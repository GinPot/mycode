/*
 * $QNXLicenseC:
 * Copyright 2016, Freescale Semiconductor, Inc.
 * Copyright 2017 NXP
 * Copyright 2018, QNX Software Systems.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You
 * may not reproduce, modify or distribute this software except in
 * compliance with the License. You may obtain a copy of the License
 * at: http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
 *
 * This file may contain contributions from others, either as
 * contributors under the License or as licensors under other terms.
 * Please review this entire file for other proprietary rights or license
 * notices, as well as the QNX Development Suite License Guide at
 * http://licensing.qnx.com/license-guide/ for other information.
 * $
 */

/*!
 * @file USB3_USBSS.h
 * @date date-of-generation
 * @brief USB3_USBSS memory map for QNX USB3_USBSS memory map for i.MX
 *
 * QNX USB3_USBSS memory map for i.MX
 */

#ifndef IMX_USB3_USBSS_H_
#define IMX_USB3_USBSS_H_

#include <stdint.h>


/* IMX_USB3_USBSS_OTGCMD - OTG Command */
typedef union IMX_USB3_USBSS_OTGCMD_union_t {
    uint32_t R;
    struct {
        uint32_t DEV_BUS_REQ :1;                 /* Request the bus for Device mode. It will set DEV_ACTIVE bit is OTGSTS register */
        uint32_t HOST_BUS_REQ :1;                /* Request the bus for Host mode. It will set HOST_ACTIVE bit is OTGSTS register */
        uint32_t OTG_EN      :1;                 /* Enable OTG mode. It will set OTG_IS_ENABLED bit is OTGSTS register */
        uint32_t OTG_DIS     :1;                 /* Disable OTG mode. It will clear OTG_IS_ENABLED bit is OTGSTS register */
        uint32_t A_DEV_EN    :1;                 /* Configure OTG as A-Device. It is only valid if OTG mode is enabled. This bit should be set in the same time when OTG_EN */
        uint32_t A_DEV_DIS   :1;                 /* Configure OTG as B-Device. It is only valid if OTG mode is enabled. This bit should be set in the same time when OTG_EN */
        uint32_t DEV_SESS_VLD_USE_SET :1;        /* Device should use b_sess_vld as vbus valid indication. This bit should be set in the same time when DEV_BUS_REQ */
        uint32_t DEV_SESS_VLD_USE_CLR :1;        /* Device should use a_vbus_vld as vbus valid indication. This bit should be set in the same time when DEV_BUS_REQ */
        uint32_t DEV_BUS_DROP :1;                /* Drop the bus for Device mode. This bit should be set when Device mode is no longer needed. It will clear DEV_ACTIVE bit is OTGSTS register */
        uint32_t HOST_BUS_DROP :1;               /* Drop the bus for Host mode. This bit should be set when Host mode is no longer needed. It will clear HOST_ACTIVE bit is OTGSTS register */
        uint32_t DIS_VBUS_DROP :1;               /* Do not disable vbus while bus is dropped. This bit is valid only if DEV_BUS_DROP or HOST_BUS_DROP are set. */
        uint32_t DEV_POWER_OFF :1;               /* Power Down USBSS-DEV. */
        uint32_t HOST_POWER_OFF :1;              /* Power Down CDNSXHCI. */
        uint32_t DEV_DEVEN_FORCE_SET :1;         /* Set forcing Device DEVEN bit to 1. This bit may be set while switching from Host to Device mode takes place. Setting this bit should be done in the same time when Device mode is activated (DEV_BUS_REQ). Setting this bit causes DEV_DEVEN_FORCE bit in OTGSTS set. */
        uint32_t DEV_DEVEN_FORCE_CLR :1;         /* Clear forcing Device DEVEN bit to 1. Setting this bit causes DEV_DEVEN_FORCE bit in OTGSTS clear. */
        uint32_t H_WRST_FOR_SWAP_SET :1;         /* Upcoming Warm Reset will be generated for Role Swapping. This bit should be set before Warm Reset for Role Swap is generated on the Port */
        uint32_t H_WRST_FOR_SWAP_CLR :1;         /* Upcoming Warm Reset will not be generated for Role Swapping. This bit should be set after Warm Reset for Role Swap is generated on the Port */
        uint32_t D_WRST_FOR_SWAP_SET :1;         /* Upcoming Warm Reset will be received for Role Swapping. This bit should be set before Warm Reset for Role Swap is received on the Port */
        uint32_t D_WRST_FOR_SWAP_CLR :1;         /* Upcoming received Warm Reset should not be treated as Role Swapping indication. This bit should be set after Warm Reset for Role Swap is received on the Port */
        uint32_t SS_HOST_DISABLED_SET :1;        /* Disable SuperSpeed host functionality. Can be used only if Host mode is not active. */
        uint32_t SS_HOST_DISABLED_CLR :1;        /* Enable SuperSpeed host functionality. */
        uint32_t SS_PERIPH_DISABLED_SET :1;      /* Disable SuperSpeed peripheral device functionality. Can be used only if Peripheral mode is not active. */
        uint32_t SS_PERIPH_DISABLED_CLR :1;      /* Enable SuperSpeed peripheral device functionality. */
        uint32_t A_SET_B_HNP_EN_SET :1;          /* This bit should be written if SetFeature(b_hnp_enable) has been sent. */
        uint32_t A_SET_B_HNP_EN_CLR :1;          /* This bit should be written if upcoming USB 2.0 bus suspend should not cause Role Swap. */
        uint32_t B_HNP_EN_SET :1;                /* This bit should be written if SetFeature(b_hnp_enable) has been accepted. */
        uint32_t B_HNP_EN_CLR :1;                /* This bit should be written if software wants to clear b_hnp_enable */
        uint32_t OTG2_SWITCH_TO_PERIPH :1;       /* Switch to Peripheral mode when operating at USB 2.0 */
        uint32_t INIT_SRP    :1;                 /* Initiate SRP */
        uint32_t DEV_VBUS_DEB_SHORT_SET :1;      /* Enable forcing Device short VBUS debounce time. This bit should be set while switching from Host to Device mode takes place. Setting this bit should be done in the same time when Device mode is activated (DEV_BUS_REQ). Setting this bit causes DEV_VBUS_DEB_SHORT bit in OTGSTS set. */
        uint32_t DEV_VBUS_DEB_SHORT_CLR :1;      /* Disable forcing Device short VBUS debounce time. Setting this bit causes DEV_VBUS_DEB_SHORT bit in OTGSTS clear. */
        uint32_t _unused31   :1;
    } B;
} IMX_USB3_USBSS_OTGCMD_t;

/* Register OTGCMD - OTG Command */
#define IMX_USB3_USBSS_OTGCMD_OFFSET 0
/* Field DEV_BUS_REQ - Request the bus for Device mode. It will set DEV_ACTIVE bit is OTGSTS register */
#define IMX_USB3_USBSS_OTGCMD_DEV_BUS_REQ_SHIFT 0
#define IMX_USB3_USBSS_OTGCMD_DEV_BUS_REQ_MASK 0x1
#define IMX_USB3_USBSS_OTGCMD_DEV_BUS_REQ(v) (((v) << 0) & 0x1)
/* Field HOST_BUS_REQ - Request the bus for Host mode. It will set HOST_ACTIVE bit is OTGSTS register */
#define IMX_USB3_USBSS_OTGCMD_HOST_BUS_REQ_SHIFT 1
#define IMX_USB3_USBSS_OTGCMD_HOST_BUS_REQ_MASK 0x2
#define IMX_USB3_USBSS_OTGCMD_HOST_BUS_REQ(v) (((v) << 0x1) & 0x2)
/* Field OTG_EN - Enable OTG mode. It will set OTG_IS_ENABLED bit is OTGSTS register */
#define IMX_USB3_USBSS_OTGCMD_OTG_EN_SHIFT 2
#define IMX_USB3_USBSS_OTGCMD_OTG_EN_MASK 0x4
#define IMX_USB3_USBSS_OTGCMD_OTG_EN(v) (((v) << 0x2) & 0x4)
/* Field OTG_DIS - Disable OTG mode. It will clear OTG_IS_ENABLED bit is OTGSTS register */
#define IMX_USB3_USBSS_OTGCMD_OTG_DIS_SHIFT 3
#define IMX_USB3_USBSS_OTGCMD_OTG_DIS_MASK 0x8
#define IMX_USB3_USBSS_OTGCMD_OTG_DIS(v) (((v) << 0x3) & 0x8)
/* Field A_DEV_EN - Configure OTG as A-Device. It is only valid if OTG mode is enabled. This bit should be set in the same time when OTG_EN */
#define IMX_USB3_USBSS_OTGCMD_A_DEV_EN_SHIFT 4
#define IMX_USB3_USBSS_OTGCMD_A_DEV_EN_MASK 0x10
#define IMX_USB3_USBSS_OTGCMD_A_DEV_EN(v) (((v) << 0x4) & 0x10)
/* Field A_DEV_DIS - Configure OTG as B-Device. It is only valid if OTG mode is enabled. This bit should be set in the same time when OTG_EN */
#define IMX_USB3_USBSS_OTGCMD_A_DEV_DIS_SHIFT 5
#define IMX_USB3_USBSS_OTGCMD_A_DEV_DIS_MASK 0x20
#define IMX_USB3_USBSS_OTGCMD_A_DEV_DIS(v) (((v) << 0x5) & 0x20)
/* Field DEV_SESS_VLD_USE_SET - Device should use b_sess_vld as vbus valid indication. This bit should be set in the same time when DEV_BUS_REQ */
#define IMX_USB3_USBSS_OTGCMD_DEV_SESS_VLD_USE_SET_SHIFT 6
#define IMX_USB3_USBSS_OTGCMD_DEV_SESS_VLD_USE_SET_MASK 0x40
#define IMX_USB3_USBSS_OTGCMD_DEV_SESS_VLD_USE_SET(v) (((v) << 0x6) & 0x40)
/* Field DEV_SESS_VLD_USE_CLR - Device should use a_vbus_vld as vbus valid indication. This bit should be set in the same time when DEV_BUS_REQ */
#define IMX_USB3_USBSS_OTGCMD_DEV_SESS_VLD_USE_CLR_SHIFT 7
#define IMX_USB3_USBSS_OTGCMD_DEV_SESS_VLD_USE_CLR_MASK 0x80
#define IMX_USB3_USBSS_OTGCMD_DEV_SESS_VLD_USE_CLR(v) (((v) << 0x7) & 0x80)
/* Field DEV_BUS_DROP - Drop the bus for Device mode. This bit should be set when Device mode is no longer needed. It will clear DEV_ACTIVE bit is OTGSTS register */
#define IMX_USB3_USBSS_OTGCMD_DEV_BUS_DROP_SHIFT 8
#define IMX_USB3_USBSS_OTGCMD_DEV_BUS_DROP_MASK 0x100
#define IMX_USB3_USBSS_OTGCMD_DEV_BUS_DROP(v) (((v) << 0x8) & 0x100)
/* Field HOST_BUS_DROP - Drop the bus for Host mode. This bit should be set when Host mode is no longer needed. It will clear HOST_ACTIVE bit is OTGSTS register */
#define IMX_USB3_USBSS_OTGCMD_HOST_BUS_DROP_SHIFT 9
#define IMX_USB3_USBSS_OTGCMD_HOST_BUS_DROP_MASK 0x200
#define IMX_USB3_USBSS_OTGCMD_HOST_BUS_DROP(v) (((v) << 0x9) & 0x200)
/* Field DIS_VBUS_DROP - Do not disable vbus while bus is dropped. This bit is valid only if DEV_BUS_DROP or HOST_BUS_DROP are set. */
#define IMX_USB3_USBSS_OTGCMD_DIS_VBUS_DROP_SHIFT 10
#define IMX_USB3_USBSS_OTGCMD_DIS_VBUS_DROP_MASK 0x400
#define IMX_USB3_USBSS_OTGCMD_DIS_VBUS_DROP(v) (((v) << 0xA) & 0x400)
/* Field DEV_POWER_OFF - Power Down USBSS-DEV. */
#define IMX_USB3_USBSS_OTGCMD_DEV_POWER_OFF_SHIFT 11
#define IMX_USB3_USBSS_OTGCMD_DEV_POWER_OFF_MASK 0x800
#define IMX_USB3_USBSS_OTGCMD_DEV_POWER_OFF(v) (((v) << 0xB) & 0x800)
/* Field HOST_POWER_OFF - Power Down CDNSXHCI. */
#define IMX_USB3_USBSS_OTGCMD_HOST_POWER_OFF_SHIFT 12
#define IMX_USB3_USBSS_OTGCMD_HOST_POWER_OFF_MASK 0x1000
#define IMX_USB3_USBSS_OTGCMD_HOST_POWER_OFF(v) (((v) << 0xC) & 0x1000)
/* Field DEV_DEVEN_FORCE_SET - Set forcing Device DEVEN bit to 1. This bit may be set while switching from Host to Device mode takes place. Setting this bit should be done in the same time when Device mode is activated (DEV_BUS_REQ). Setting this bit causes DEV_DEVEN_FORCE bit in OTGSTS set. */
#define IMX_USB3_USBSS_OTGCMD_DEV_DEVEN_FORCE_SET_SHIFT 13
#define IMX_USB3_USBSS_OTGCMD_DEV_DEVEN_FORCE_SET_MASK 0x2000
#define IMX_USB3_USBSS_OTGCMD_DEV_DEVEN_FORCE_SET(v) (((v) << 0xD) & 0x2000)
/* Field DEV_DEVEN_FORCE_CLR - Clear forcing Device DEVEN bit to 1. Setting this bit causes DEV_DEVEN_FORCE bit in OTGSTS clear. */
#define IMX_USB3_USBSS_OTGCMD_DEV_DEVEN_FORCE_CLR_SHIFT 14
#define IMX_USB3_USBSS_OTGCMD_DEV_DEVEN_FORCE_CLR_MASK 0x4000
#define IMX_USB3_USBSS_OTGCMD_DEV_DEVEN_FORCE_CLR(v) (((v) << 0xE) & 0x4000)
/* Field H_WRST_FOR_SWAP_SET - Upcoming Warm Reset will be generated for Role Swapping. This bit should be set before Warm Reset for Role Swap is generated on the Port */
#define IMX_USB3_USBSS_OTGCMD_H_WRST_FOR_SWAP_SET_SHIFT 15
#define IMX_USB3_USBSS_OTGCMD_H_WRST_FOR_SWAP_SET_MASK 0x8000
#define IMX_USB3_USBSS_OTGCMD_H_WRST_FOR_SWAP_SET(v) (((v) << 0xF) & 0x8000)
/* Field H_WRST_FOR_SWAP_CLR - Upcoming Warm Reset will not be generated for Role Swapping. This bit should be set after Warm Reset for Role Swap is generated on the Port */
#define IMX_USB3_USBSS_OTGCMD_H_WRST_FOR_SWAP_CLR_SHIFT 16
#define IMX_USB3_USBSS_OTGCMD_H_WRST_FOR_SWAP_CLR_MASK 0x10000
#define IMX_USB3_USBSS_OTGCMD_H_WRST_FOR_SWAP_CLR(v) (((v) << 0x10) & 0x10000)
/* Field D_WRST_FOR_SWAP_SET - Upcoming Warm Reset will be received for Role Swapping. This bit should be set before Warm Reset for Role Swap is received on the Port */
#define IMX_USB3_USBSS_OTGCMD_D_WRST_FOR_SWAP_SET_SHIFT 17
#define IMX_USB3_USBSS_OTGCMD_D_WRST_FOR_SWAP_SET_MASK 0x20000
#define IMX_USB3_USBSS_OTGCMD_D_WRST_FOR_SWAP_SET(v) (((v) << 0x11) & 0x20000)
/* Field D_WRST_FOR_SWAP_CLR - Upcoming received Warm Reset should not be treated as Role Swapping indication. This bit should be set after Warm Reset for Role Swap is received on the Port */
#define IMX_USB3_USBSS_OTGCMD_D_WRST_FOR_SWAP_CLR_SHIFT 18
#define IMX_USB3_USBSS_OTGCMD_D_WRST_FOR_SWAP_CLR_MASK 0x40000
#define IMX_USB3_USBSS_OTGCMD_D_WRST_FOR_SWAP_CLR(v) (((v) << 0x12) & 0x40000)
/* Field SS_HOST_DISABLED_SET - Disable SuperSpeed host functionality. Can be used only if Host mode is not active. */
#define IMX_USB3_USBSS_OTGCMD_SS_HOST_DISABLED_SET_SHIFT 19
#define IMX_USB3_USBSS_OTGCMD_SS_HOST_DISABLED_SET_MASK 0x80000
#define IMX_USB3_USBSS_OTGCMD_SS_HOST_DISABLED_SET(v) (((v) << 0x13) & 0x80000)
/* Field SS_HOST_DISABLED_CLR - Enable SuperSpeed host functionality. */
#define IMX_USB3_USBSS_OTGCMD_SS_HOST_DISABLED_CLR_SHIFT 20
#define IMX_USB3_USBSS_OTGCMD_SS_HOST_DISABLED_CLR_MASK 0x100000
#define IMX_USB3_USBSS_OTGCMD_SS_HOST_DISABLED_CLR(v) (((v) << 0x14) & 0x100000)
/* Field SS_PERIPH_DISABLED_SET - Disable SuperSpeed peripheral device functionality. Can be used only if Peripheral mode is not active. */
#define IMX_USB3_USBSS_OTGCMD_SS_PERIPH_DISABLED_SET_SHIFT 21
#define IMX_USB3_USBSS_OTGCMD_SS_PERIPH_DISABLED_SET_MASK 0x200000
#define IMX_USB3_USBSS_OTGCMD_SS_PERIPH_DISABLED_SET(v) (((v) << 0x15) & 0x200000)
/* Field SS_PERIPH_DISABLED_CLR - Enable SuperSpeed peripheral device functionality. */
#define IMX_USB3_USBSS_OTGCMD_SS_PERIPH_DISABLED_CLR_SHIFT 22
#define IMX_USB3_USBSS_OTGCMD_SS_PERIPH_DISABLED_CLR_MASK 0x400000
#define IMX_USB3_USBSS_OTGCMD_SS_PERIPH_DISABLED_CLR(v) (((v) << 0x16) & 0x400000)
/* Field A_SET_B_HNP_EN_SET - This bit should be written if SetFeature(b_hnp_enable) has been sent. */
#define IMX_USB3_USBSS_OTGCMD_A_SET_B_HNP_EN_SET_SHIFT 23
#define IMX_USB3_USBSS_OTGCMD_A_SET_B_HNP_EN_SET_MASK 0x800000
#define IMX_USB3_USBSS_OTGCMD_A_SET_B_HNP_EN_SET(v) (((v) << 0x17) & 0x800000)
/* Field A_SET_B_HNP_EN_CLR - This bit should be written if upcoming USB 2.0 bus suspend should not cause Role Swap. */
#define IMX_USB3_USBSS_OTGCMD_A_SET_B_HNP_EN_CLR_SHIFT 24
#define IMX_USB3_USBSS_OTGCMD_A_SET_B_HNP_EN_CLR_MASK 0x1000000
#define IMX_USB3_USBSS_OTGCMD_A_SET_B_HNP_EN_CLR(v) (((v) << 0x18) & 0x1000000)
/* Field B_HNP_EN_SET - This bit should be written if SetFeature(b_hnp_enable) has been accepted. */
#define IMX_USB3_USBSS_OTGCMD_B_HNP_EN_SET_SHIFT 25
#define IMX_USB3_USBSS_OTGCMD_B_HNP_EN_SET_MASK 0x2000000
#define IMX_USB3_USBSS_OTGCMD_B_HNP_EN_SET(v) (((v) << 0x19) & 0x2000000)
/* Field B_HNP_EN_CLR - This bit should be written if software wants to clear b_hnp_enable */
#define IMX_USB3_USBSS_OTGCMD_B_HNP_EN_CLR_SHIFT 26
#define IMX_USB3_USBSS_OTGCMD_B_HNP_EN_CLR_MASK 0x4000000
#define IMX_USB3_USBSS_OTGCMD_B_HNP_EN_CLR(v) (((v) << 0x1A) & 0x4000000)
/* Field OTG2_SWITCH_TO_PERIPH - Switch to Peripheral mode when operating at USB 2.0 */
#define IMX_USB3_USBSS_OTGCMD_OTG2_SWITCH_TO_PERIPH_SHIFT 27
#define IMX_USB3_USBSS_OTGCMD_OTG2_SWITCH_TO_PERIPH_MASK 0x8000000
#define IMX_USB3_USBSS_OTGCMD_OTG2_SWITCH_TO_PERIPH(v) (((v) << 0x1B) & 0x8000000)
/* Field INIT_SRP - Initiate SRP */
#define IMX_USB3_USBSS_OTGCMD_INIT_SRP_SHIFT 28
#define IMX_USB3_USBSS_OTGCMD_INIT_SRP_MASK 0x10000000
#define IMX_USB3_USBSS_OTGCMD_INIT_SRP(v) (((v) << 0x1C) & 0x10000000)
/* Field DEV_VBUS_DEB_SHORT_SET - Enable forcing Device short VBUS debounce time. This bit should be set while switching from Host to Device mode takes place. Setting this bit should be done in the same time when Device mode is activated (DEV_BUS_REQ). Setting this bit causes DEV_VBUS_DEB_SHORT bit in OTGSTS set. */
#define IMX_USB3_USBSS_OTGCMD_DEV_VBUS_DEB_SHORT_SET_SHIFT 29
#define IMX_USB3_USBSS_OTGCMD_DEV_VBUS_DEB_SHORT_SET_MASK 0x20000000
#define IMX_USB3_USBSS_OTGCMD_DEV_VBUS_DEB_SHORT_SET(v) (((v) << 0x1D) & 0x20000000)
/* Field DEV_VBUS_DEB_SHORT_CLR - Disable forcing Device short VBUS debounce time. Setting this bit causes DEV_VBUS_DEB_SHORT bit in OTGSTS clear. */
#define IMX_USB3_USBSS_OTGCMD_DEV_VBUS_DEB_SHORT_CLR_SHIFT 30
#define IMX_USB3_USBSS_OTGCMD_DEV_VBUS_DEB_SHORT_CLR_MASK 0x40000000
#define IMX_USB3_USBSS_OTGCMD_DEV_VBUS_DEB_SHORT_CLR(v) (((v) << 0x1E) & 0x40000000)

/* IMX_USB3_USBSS_OTGSTS - OTG Status */
typedef union IMX_USB3_USBSS_OTGSTS_union_t {
    uint32_t R;
    struct {
        uint32_t ID_VALUE    :1;                 /* Current value of the ID pin. It is only valid when idpullup in OTGCTRL1_TYPE register is set to '1'. ID_VALUE must be valid within 50ms after idpullup is set to '1' */
        uint32_t VBUS_VALID  :1;                 /* Current value of the vbus_valid */
        uint32_t SESSION_VALID :1;               /* Current value of the b_sess_vld */
        uint32_t DEV_ACTIVE  :1;                 /* Device mode is active. NOTE: It is possible that Device is in inactive state (even turned off) while DEV_ACTIVE is 1. */
        uint32_t HOST_ACTIVE :1;                 /* Device mode is active. NOTE: It is possible that Host is in inactive state (even turned off) while HOST_ACTIVE is 1. */
        uint32_t OTG_IS_ENABLED :1;              /* OTG functionality is enabled */
        uint32_t OTG_MODE    :1;                 /* OTG mode: 0 - A-Device 1 - B-Device Valid only if OTG_IS_ENABLED is 1. */
        uint32_t SS_HOST_DISABLED :1;            /* SuperSpeed host functionality is disabled. Port will be operating at USB 2.0 speed. */
        uint32_t SS_PERIPH_DISABLED :1;          /* SuperSpeed device functionality is disabled. Port will be operating at USB 2.0 speed. */
        uint32_t DEV_VBUS_DEB_SHORT :1;          /* Device forcing short VBUS decounce is enabled. */
        uint32_t DEV_SESS_VLD_USE :1;            /* Device mode vbus valid indication: 0: a_vbus_vld is used as vbus valid 1: b_sess_vld is used as vbus valid */
        uint32_t OTG_NRDY    :1;                 /* OTG Controller not ready. Software shall not read nor write any register except OTGISTS if this bit is set. */
        uint32_t STRAP       :3;                 /* Value of the strap pins. 000 - no default configuration 010 - Controller initiall configured as Host 100 - Controller initially configured as Device other - Reserved (might be used for Type-C) */
        uint32_t H_WRST_FOR_SWAP :1;             /* Upcoming Warm Reset will be generated for Role Swapping from Host to Peripheral. */
        uint32_t DEV_DEVEN_FORCE :1;             /* Device forcing DEVEN bit is enabled. */
        uint32_t D_WRST_FOR_SWAP :1;             /* Upcoming Warm Reset will be received for Role Swapping from Peripheral to Host. */
        uint32_t SRP_INITIAL_CONDITION_MET :1;   /* SRP initial condition are met. OTG B-device software should issue SRP puluse onli if this bit is set. */
        uint32_t SRP_DET_NOT_COMPLIANT_DEV :1;   /* OTG A-device detected not compilant device. If this bit is set then OTG A-device should disable SRP detection until not compilant device is disconnected (SRP_NOT_COMP_DEV_REMOVED_INT) */
        uint32_t _unused20   :3;
        uint32_t A_SET_B_HNP_EN :1;              /* SetFeature(b_hnp_enable) has been sent and is valid. */
        uint32_t _unused24   :1;
        uint32_t B_HNP_EN    :1;                 /* SetFeature(b_hnp_enable) has been accepted. */
        uint32_t XHC_READY   :1;                 /* Host mode is turned on; registers in CDNSXHCI AUX domain are accessible through APB */
        uint32_t DEV_READY   :1;                 /* Device mode is turned on; registers in USBSS-DEV domain are accessible through APB */
        uint32_t _unused28   :4;
    } B;
} IMX_USB3_USBSS_OTGSTS_t;

/* Register OTGSTS - OTG Status */
#define IMX_USB3_USBSS_OTGSTS_OFFSET 0x4
/* Field ID_VALUE - Current value of the ID pin. It is only valid when idpullup in OTGCTRL1_TYPE register is set to '1'. ID_VALUE must be valid within 50ms after idpullup is set to '1' */
#define IMX_USB3_USBSS_OTGSTS_ID_VALUE_SHIFT 0
#define IMX_USB3_USBSS_OTGSTS_ID_VALUE_MASK 0x1
#define IMX_USB3_USBSS_OTGSTS_ID_VALUE(v) (((v) << 0) & 0x1)
/* Field VBUS_VALID - Current value of the vbus_valid */
#define IMX_USB3_USBSS_OTGSTS_VBUS_VALID_SHIFT 1
#define IMX_USB3_USBSS_OTGSTS_VBUS_VALID_MASK 0x2
#define IMX_USB3_USBSS_OTGSTS_VBUS_VALID(v) (((v) << 0x1) & 0x2)
/* Field SESSION_VALID - Current value of the b_sess_vld */
#define IMX_USB3_USBSS_OTGSTS_SESSION_VALID_SHIFT 2
#define IMX_USB3_USBSS_OTGSTS_SESSION_VALID_MASK 0x4
#define IMX_USB3_USBSS_OTGSTS_SESSION_VALID(v) (((v) << 0x2) & 0x4)
/* Field DEV_ACTIVE - Device mode is active. NOTE: It is possible that Device is in inactive state (even turned off) while DEV_ACTIVE is 1. */
#define IMX_USB3_USBSS_OTGSTS_DEV_ACTIVE_SHIFT 3
#define IMX_USB3_USBSS_OTGSTS_DEV_ACTIVE_MASK 0x8
#define IMX_USB3_USBSS_OTGSTS_DEV_ACTIVE(v) (((v) << 0x3) & 0x8)
/* Field HOST_ACTIVE - Device mode is active. NOTE: It is possible that Host is in inactive state (even turned off) while HOST_ACTIVE is 1. */
#define IMX_USB3_USBSS_OTGSTS_HOST_ACTIVE_SHIFT 4
#define IMX_USB3_USBSS_OTGSTS_HOST_ACTIVE_MASK 0x10
#define IMX_USB3_USBSS_OTGSTS_HOST_ACTIVE(v) (((v) << 0x4) & 0x10)
/* Field OTG_IS_ENABLED - OTG functionality is enabled */
#define IMX_USB3_USBSS_OTGSTS_OTG_IS_ENABLED_SHIFT 5
#define IMX_USB3_USBSS_OTGSTS_OTG_IS_ENABLED_MASK 0x20
#define IMX_USB3_USBSS_OTGSTS_OTG_IS_ENABLED(v) (((v) << 0x5) & 0x20)
/* Field OTG_MODE - OTG mode: 0 - A-Device 1 - B-Device Valid only if OTG_IS_ENABLED is 1. */
#define IMX_USB3_USBSS_OTGSTS_OTG_MODE_SHIFT 6
#define IMX_USB3_USBSS_OTGSTS_OTG_MODE_MASK 0x40
#define IMX_USB3_USBSS_OTGSTS_OTG_MODE(v) (((v) << 0x6) & 0x40)
/* Field SS_HOST_DISABLED - SuperSpeed host functionality is disabled. Port will be operating at USB 2.0 speed. */
#define IMX_USB3_USBSS_OTGSTS_SS_HOST_DISABLED_SHIFT 7
#define IMX_USB3_USBSS_OTGSTS_SS_HOST_DISABLED_MASK 0x80
#define IMX_USB3_USBSS_OTGSTS_SS_HOST_DISABLED(v) (((v) << 0x7) & 0x80)
/* Field SS_PERIPH_DISABLED - SuperSpeed device functionality is disabled. Port will be operating at USB 2.0 speed. */
#define IMX_USB3_USBSS_OTGSTS_SS_PERIPH_DISABLED_SHIFT 8
#define IMX_USB3_USBSS_OTGSTS_SS_PERIPH_DISABLED_MASK 0x100
#define IMX_USB3_USBSS_OTGSTS_SS_PERIPH_DISABLED(v) (((v) << 0x8) & 0x100)
/* Field DEV_VBUS_DEB_SHORT - Device forcing short VBUS decounce is enabled. */
#define IMX_USB3_USBSS_OTGSTS_DEV_VBUS_DEB_SHORT_SHIFT 9
#define IMX_USB3_USBSS_OTGSTS_DEV_VBUS_DEB_SHORT_MASK 0x200
#define IMX_USB3_USBSS_OTGSTS_DEV_VBUS_DEB_SHORT(v) (((v) << 0x9) & 0x200)
/* Field DEV_SESS_VLD_USE - Device mode vbus valid indication: 0: a_vbus_vld is used as vbus valid 1: b_sess_vld is used as vbus valid */
#define IMX_USB3_USBSS_OTGSTS_DEV_SESS_VLD_USE_SHIFT 10
#define IMX_USB3_USBSS_OTGSTS_DEV_SESS_VLD_USE_MASK 0x400
#define IMX_USB3_USBSS_OTGSTS_DEV_SESS_VLD_USE(v) (((v) << 0xA) & 0x400)
/* Field OTG_NRDY - OTG Controller not ready. Software shall not read nor write any register except OTGISTS if this bit is set. */
#define IMX_USB3_USBSS_OTGSTS_OTG_NRDY_SHIFT 11
#define IMX_USB3_USBSS_OTGSTS_OTG_NRDY_MASK 0x800
#define IMX_USB3_USBSS_OTGSTS_OTG_NRDY(v) (((v) << 0xB) & 0x800)
/* Field STRAP - Value of the strap pins. 000 - no default configuration 010 - Controller initiall configured as Host 100 - Controller initially configured as Device other - Reserved (might be used for Type-C) */
#define IMX_USB3_USBSS_OTGSTS_STRAP_SHIFT 12
#define IMX_USB3_USBSS_OTGSTS_STRAP_MASK 0x7000
#define IMX_USB3_USBSS_OTGSTS_STRAP(v) (((v) << 0xC) & 0x7000)
/* Field H_WRST_FOR_SWAP - Upcoming Warm Reset will be generated for Role Swapping from Host to Peripheral. */
#define IMX_USB3_USBSS_OTGSTS_H_WRST_FOR_SWAP_SHIFT 15
#define IMX_USB3_USBSS_OTGSTS_H_WRST_FOR_SWAP_MASK 0x8000
#define IMX_USB3_USBSS_OTGSTS_H_WRST_FOR_SWAP(v) (((v) << 0xF) & 0x8000)
/* Field DEV_DEVEN_FORCE - Device forcing DEVEN bit is enabled. */
#define IMX_USB3_USBSS_OTGSTS_DEV_DEVEN_FORCE_SHIFT 16
#define IMX_USB3_USBSS_OTGSTS_DEV_DEVEN_FORCE_MASK 0x10000
#define IMX_USB3_USBSS_OTGSTS_DEV_DEVEN_FORCE(v) (((v) << 0x10) & 0x10000)
/* Field D_WRST_FOR_SWAP - Upcoming Warm Reset will be received for Role Swapping from Peripheral to Host. */
#define IMX_USB3_USBSS_OTGSTS_D_WRST_FOR_SWAP_SHIFT 17
#define IMX_USB3_USBSS_OTGSTS_D_WRST_FOR_SWAP_MASK 0x20000
#define IMX_USB3_USBSS_OTGSTS_D_WRST_FOR_SWAP(v) (((v) << 0x11) & 0x20000)
/* Field SRP_INITIAL_CONDITION_MET - SRP initial condition are met. OTG B-device software should issue SRP puluse onli if this bit is set. */
#define IMX_USB3_USBSS_OTGSTS_SRP_INITIAL_CONDITION_MET_SHIFT 18
#define IMX_USB3_USBSS_OTGSTS_SRP_INITIAL_CONDITION_MET_MASK 0x40000
#define IMX_USB3_USBSS_OTGSTS_SRP_INITIAL_CONDITION_MET(v) (((v) << 0x12) & 0x40000)
/* Field SRP_DET_NOT_COMPLIANT_DEV - OTG A-device detected not compilant device. If this bit is set then OTG A-device should disable SRP detection until not compilant device is disconnected (SRP_NOT_COMP_DEV_REMOVED_INT) */
#define IMX_USB3_USBSS_OTGSTS_SRP_DET_NOT_COMPLIANT_DEV_SHIFT 19
#define IMX_USB3_USBSS_OTGSTS_SRP_DET_NOT_COMPLIANT_DEV_MASK 0x80000
#define IMX_USB3_USBSS_OTGSTS_SRP_DET_NOT_COMPLIANT_DEV(v) (((v) << 0x13) & 0x80000)
/* Field A_SET_B_HNP_EN - SetFeature(b_hnp_enable) has been sent and is valid. */
#define IMX_USB3_USBSS_OTGSTS_A_SET_B_HNP_EN_SHIFT 23
#define IMX_USB3_USBSS_OTGSTS_A_SET_B_HNP_EN_MASK 0x800000
#define IMX_USB3_USBSS_OTGSTS_A_SET_B_HNP_EN(v) (((v) << 0x17) & 0x800000)
/* Field B_HNP_EN - SetFeature(b_hnp_enable) has been accepted. */
#define IMX_USB3_USBSS_OTGSTS_B_HNP_EN_SHIFT 25
#define IMX_USB3_USBSS_OTGSTS_B_HNP_EN_MASK 0x2000000
#define IMX_USB3_USBSS_OTGSTS_B_HNP_EN(v) (((v) << 0x19) & 0x2000000)
/* Field XHC_READY - Host mode is turned on; registers in CDNSXHCI AUX domain are accessible through APB */
#define IMX_USB3_USBSS_OTGSTS_XHC_READY_SHIFT 26
#define IMX_USB3_USBSS_OTGSTS_XHC_READY_MASK 0x4000000
#define IMX_USB3_USBSS_OTGSTS_XHC_READY(v) (((v) << 0x1A) & 0x4000000)
/* Field DEV_READY - Device mode is turned on; registers in USBSS-DEV domain are accessible through APB */
#define IMX_USB3_USBSS_OTGSTS_DEV_READY_SHIFT 27
#define IMX_USB3_USBSS_OTGSTS_DEV_READY_MASK 0x8000000
#define IMX_USB3_USBSS_OTGSTS_DEV_READY(v) (((v) << 0x1B) & 0x8000000)

/* IMX_USB3_USBSS_OTGSTATE - OTG State */
typedef union IMX_USB3_USBSS_OTGSTATE_union_t {
    uint32_t R;
    struct {
        uint32_t DEV_OTG_STATE :3;               /* Current state of the OTG Device FSM */
        uint32_t HOST_OTG_STATE :3;              /* Current state of the OTG Host FSM */
        uint32_t _unused6    :2;
        uint32_t APB_AXI_CTRL :2;                /* Current state of the ABP/AXI mux selector */
        uint32_t PIPE_CTRL   :2;                 /* Current state of the USB3 PIPE mux selector */
        uint32_t UTMI_CTRL   :2;                 /* Current state of the USB2 UTMI mux selector */
        uint32_t _unused14   :2;
        uint32_t DEV_POWER_STATE :3;             /* Current state of the Device power controlling FSM */
        uint32_t HOST_POWER_STATE :3;            /* Current state of the Host power controlling FSM */
        uint32_t _unused22   :2;
        uint32_t PHY_REFCLK_REQ :1;              /* Value of the phy_refclk_req signal from the PHY Reference Clock Control interface */
        uint32_t PHY_REFCLK_1PCT_VALID :1;       /* Value of the phy_refclk_1pct_valid signal from the PHY Reference Clock Control interface */
        uint32_t PHY_REFCLK_VALID :1;            /* Value of the phy_refclk_valid signal from the PHY Reference Clock Control interface */
        uint32_t REFCLK_FSM  :3;                 /* Reference Clock control FSM state */
        uint32_t _unused30   :2;
    } B;
} IMX_USB3_USBSS_OTGSTATE_t;

/* Register OTGSTATE - OTG State */
#define IMX_USB3_USBSS_OTGSTATE_OFFSET 0x8
/* Field DEV_OTG_STATE - Current state of the OTG Device FSM */
#define IMX_USB3_USBSS_OTGSTATE_DEV_OTG_STATE_SHIFT 0
#define IMX_USB3_USBSS_OTGSTATE_DEV_OTG_STATE_MASK 0x7
#define IMX_USB3_USBSS_OTGSTATE_DEV_OTG_STATE(v) (((v) << 0) & 0x7)
/* Field HOST_OTG_STATE - Current state of the OTG Host FSM */
#define IMX_USB3_USBSS_OTGSTATE_HOST_OTG_STATE_SHIFT 3
#define IMX_USB3_USBSS_OTGSTATE_HOST_OTG_STATE_MASK 0x38
#define IMX_USB3_USBSS_OTGSTATE_HOST_OTG_STATE(v) (((v) << 0x3) & 0x38)
/* Field APB_AXI_CTRL - Current state of the ABP/AXI mux selector */
#define IMX_USB3_USBSS_OTGSTATE_APB_AXI_CTRL_SHIFT 8
#define IMX_USB3_USBSS_OTGSTATE_APB_AXI_CTRL_MASK 0x300
#define IMX_USB3_USBSS_OTGSTATE_APB_AXI_CTRL(v) (((v) << 0x8) & 0x300)
/* Field PIPE_CTRL - Current state of the USB3 PIPE mux selector */
#define IMX_USB3_USBSS_OTGSTATE_PIPE_CTRL_SHIFT 10
#define IMX_USB3_USBSS_OTGSTATE_PIPE_CTRL_MASK 0xC00
#define IMX_USB3_USBSS_OTGSTATE_PIPE_CTRL(v) (((v) << 0xA) & 0xC00)
/* Field UTMI_CTRL - Current state of the USB2 UTMI mux selector */
#define IMX_USB3_USBSS_OTGSTATE_UTMI_CTRL_SHIFT 12
#define IMX_USB3_USBSS_OTGSTATE_UTMI_CTRL_MASK 0x3000
#define IMX_USB3_USBSS_OTGSTATE_UTMI_CTRL(v) (((v) << 0xC) & 0x3000)
/* Field DEV_POWER_STATE - Current state of the Device power controlling FSM */
#define IMX_USB3_USBSS_OTGSTATE_DEV_POWER_STATE_SHIFT 16
#define IMX_USB3_USBSS_OTGSTATE_DEV_POWER_STATE_MASK 0x70000
#define IMX_USB3_USBSS_OTGSTATE_DEV_POWER_STATE(v) (((v) << 0x10) & 0x70000)
/* Field HOST_POWER_STATE - Current state of the Host power controlling FSM */
#define IMX_USB3_USBSS_OTGSTATE_HOST_POWER_STATE_SHIFT 19
#define IMX_USB3_USBSS_OTGSTATE_HOST_POWER_STATE_MASK 0x380000
#define IMX_USB3_USBSS_OTGSTATE_HOST_POWER_STATE(v) (((v) << 0x13) & 0x380000)
/* Field PHY_REFCLK_REQ - Value of the phy_refclk_req signal from the PHY Reference Clock Control interface */
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_REQ_SHIFT 24
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_REQ_MASK 0x1000000
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_REQ(v) (((v) << 0x18) & 0x1000000)
/* Field PHY_REFCLK_1PCT_VALID - Value of the phy_refclk_1pct_valid signal from the PHY Reference Clock Control interface */
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_1PCT_VALID_SHIFT 25
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_1PCT_VALID_MASK 0x2000000
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_1PCT_VALID(v) (((v) << 0x19) & 0x2000000)
/* Field PHY_REFCLK_VALID - Value of the phy_refclk_valid signal from the PHY Reference Clock Control interface */
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_VALID_SHIFT 26
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_VALID_MASK 0x4000000
#define IMX_USB3_USBSS_OTGSTATE_PHY_REFCLK_VALID(v) (((v) << 0x1A) & 0x4000000)
/* Field REFCLK_FSM - Reference Clock control FSM state */
#define IMX_USB3_USBSS_OTGSTATE_REFCLK_FSM_SHIFT 27
#define IMX_USB3_USBSS_OTGSTATE_REFCLK_FSM_MASK 0x38000000
#define IMX_USB3_USBSS_OTGSTATE_REFCLK_FSM(v) (((v) << 0x1B) & 0x38000000)

/* IMX_USB3_USBSS_OTGREFCLK - OTG Reference Clock */
typedef union IMX_USB3_USBSS_OTGREFCLK_union_t {
    uint32_t R;
    struct {
        uint32_t P3_TO_REFCLK_REQ :14;           /* Time in stb_clk_predft clock period units within which the module won't be requesting for Reference Clock to be off after USB 3.0 PHY powerdown changes to P3 */
        uint32_t _unused14   :2;
        uint32_t SUSPEND_TO_REFCLK_REQ :14;      /* Time in stb_clk_predft clock period units within which the module won't be requesting for Reference Clock to be off after USB 2.0 PHY is requested to enter suspend (L2) state. */
        uint32_t _unused30   :1;
        uint32_t OTG_STB_CLK_SWITCH_EN :1;       /* Allow PHY Reference Clock sour to be either low frequency of turned-off when both modes (Host/Device) are disabled */
    } B;
} IMX_USB3_USBSS_OTGREFCLK_t;

/* Register OTGREFCLK - OTG Reference Clock */
#define IMX_USB3_USBSS_OTGREFCLK_OFFSET 0xC
/* Field P3_TO_REFCLK_REQ - Time in stb_clk_predft clock period units within which the module won't be requesting for Reference Clock to be off after USB 3.0 PHY powerdown changes to P3 */
#define IMX_USB3_USBSS_OTGREFCLK_P3_TO_REFCLK_REQ_SHIFT 0
#define IMX_USB3_USBSS_OTGREFCLK_P3_TO_REFCLK_REQ_MASK 0x3FFF
#define IMX_USB3_USBSS_OTGREFCLK_P3_TO_REFCLK_REQ(v) (((v) << 0) & 0x3FFF)
/* Field SUSPEND_TO_REFCLK_REQ - Time in stb_clk_predft clock period units within which the module won't be requesting for Reference Clock to be off after USB 2.0 PHY is requested to enter suspend (L2) state. */
#define IMX_USB3_USBSS_OTGREFCLK_SUSPEND_TO_REFCLK_REQ_SHIFT 16
#define IMX_USB3_USBSS_OTGREFCLK_SUSPEND_TO_REFCLK_REQ_MASK 0x3FFF0000
#define IMX_USB3_USBSS_OTGREFCLK_SUSPEND_TO_REFCLK_REQ(v) (((v) << 0x10) & 0x3FFF0000)
/* Field OTG_STB_CLK_SWITCH_EN - Allow PHY Reference Clock sour to be either low frequency of turned-off when both modes (Host/Device) are disabled */
#define IMX_USB3_USBSS_OTGREFCLK_OTG_STB_CLK_SWITCH_EN_SHIFT 31
#define IMX_USB3_USBSS_OTGREFCLK_OTG_STB_CLK_SWITCH_EN_MASK 0x80000000
#define IMX_USB3_USBSS_OTGREFCLK_OTG_STB_CLK_SWITCH_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_OTGIEN - OTG Interrupt Enable */
typedef union IMX_USB3_USBSS_OTGIEN_union_t {
    uint32_t R;
    struct {
        uint32_t ID_CHANGE_INT_EN :1;            /* ID change interrupt enable */
        uint32_t VBUS_ON_FAILED_INT_EN :1;       /* Enabling Vbus by A-Device has failed interrupt enable. */
        uint32_t OTGSESSVALID_RISE_INT_EN :1;    /* Otgsessvalid rise detected interrupt enable. */
        uint32_t OTGSESSVALID_FALL_INT_EN :1;    /* Otgsessvalid fall detected interrupt enable. */
        uint32_t VBUSVALID_RISE_INT_EN :1;       /* Vbusvalid fall detected interrupt enable. */
        uint32_t VBUSVALID_FALL_INT_EN :1;       /* Vbusvalid fall detected interrupt enable. */
        uint32_t SENSE_RISE_INT_EN :1;           /* ADP sense comparator rise detected interrupt enable */
        uint32_t PROBE_RISE_INT_EN :1;           /* ADP probe comparator rise detected interrupt enable */
        uint32_t ADP_PROBE_COMPLETED_INT_EN :1;  /* ADP probe completed interrupt enable */
        uint32_t TA_AIDL_BDIS_TMOUT_INT_EN :1;   /* No response from B-Device for HNP interrupt enable. */
        uint32_t TA_BIDL_ADIS_TMOUT_INT_EN :1;   /* No activity from B-Device timeout interrupt enable. */
        uint32_t SRP_DET_INT_EN :1;              /* SRP pulse detected interrupt enable. NOTE: SRP detection can be enabled only if core is enabled to work as a A-device (OTGSTS.OTG_MODE=0) */
        uint32_t SRP_NOT_COMP_DEV_REMOVED_INT_EN :1; /* Non cmpliant device disconnect interrupt enable */
        uint32_t OVERCURRENT_INT_EN :1;          /* Overcurrent condition detected interrupt enable. */
        uint32_t SRP_FAIL_INT_EN :1;             /* No response from SRP from A-Device interrupt enable. */
        uint32_t SRP_CMPL_INT_EN :1;             /* SRP completed interrupt enable. */
        uint32_t TB_ASE0_BRST_TMOUT_INT_EN :1;   /* No response from A-Device to HNP interrupt enable. */
        uint32_t TB_AIDL_BDIS_MIN_TMOUT_INT_EN :1; /* The bus has been in Idle state for the required time during HNP interrupt enable. */
        uint32_t TIMER_TMOUT_INT_EN :1;          /* Timer timeout interrupt enable. */
        uint32_t H_POLL_ENTRY_INT_EN :1;         /* Host Polling state entry interrupt enable. */
        uint32_t H_WRST_GEN_CMPL_INT_EN :1;      /* Host Warm Reset generation completed interrupt enable. */
        uint32_t RID_FLOAT_FALL_INT_EN :1;       /* RID floating comparator detect interrupt enable */
        uint32_t RID_FLOAT_RISE_INT_EN :1;       /* RID floating comparator rise detect interrupt enable */
        uint32_t RID_GND_RISE_INT_EN :1;         /* RID GND comparator rise detect interrupt enable */
        uint32_t RID_C_RISE_INT_EN :1;           /* RID C comparator rise detect interrupt enable */
        uint32_t RID_B_RISE_INT_EN :1;           /* RID B comparator rise detect interrupt enable */
        uint32_t RID_A_RISE_INT_EN :1;           /* RID A comparator rise detect interrupt enable */
        uint32_t DM_VDAT_REF_RISE_INT_EN :1;     /* DM VDAT comparator rise detect interrupt enable */
        uint32_t DP_VDAT_REF_RISE_INT_EN :1;     /* DP VDAT comparator rise detect interrupt enable */
        uint32_t DCD_COMP_RISE_INT_EN :1;        /* DCD comparator rise detect interrupt enable */
        uint32_t DCD_COMP_FALL_INT_EN :1;        /* DCD comparator fall detect interrupt enable */
        uint32_t DM_VLGC_COMP_RISE_INT_EN :1;    /* DM VLGC comparator rise detect interrupt enable */
    } B;
} IMX_USB3_USBSS_OTGIEN_t;

/* Register OTGIEN - OTG Interrupt Enable */
#define IMX_USB3_USBSS_OTGIEN_OFFSET 0x10
/* Field ID_CHANGE_INT_EN - ID change interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_ID_CHANGE_INT_EN_SHIFT 0
#define IMX_USB3_USBSS_OTGIEN_ID_CHANGE_INT_EN_MASK 0x1
#define IMX_USB3_USBSS_OTGIEN_ID_CHANGE_INT_EN(v) (((v) << 0) & 0x1)
/* Field VBUS_ON_FAILED_INT_EN - Enabling Vbus by A-Device has failed interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_VBUS_ON_FAILED_INT_EN_SHIFT 1
#define IMX_USB3_USBSS_OTGIEN_VBUS_ON_FAILED_INT_EN_MASK 0x2
#define IMX_USB3_USBSS_OTGIEN_VBUS_ON_FAILED_INT_EN(v) (((v) << 0x1) & 0x2)
/* Field OTGSESSVALID_RISE_INT_EN - Otgsessvalid rise detected interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_OTGSESSVALID_RISE_INT_EN_SHIFT 2
#define IMX_USB3_USBSS_OTGIEN_OTGSESSVALID_RISE_INT_EN_MASK 0x4
#define IMX_USB3_USBSS_OTGIEN_OTGSESSVALID_RISE_INT_EN(v) (((v) << 0x2) & 0x4)
/* Field OTGSESSVALID_FALL_INT_EN - Otgsessvalid fall detected interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_OTGSESSVALID_FALL_INT_EN_SHIFT 3
#define IMX_USB3_USBSS_OTGIEN_OTGSESSVALID_FALL_INT_EN_MASK 0x8
#define IMX_USB3_USBSS_OTGIEN_OTGSESSVALID_FALL_INT_EN(v) (((v) << 0x3) & 0x8)
/* Field VBUSVALID_RISE_INT_EN - Vbusvalid fall detected interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_VBUSVALID_RISE_INT_EN_SHIFT 4
#define IMX_USB3_USBSS_OTGIEN_VBUSVALID_RISE_INT_EN_MASK 0x10
#define IMX_USB3_USBSS_OTGIEN_VBUSVALID_RISE_INT_EN(v) (((v) << 0x4) & 0x10)
/* Field VBUSVALID_FALL_INT_EN - Vbusvalid fall detected interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_VBUSVALID_FALL_INT_EN_SHIFT 5
#define IMX_USB3_USBSS_OTGIEN_VBUSVALID_FALL_INT_EN_MASK 0x20
#define IMX_USB3_USBSS_OTGIEN_VBUSVALID_FALL_INT_EN(v) (((v) << 0x5) & 0x20)
/* Field SENSE_RISE_INT_EN - ADP sense comparator rise detected interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_SENSE_RISE_INT_EN_SHIFT 6
#define IMX_USB3_USBSS_OTGIEN_SENSE_RISE_INT_EN_MASK 0x40
#define IMX_USB3_USBSS_OTGIEN_SENSE_RISE_INT_EN(v) (((v) << 0x6) & 0x40)
/* Field PROBE_RISE_INT_EN - ADP probe comparator rise detected interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_PROBE_RISE_INT_EN_SHIFT 7
#define IMX_USB3_USBSS_OTGIEN_PROBE_RISE_INT_EN_MASK 0x80
#define IMX_USB3_USBSS_OTGIEN_PROBE_RISE_INT_EN(v) (((v) << 0x7) & 0x80)
/* Field ADP_PROBE_COMPLETED_INT_EN - ADP probe completed interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_ADP_PROBE_COMPLETED_INT_EN_SHIFT 8
#define IMX_USB3_USBSS_OTGIEN_ADP_PROBE_COMPLETED_INT_EN_MASK 0x100
#define IMX_USB3_USBSS_OTGIEN_ADP_PROBE_COMPLETED_INT_EN(v) (((v) << 0x8) & 0x100)
/* Field TA_AIDL_BDIS_TMOUT_INT_EN - No response from B-Device for HNP interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_TA_AIDL_BDIS_TMOUT_INT_EN_SHIFT 9
#define IMX_USB3_USBSS_OTGIEN_TA_AIDL_BDIS_TMOUT_INT_EN_MASK 0x200
#define IMX_USB3_USBSS_OTGIEN_TA_AIDL_BDIS_TMOUT_INT_EN(v) (((v) << 0x9) & 0x200)
/* Field TA_BIDL_ADIS_TMOUT_INT_EN - No activity from B-Device timeout interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_TA_BIDL_ADIS_TMOUT_INT_EN_SHIFT 10
#define IMX_USB3_USBSS_OTGIEN_TA_BIDL_ADIS_TMOUT_INT_EN_MASK 0x400
#define IMX_USB3_USBSS_OTGIEN_TA_BIDL_ADIS_TMOUT_INT_EN(v) (((v) << 0xA) & 0x400)
/* Field SRP_DET_INT_EN - SRP pulse detected interrupt enable. NOTE: SRP detection can be enabled only if core is enabled to work as a A-device (OTGSTS.OTG_MODE=0) */
#define IMX_USB3_USBSS_OTGIEN_SRP_DET_INT_EN_SHIFT 11
#define IMX_USB3_USBSS_OTGIEN_SRP_DET_INT_EN_MASK 0x800
#define IMX_USB3_USBSS_OTGIEN_SRP_DET_INT_EN(v) (((v) << 0xB) & 0x800)
/* Field SRP_NOT_COMP_DEV_REMOVED_INT_EN - Non cmpliant device disconnect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_SRP_NOT_COMP_DEV_REMOVED_INT_EN_SHIFT 12
#define IMX_USB3_USBSS_OTGIEN_SRP_NOT_COMP_DEV_REMOVED_INT_EN_MASK 0x1000
#define IMX_USB3_USBSS_OTGIEN_SRP_NOT_COMP_DEV_REMOVED_INT_EN(v) (((v) << 0xC) & 0x1000)
/* Field OVERCURRENT_INT_EN - Overcurrent condition detected interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_OVERCURRENT_INT_EN_SHIFT 13
#define IMX_USB3_USBSS_OTGIEN_OVERCURRENT_INT_EN_MASK 0x2000
#define IMX_USB3_USBSS_OTGIEN_OVERCURRENT_INT_EN(v) (((v) << 0xD) & 0x2000)
/* Field SRP_FAIL_INT_EN - No response from SRP from A-Device interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_SRP_FAIL_INT_EN_SHIFT 14
#define IMX_USB3_USBSS_OTGIEN_SRP_FAIL_INT_EN_MASK 0x4000
#define IMX_USB3_USBSS_OTGIEN_SRP_FAIL_INT_EN(v) (((v) << 0xE) & 0x4000)
/* Field SRP_CMPL_INT_EN - SRP completed interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_SRP_CMPL_INT_EN_SHIFT 15
#define IMX_USB3_USBSS_OTGIEN_SRP_CMPL_INT_EN_MASK 0x8000
#define IMX_USB3_USBSS_OTGIEN_SRP_CMPL_INT_EN(v) (((v) << 0xF) & 0x8000)
/* Field TB_ASE0_BRST_TMOUT_INT_EN - No response from A-Device to HNP interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_TB_ASE0_BRST_TMOUT_INT_EN_SHIFT 16
#define IMX_USB3_USBSS_OTGIEN_TB_ASE0_BRST_TMOUT_INT_EN_MASK 0x10000
#define IMX_USB3_USBSS_OTGIEN_TB_ASE0_BRST_TMOUT_INT_EN(v) (((v) << 0x10) & 0x10000)
/* Field TB_AIDL_BDIS_MIN_TMOUT_INT_EN - The bus has been in Idle state for the required time during HNP interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_TB_AIDL_BDIS_MIN_TMOUT_INT_EN_SHIFT 17
#define IMX_USB3_USBSS_OTGIEN_TB_AIDL_BDIS_MIN_TMOUT_INT_EN_MASK 0x20000
#define IMX_USB3_USBSS_OTGIEN_TB_AIDL_BDIS_MIN_TMOUT_INT_EN(v) (((v) << 0x11) & 0x20000)
/* Field TIMER_TMOUT_INT_EN - Timer timeout interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_TIMER_TMOUT_INT_EN_SHIFT 18
#define IMX_USB3_USBSS_OTGIEN_TIMER_TMOUT_INT_EN_MASK 0x40000
#define IMX_USB3_USBSS_OTGIEN_TIMER_TMOUT_INT_EN(v) (((v) << 0x12) & 0x40000)
/* Field H_POLL_ENTRY_INT_EN - Host Polling state entry interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_H_POLL_ENTRY_INT_EN_SHIFT 19
#define IMX_USB3_USBSS_OTGIEN_H_POLL_ENTRY_INT_EN_MASK 0x80000
#define IMX_USB3_USBSS_OTGIEN_H_POLL_ENTRY_INT_EN(v) (((v) << 0x13) & 0x80000)
/* Field H_WRST_GEN_CMPL_INT_EN - Host Warm Reset generation completed interrupt enable. */
#define IMX_USB3_USBSS_OTGIEN_H_WRST_GEN_CMPL_INT_EN_SHIFT 20
#define IMX_USB3_USBSS_OTGIEN_H_WRST_GEN_CMPL_INT_EN_MASK 0x100000
#define IMX_USB3_USBSS_OTGIEN_H_WRST_GEN_CMPL_INT_EN(v) (((v) << 0x14) & 0x100000)
/* Field RID_FLOAT_FALL_INT_EN - RID floating comparator detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_RID_FLOAT_FALL_INT_EN_SHIFT 21
#define IMX_USB3_USBSS_OTGIEN_RID_FLOAT_FALL_INT_EN_MASK 0x200000
#define IMX_USB3_USBSS_OTGIEN_RID_FLOAT_FALL_INT_EN(v) (((v) << 0x15) & 0x200000)
/* Field RID_FLOAT_RISE_INT_EN - RID floating comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_RID_FLOAT_RISE_INT_EN_SHIFT 22
#define IMX_USB3_USBSS_OTGIEN_RID_FLOAT_RISE_INT_EN_MASK 0x400000
#define IMX_USB3_USBSS_OTGIEN_RID_FLOAT_RISE_INT_EN(v) (((v) << 0x16) & 0x400000)
/* Field RID_GND_RISE_INT_EN - RID GND comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_RID_GND_RISE_INT_EN_SHIFT 23
#define IMX_USB3_USBSS_OTGIEN_RID_GND_RISE_INT_EN_MASK 0x800000
#define IMX_USB3_USBSS_OTGIEN_RID_GND_RISE_INT_EN(v) (((v) << 0x17) & 0x800000)
/* Field RID_C_RISE_INT_EN - RID C comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_RID_C_RISE_INT_EN_SHIFT 24
#define IMX_USB3_USBSS_OTGIEN_RID_C_RISE_INT_EN_MASK 0x1000000
#define IMX_USB3_USBSS_OTGIEN_RID_C_RISE_INT_EN(v) (((v) << 0x18) & 0x1000000)
/* Field RID_B_RISE_INT_EN - RID B comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_RID_B_RISE_INT_EN_SHIFT 25
#define IMX_USB3_USBSS_OTGIEN_RID_B_RISE_INT_EN_MASK 0x2000000
#define IMX_USB3_USBSS_OTGIEN_RID_B_RISE_INT_EN(v) (((v) << 0x19) & 0x2000000)
/* Field RID_A_RISE_INT_EN - RID A comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_RID_A_RISE_INT_EN_SHIFT 26
#define IMX_USB3_USBSS_OTGIEN_RID_A_RISE_INT_EN_MASK 0x4000000
#define IMX_USB3_USBSS_OTGIEN_RID_A_RISE_INT_EN(v) (((v) << 0x1A) & 0x4000000)
/* Field DM_VDAT_REF_RISE_INT_EN - DM VDAT comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_DM_VDAT_REF_RISE_INT_EN_SHIFT 27
#define IMX_USB3_USBSS_OTGIEN_DM_VDAT_REF_RISE_INT_EN_MASK 0x8000000
#define IMX_USB3_USBSS_OTGIEN_DM_VDAT_REF_RISE_INT_EN(v) (((v) << 0x1B) & 0x8000000)
/* Field DP_VDAT_REF_RISE_INT_EN - DP VDAT comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_DP_VDAT_REF_RISE_INT_EN_SHIFT 28
#define IMX_USB3_USBSS_OTGIEN_DP_VDAT_REF_RISE_INT_EN_MASK 0x10000000
#define IMX_USB3_USBSS_OTGIEN_DP_VDAT_REF_RISE_INT_EN(v) (((v) << 0x1C) & 0x10000000)
/* Field DCD_COMP_RISE_INT_EN - DCD comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_DCD_COMP_RISE_INT_EN_SHIFT 29
#define IMX_USB3_USBSS_OTGIEN_DCD_COMP_RISE_INT_EN_MASK 0x20000000
#define IMX_USB3_USBSS_OTGIEN_DCD_COMP_RISE_INT_EN(v) (((v) << 0x1D) & 0x20000000)
/* Field DCD_COMP_FALL_INT_EN - DCD comparator fall detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_DCD_COMP_FALL_INT_EN_SHIFT 30
#define IMX_USB3_USBSS_OTGIEN_DCD_COMP_FALL_INT_EN_MASK 0x40000000
#define IMX_USB3_USBSS_OTGIEN_DCD_COMP_FALL_INT_EN(v) (((v) << 0x1E) & 0x40000000)
/* Field DM_VLGC_COMP_RISE_INT_EN - DM VLGC comparator rise detect interrupt enable */
#define IMX_USB3_USBSS_OTGIEN_DM_VLGC_COMP_RISE_INT_EN_SHIFT 31
#define IMX_USB3_USBSS_OTGIEN_DM_VLGC_COMP_RISE_INT_EN_MASK 0x80000000
#define IMX_USB3_USBSS_OTGIEN_DM_VLGC_COMP_RISE_INT_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_OTGIVECT - OTG Interrupt Vector */
typedef union IMX_USB3_USBSS_OTGIVECT_union_t {
    uint32_t R;
    struct {
        uint32_t ID_CHANGE_INT :1;               /* ID change interrupt */
        uint32_t VBUS_ON_FAILED_INT :1;          /* Enabling Vbus by A-Device has failed. This bit should be cleared before enabling subsequent connection as host. */
        uint32_t OTGSESSVALID_RISE_INT :1;       /* Otgsessvalid rise detected interrupt. */
        uint32_t OTGSESSVALID_FALL_INT :1;       /* Otgsessvalid fall detected interrupt. */
        uint32_t VBUSVALID_RISE_INT :1;          /* Vbusvalid fall detected interrupt. */
        uint32_t VBUSVALID_FALL_INT :1;          /* Vbusvalid fall detected interrupt. */
        uint32_t SENSE_RISE_INT :1;              /* ADP sense comparator rise detected interrupt */
        uint32_t PROBE_RISE_INT :1;              /* ADP probe comparator rise detected interrupt */
        uint32_t ADP_PROBE_COMPLETED_INT :1;     /* ADP completed. Status is reported in OTGADPSTS register. */
        uint32_t TA_AIDL_BDIS_TMOUT_INT :1;      /* No response from B-Device for HNP interrupt. */
        uint32_t TA_BIDL_ADIS_TMOUT_INT :1;      /* No activity from B-Device timeout interrupt. */
        uint32_t SRP_DET_INT :1;                 /* SRP pulse detected interrupt. */
        uint32_t SRP_NOT_COMP_DEV_REMOVED_INT :1; /* Not cmpliant device disconnect detect interrupt. */
        uint32_t OVERCURRENT_INT :1;             /* Overcurrent condition detected interrupt. */
        uint32_t SRP_FAIL_INT :1;                /* No response from SRP from A-Device interrupt. */
        uint32_t SRP_CMPL_INT :1;                /* SRP completed interrupt. */
        uint32_t TB_ASE0_BRST_TMOUT_INT :1;      /* No response from A-Device to HNP interrupt. */
        uint32_t TB_AIDL_BDIS_MIN_TMOUT_INT :1;  /* The bus has been in Idle state for the required time during HNP interrupt. */
        uint32_t TIMER_TMOUT_INT :1;             /* Timer timeout interrupt. */
        uint32_t H_POLLTRY_INT :1;               /* Host Polling state entry interrupt. */
        uint32_t H_WRST_GEN_CMPL_INT :1;         /* Host Warm Reset generation completed interrupt. */
        uint32_t RID_FLOAT_FALL_INT :1;          /* RID floating comparator detect interrupt */
        uint32_t RID_FLOAT_RISE_INT :1;          /* RID floating comparator rise detect interrupt */
        uint32_t RID_GND_RISE_INT :1;            /* RID GND comparator rise detect interrupt */
        uint32_t RID_C_RISE_INT :1;              /* RID C comparator rise detect interrupt */
        uint32_t RID_B_RISE_INT :1;              /* RID B comparator rise detect interrupt */
        uint32_t RID_A_RISE_INT :1;              /* RID A comparator rise detect interrupt */
        uint32_t DM_VDAT_REF_RISE_INT :1;        /* DM VDAT comparator rise detect interrupt */
        uint32_t DP_VDAT_REF_RISE_INT :1;        /* DP VDAT comparator rise detect interrupt */
        uint32_t DCD_COMP_RISE_INT :1;           /* DCD comparator rise detect interrupt */
        uint32_t DCD_COMP_FALL_INT :1;           /* DCD comparator fall detect interrupt */
        uint32_t DM_VLGC_COMP_RISE_INT :1;       /* DM VLGC comparator rise detect interrupt */
    } B;
} IMX_USB3_USBSS_OTGIVECT_t;

/* Register OTGIVECT - OTG Interrupt Vector */
#define IMX_USB3_USBSS_OTGIVECT_OFFSET 0x14
/* Field ID_CHANGE_INT - ID change interrupt */
#define IMX_USB3_USBSS_OTGIVECT_ID_CHANGE_INT_SHIFT 0
#define IMX_USB3_USBSS_OTGIVECT_ID_CHANGE_INT_MASK 0x1
#define IMX_USB3_USBSS_OTGIVECT_ID_CHANGE_INT(v) (((v) << 0) & 0x1)
/* Field VBUS_ON_FAILED_INT - Enabling Vbus by A-Device has failed. This bit should be cleared before enabling subsequent connection as host. */
#define IMX_USB3_USBSS_OTGIVECT_VBUS_ON_FAILED_INT_SHIFT 1
#define IMX_USB3_USBSS_OTGIVECT_VBUS_ON_FAILED_INT_MASK 0x2
#define IMX_USB3_USBSS_OTGIVECT_VBUS_ON_FAILED_INT(v) (((v) << 0x1) & 0x2)
/* Field OTGSESSVALID_RISE_INT - Otgsessvalid rise detected interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_OTGSESSVALID_RISE_INT_SHIFT 2
#define IMX_USB3_USBSS_OTGIVECT_OTGSESSVALID_RISE_INT_MASK 0x4
#define IMX_USB3_USBSS_OTGIVECT_OTGSESSVALID_RISE_INT(v) (((v) << 0x2) & 0x4)
/* Field OTGSESSVALID_FALL_INT - Otgsessvalid fall detected interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_OTGSESSVALID_FALL_INT_SHIFT 3
#define IMX_USB3_USBSS_OTGIVECT_OTGSESSVALID_FALL_INT_MASK 0x8
#define IMX_USB3_USBSS_OTGIVECT_OTGSESSVALID_FALL_INT(v) (((v) << 0x3) & 0x8)
/* Field VBUSVALID_RISE_INT - Vbusvalid fall detected interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_VBUSVALID_RISE_INT_SHIFT 4
#define IMX_USB3_USBSS_OTGIVECT_VBUSVALID_RISE_INT_MASK 0x10
#define IMX_USB3_USBSS_OTGIVECT_VBUSVALID_RISE_INT(v) (((v) << 0x4) & 0x10)
/* Field VBUSVALID_FALL_INT - Vbusvalid fall detected interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_VBUSVALID_FALL_INT_SHIFT 5
#define IMX_USB3_USBSS_OTGIVECT_VBUSVALID_FALL_INT_MASK 0x20
#define IMX_USB3_USBSS_OTGIVECT_VBUSVALID_FALL_INT(v) (((v) << 0x5) & 0x20)
/* Field SENSE_RISE_INT - ADP sense comparator rise detected interrupt */
#define IMX_USB3_USBSS_OTGIVECT_SENSE_RISE_INT_SHIFT 6
#define IMX_USB3_USBSS_OTGIVECT_SENSE_RISE_INT_MASK 0x40
#define IMX_USB3_USBSS_OTGIVECT_SENSE_RISE_INT(v) (((v) << 0x6) & 0x40)
/* Field PROBE_RISE_INT - ADP probe comparator rise detected interrupt */
#define IMX_USB3_USBSS_OTGIVECT_PROBE_RISE_INT_SHIFT 7
#define IMX_USB3_USBSS_OTGIVECT_PROBE_RISE_INT_MASK 0x80
#define IMX_USB3_USBSS_OTGIVECT_PROBE_RISE_INT(v) (((v) << 0x7) & 0x80)
/* Field ADP_PROBE_COMPLETED_INT - ADP completed. Status is reported in OTGADPSTS register. */
#define IMX_USB3_USBSS_OTGIVECT_ADP_PROBE_COMPLETED_INT_SHIFT 8
#define IMX_USB3_USBSS_OTGIVECT_ADP_PROBE_COMPLETED_INT_MASK 0x100
#define IMX_USB3_USBSS_OTGIVECT_ADP_PROBE_COMPLETED_INT(v) (((v) << 0x8) & 0x100)
/* Field TA_AIDL_BDIS_TMOUT_INT - No response from B-Device for HNP interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_TA_AIDL_BDIS_TMOUT_INT_SHIFT 9
#define IMX_USB3_USBSS_OTGIVECT_TA_AIDL_BDIS_TMOUT_INT_MASK 0x200
#define IMX_USB3_USBSS_OTGIVECT_TA_AIDL_BDIS_TMOUT_INT(v) (((v) << 0x9) & 0x200)
/* Field TA_BIDL_ADIS_TMOUT_INT - No activity from B-Device timeout interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_TA_BIDL_ADIS_TMOUT_INT_SHIFT 10
#define IMX_USB3_USBSS_OTGIVECT_TA_BIDL_ADIS_TMOUT_INT_MASK 0x400
#define IMX_USB3_USBSS_OTGIVECT_TA_BIDL_ADIS_TMOUT_INT(v) (((v) << 0xA) & 0x400)
/* Field SRP_DET_INT - SRP pulse detected interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_SRP_DET_INT_SHIFT 11
#define IMX_USB3_USBSS_OTGIVECT_SRP_DET_INT_MASK 0x800
#define IMX_USB3_USBSS_OTGIVECT_SRP_DET_INT(v) (((v) << 0xB) & 0x800)
/* Field SRP_NOT_COMP_DEV_REMOVED_INT - Not cmpliant device disconnect detect interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_SRP_NOT_COMP_DEV_REMOVED_INT_SHIFT 12
#define IMX_USB3_USBSS_OTGIVECT_SRP_NOT_COMP_DEV_REMOVED_INT_MASK 0x1000
#define IMX_USB3_USBSS_OTGIVECT_SRP_NOT_COMP_DEV_REMOVED_INT(v) (((v) << 0xC) & 0x1000)
/* Field OVERCURRENT_INT - Overcurrent condition detected interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_OVERCURRENT_INT_SHIFT 13
#define IMX_USB3_USBSS_OTGIVECT_OVERCURRENT_INT_MASK 0x2000
#define IMX_USB3_USBSS_OTGIVECT_OVERCURRENT_INT(v) (((v) << 0xD) & 0x2000)
/* Field SRP_FAIL_INT - No response from SRP from A-Device interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_SRP_FAIL_INT_SHIFT 14
#define IMX_USB3_USBSS_OTGIVECT_SRP_FAIL_INT_MASK 0x4000
#define IMX_USB3_USBSS_OTGIVECT_SRP_FAIL_INT(v) (((v) << 0xE) & 0x4000)
/* Field SRP_CMPL_INT - SRP completed interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_SRP_CMPL_INT_SHIFT 15
#define IMX_USB3_USBSS_OTGIVECT_SRP_CMPL_INT_MASK 0x8000
#define IMX_USB3_USBSS_OTGIVECT_SRP_CMPL_INT(v) (((v) << 0xF) & 0x8000)
/* Field TB_ASE0_BRST_TMOUT_INT - No response from A-Device to HNP interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_TB_ASE0_BRST_TMOUT_INT_SHIFT 16
#define IMX_USB3_USBSS_OTGIVECT_TB_ASE0_BRST_TMOUT_INT_MASK 0x10000
#define IMX_USB3_USBSS_OTGIVECT_TB_ASE0_BRST_TMOUT_INT(v) (((v) << 0x10) & 0x10000)
/* Field TB_AIDL_BDIS_MIN_TMOUT_INT - The bus has been in Idle state for the required time during HNP interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_TB_AIDL_BDIS_MIN_TMOUT_INT_SHIFT 17
#define IMX_USB3_USBSS_OTGIVECT_TB_AIDL_BDIS_MIN_TMOUT_INT_MASK 0x20000
#define IMX_USB3_USBSS_OTGIVECT_TB_AIDL_BDIS_MIN_TMOUT_INT(v) (((v) << 0x11) & 0x20000)
/* Field TIMER_TMOUT_INT - Timer timeout interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_TIMER_TMOUT_INT_SHIFT 18
#define IMX_USB3_USBSS_OTGIVECT_TIMER_TMOUT_INT_MASK 0x40000
#define IMX_USB3_USBSS_OTGIVECT_TIMER_TMOUT_INT(v) (((v) << 0x12) & 0x40000)
/* Field H_POLLTRY_INT - Host Polling state entry interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_H_POLLTRY_INT_SHIFT 19
#define IMX_USB3_USBSS_OTGIVECT_H_POLLTRY_INT_MASK 0x80000
#define IMX_USB3_USBSS_OTGIVECT_H_POLLTRY_INT(v) (((v) << 0x13) & 0x80000)
/* Field H_WRST_GEN_CMPL_INT - Host Warm Reset generation completed interrupt. */
#define IMX_USB3_USBSS_OTGIVECT_H_WRST_GEN_CMPL_INT_SHIFT 20
#define IMX_USB3_USBSS_OTGIVECT_H_WRST_GEN_CMPL_INT_MASK 0x100000
#define IMX_USB3_USBSS_OTGIVECT_H_WRST_GEN_CMPL_INT(v) (((v) << 0x14) & 0x100000)
/* Field RID_FLOAT_FALL_INT - RID floating comparator detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_RID_FLOAT_FALL_INT_SHIFT 21
#define IMX_USB3_USBSS_OTGIVECT_RID_FLOAT_FALL_INT_MASK 0x200000
#define IMX_USB3_USBSS_OTGIVECT_RID_FLOAT_FALL_INT(v) (((v) << 0x15) & 0x200000)
/* Field RID_FLOAT_RISE_INT - RID floating comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_RID_FLOAT_RISE_INT_SHIFT 22
#define IMX_USB3_USBSS_OTGIVECT_RID_FLOAT_RISE_INT_MASK 0x400000
#define IMX_USB3_USBSS_OTGIVECT_RID_FLOAT_RISE_INT(v) (((v) << 0x16) & 0x400000)
/* Field RID_GND_RISE_INT - RID GND comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_RID_GND_RISE_INT_SHIFT 23
#define IMX_USB3_USBSS_OTGIVECT_RID_GND_RISE_INT_MASK 0x800000
#define IMX_USB3_USBSS_OTGIVECT_RID_GND_RISE_INT(v) (((v) << 0x17) & 0x800000)
/* Field RID_C_RISE_INT - RID C comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_RID_C_RISE_INT_SHIFT 24
#define IMX_USB3_USBSS_OTGIVECT_RID_C_RISE_INT_MASK 0x1000000
#define IMX_USB3_USBSS_OTGIVECT_RID_C_RISE_INT(v) (((v) << 0x18) & 0x1000000)
/* Field RID_B_RISE_INT - RID B comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_RID_B_RISE_INT_SHIFT 25
#define IMX_USB3_USBSS_OTGIVECT_RID_B_RISE_INT_MASK 0x2000000
#define IMX_USB3_USBSS_OTGIVECT_RID_B_RISE_INT(v) (((v) << 0x19) & 0x2000000)
/* Field RID_A_RISE_INT - RID A comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_RID_A_RISE_INT_SHIFT 26
#define IMX_USB3_USBSS_OTGIVECT_RID_A_RISE_INT_MASK 0x4000000
#define IMX_USB3_USBSS_OTGIVECT_RID_A_RISE_INT(v) (((v) << 0x1A) & 0x4000000)
/* Field DM_VDAT_REF_RISE_INT - DM VDAT comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_DM_VDAT_REF_RISE_INT_SHIFT 27
#define IMX_USB3_USBSS_OTGIVECT_DM_VDAT_REF_RISE_INT_MASK 0x8000000
#define IMX_USB3_USBSS_OTGIVECT_DM_VDAT_REF_RISE_INT(v) (((v) << 0x1B) & 0x8000000)
/* Field DP_VDAT_REF_RISE_INT - DP VDAT comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_DP_VDAT_REF_RISE_INT_SHIFT 28
#define IMX_USB3_USBSS_OTGIVECT_DP_VDAT_REF_RISE_INT_MASK 0x10000000
#define IMX_USB3_USBSS_OTGIVECT_DP_VDAT_REF_RISE_INT(v) (((v) << 0x1C) & 0x10000000)
/* Field DCD_COMP_RISE_INT - DCD comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_DCD_COMP_RISE_INT_SHIFT 29
#define IMX_USB3_USBSS_OTGIVECT_DCD_COMP_RISE_INT_MASK 0x20000000
#define IMX_USB3_USBSS_OTGIVECT_DCD_COMP_RISE_INT(v) (((v) << 0x1D) & 0x20000000)
/* Field DCD_COMP_FALL_INT - DCD comparator fall detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_DCD_COMP_FALL_INT_SHIFT 30
#define IMX_USB3_USBSS_OTGIVECT_DCD_COMP_FALL_INT_MASK 0x40000000
#define IMX_USB3_USBSS_OTGIVECT_DCD_COMP_FALL_INT(v) (((v) << 0x1E) & 0x40000000)
/* Field DM_VLGC_COMP_RISE_INT - DM VLGC comparator rise detect interrupt */
#define IMX_USB3_USBSS_OTGIVECT_DM_VLGC_COMP_RISE_INT_SHIFT 31
#define IMX_USB3_USBSS_OTGIVECT_DM_VLGC_COMP_RISE_INT_MASK 0x80000000
#define IMX_USB3_USBSS_OTGIVECT_DM_VLGC_COMP_RISE_INT(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_CLK_FREQ - Clock Frequency */
typedef union IMX_USB3_USBSS_CLK_FREQ_union_t {
    uint32_t R;
    struct {
        uint32_t CLK_FREQ_MHZ :16;               /* CLK_FREQ_MHZ defines how many cycles are needed to determine 1 us clock base for fast clock Example: Let's say that fast clock frequency is 12MHz. With CLK_FREQ_MHZ set to 12 time base would be 12 cycles of 12Mhz clock which gives 1 us */
        uint32_t CLK_FREQ_KHZ :16;               /* CLK_FREQ_KHZ defines how many cycles are needed to determine 1 ms clock base for stb_clk_predft. Example: Let's say that stb_clk_predft frequency is 32kHz. With CLK_FREQ_KHZ set to 32 time base would be 32 cycles of 32khz clock which gives 1 ms */
    } B;
} IMX_USB3_USBSS_CLK_FREQ_t;

/* Register CLK_FREQ - Clock Frequency */
#define IMX_USB3_USBSS_CLK_FREQ_OFFSET 0x20
/* Field CLK_FREQ_MHZ - CLK_FREQ_MHZ defines how many cycles are needed to determine 1 us clock base for fast clock Example: Let's say that fast clock frequency is 12MHz. With CLK_FREQ_MHZ set to 12 time base would be 12 cycles of 12Mhz clock which gives 1 us */
#define IMX_USB3_USBSS_CLK_FREQ_CLK_FREQ_MHZ_SHIFT 0
#define IMX_USB3_USBSS_CLK_FREQ_CLK_FREQ_MHZ_MASK 0xFFFF
#define IMX_USB3_USBSS_CLK_FREQ_CLK_FREQ_MHZ(v) (((v) << 0) & 0xFFFF)
/* Field CLK_FREQ_KHZ - CLK_FREQ_KHZ defines how many cycles are needed to determine 1 ms clock base for stb_clk_predft. Example: Let's say that stb_clk_predft frequency is 32kHz. With CLK_FREQ_KHZ set to 32 time base would be 32 cycles of 32khz clock which gives 1 ms */
#define IMX_USB3_USBSS_CLK_FREQ_CLK_FREQ_KHZ_SHIFT 16
#define IMX_USB3_USBSS_CLK_FREQ_CLK_FREQ_KHZ_MASK 0xFFFF0000
#define IMX_USB3_USBSS_CLK_FREQ_CLK_FREQ_KHZ(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_OTGTMR - OTG Timer */
typedef union IMX_USB3_USBSS_OTGTMR_union_t {
    uint32_t R;
    struct {
        uint32_t TIMEOUT_VALUE :16;              /* Timeout value for timer. Valid only if TIMER_WRITE is 1. */
        uint32_t TIMEOUT_UNITS :2;               /* Time units */
        uint32_t TIMER_WRITE :1;                 /* Timer value and units write strobe */
        uint32_t TIMER_START :1;                 /* Start timer */
        uint32_t TIMER_STOP  :1;                 /* Stop timer */
        uint32_t _unused21   :11;
    } B;
} IMX_USB3_USBSS_OTGTMR_t;

/* Register OTGTMR - OTG Timer */
#define IMX_USB3_USBSS_OTGTMR_OFFSET 0x24
/* Field TIMEOUT_VALUE - Timeout value for timer. Valid only if TIMER_WRITE is 1. */
#define IMX_USB3_USBSS_OTGTMR_TIMEOUT_VALUE_SHIFT 0
#define IMX_USB3_USBSS_OTGTMR_TIMEOUT_VALUE_MASK 0xFFFF
#define IMX_USB3_USBSS_OTGTMR_TIMEOUT_VALUE(v) (((v) << 0) & 0xFFFF)
/* Field TIMEOUT_UNITS - Time units */
#define IMX_USB3_USBSS_OTGTMR_TIMEOUT_UNITS_SHIFT 16
#define IMX_USB3_USBSS_OTGTMR_TIMEOUT_UNITS_MASK 0x30000
#define IMX_USB3_USBSS_OTGTMR_TIMEOUT_UNITS(v) (((v) << 0x10) & 0x30000)
/* Field TIMER_WRITE - Timer value and units write strobe */
#define IMX_USB3_USBSS_OTGTMR_TIMER_WRITE_SHIFT 18
#define IMX_USB3_USBSS_OTGTMR_TIMER_WRITE_MASK 0x40000
#define IMX_USB3_USBSS_OTGTMR_TIMER_WRITE(v) (((v) << 0x12) & 0x40000)
/* Field TIMER_START - Start timer */
#define IMX_USB3_USBSS_OTGTMR_TIMER_START_SHIFT 19
#define IMX_USB3_USBSS_OTGTMR_TIMER_START_MASK 0x80000
#define IMX_USB3_USBSS_OTGTMR_TIMER_START(v) (((v) << 0x13) & 0x80000)
/* Field TIMER_STOP - Stop timer */
#define IMX_USB3_USBSS_OTGTMR_TIMER_STOP_SHIFT 20
#define IMX_USB3_USBSS_OTGTMR_TIMER_STOP_MASK 0x100000
#define IMX_USB3_USBSS_OTGTMR_TIMER_STOP(v) (((v) << 0x14) & 0x100000)

/* IMX_USB3_USBSS_OTGVERSION - OTG Version */
typedef union IMX_USB3_USBSS_OTGVERSION_union_t {
    uint32_t R;
    struct {
        uint32_t OTGVERSION  :16;                /* OTG core revision */
        uint32_t _unused16   :16;
    } B;
} IMX_USB3_USBSS_OTGVERSION_t;

/* Register OTGVERSION - OTG Version */
#define IMX_USB3_USBSS_OTGVERSION_OFFSET 0x30
/* Field OTGVERSION - OTG core revision */
#define IMX_USB3_USBSS_OTGVERSION_OTGVERSION_SHIFT 0
#define IMX_USB3_USBSS_OTGVERSION_OTGVERSION_MASK 0xFFFF
#define IMX_USB3_USBSS_OTGVERSION_OTGVERSION(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_OTGCAPABILITY - OTG Capabilities register */
typedef union IMX_USB3_USBSS_OTGCAPABILITY_union_t {
    uint32_t R;
    struct {
        uint32_t SRP_SUPPORT :1;                 /* SRP support. 0 - SRP not supported 1 - SRP supported */
        uint32_t HNP_SUPPORT :1;                 /* HNP support. 0 - HNP not supported 1 - HNP supported */
        uint32_t ADP_SUPPORT :1;                 /* ADP support. 0 - ADP not supported 1 - ADP supported */
        uint32_t BC_SUPPORT  :1;                 /* BC Support (Battery Charging specification rev 1.2). 0 - BC not supported 1 - BC supported */
        uint32_t RSP_SUPPORT :1;                 /* RSP support. 0 - RSP not supported 1 - RSP supported */
        uint32_t _unused5    :3;
        uint32_t OTG2REVISION :12;               /* Specifies implemeted OTG2.0 specification revision */
        uint32_t OTG3REVISION :12;               /* Specifies implemeted OTG3.0 specification revision */
    } B;
} IMX_USB3_USBSS_OTGCAPABILITY_t;

/* Register OTGCAPABILITY - OTG Capabilities register */
#define IMX_USB3_USBSS_OTGCAPABILITY_OFFSET 0x34
/* Field SRP_SUPPORT - SRP support. 0 - SRP not supported 1 - SRP supported */
#define IMX_USB3_USBSS_OTGCAPABILITY_SRP_SUPPORT_SHIFT 0
#define IMX_USB3_USBSS_OTGCAPABILITY_SRP_SUPPORT_MASK 0x1
#define IMX_USB3_USBSS_OTGCAPABILITY_SRP_SUPPORT(v) (((v) << 0) & 0x1)
/* Field HNP_SUPPORT - HNP support. 0 - HNP not supported 1 - HNP supported */
#define IMX_USB3_USBSS_OTGCAPABILITY_HNP_SUPPORT_SHIFT 1
#define IMX_USB3_USBSS_OTGCAPABILITY_HNP_SUPPORT_MASK 0x2
#define IMX_USB3_USBSS_OTGCAPABILITY_HNP_SUPPORT(v) (((v) << 0x1) & 0x2)
/* Field ADP_SUPPORT - ADP support. 0 - ADP not supported 1 - ADP supported */
#define IMX_USB3_USBSS_OTGCAPABILITY_ADP_SUPPORT_SHIFT 2
#define IMX_USB3_USBSS_OTGCAPABILITY_ADP_SUPPORT_MASK 0x4
#define IMX_USB3_USBSS_OTGCAPABILITY_ADP_SUPPORT(v) (((v) << 0x2) & 0x4)
/* Field BC_SUPPORT - BC Support (Battery Charging specification rev 1.2). 0 - BC not supported 1 - BC supported */
#define IMX_USB3_USBSS_OTGCAPABILITY_BC_SUPPORT_SHIFT 3
#define IMX_USB3_USBSS_OTGCAPABILITY_BC_SUPPORT_MASK 0x8
#define IMX_USB3_USBSS_OTGCAPABILITY_BC_SUPPORT(v) (((v) << 0x3) & 0x8)
/* Field RSP_SUPPORT - RSP support. 0 - RSP not supported 1 - RSP supported */
#define IMX_USB3_USBSS_OTGCAPABILITY_RSP_SUPPORT_SHIFT 4
#define IMX_USB3_USBSS_OTGCAPABILITY_RSP_SUPPORT_MASK 0x10
#define IMX_USB3_USBSS_OTGCAPABILITY_RSP_SUPPORT(v) (((v) << 0x4) & 0x10)
/* Field OTG2REVISION - Specifies implemeted OTG2.0 specification revision */
#define IMX_USB3_USBSS_OTGCAPABILITY_OTG2REVISION_SHIFT 8
#define IMX_USB3_USBSS_OTGCAPABILITY_OTG2REVISION_MASK 0xFFF00
#define IMX_USB3_USBSS_OTGCAPABILITY_OTG2REVISION(v) (((v) << 0x8) & 0xFFF00)
/* Field OTG3REVISION - Specifies implemeted OTG3.0 specification revision */
#define IMX_USB3_USBSS_OTGCAPABILITY_OTG3REVISION_SHIFT 20
#define IMX_USB3_USBSS_OTGCAPABILITY_OTG3REVISION_MASK 0xFFF00000
#define IMX_USB3_USBSS_OTGCAPABILITY_OTG3REVISION(v) (((v) << 0x14) & 0xFFF00000)

/* IMX_USB3_USBSS_OTGSIMULATE - OTG Simulate */
typedef union IMX_USB3_USBSS_OTGSIMULATE_union_t {
    uint32_t R;
    struct {
        uint32_t OTG_CFG_FAST_SIMS :1;           /* Debug Feature. This bit is for simulation modes only. It enables reductions to OTG timings. '0': Normal timings '1': Enable fast simulation timing modes This bit should be written '0' in normal operation */
        uint32_t _unused1    :31;
    } B;
} IMX_USB3_USBSS_OTGSIMULATE_t;

/* Register OTGSIMULATE - OTG Simulate */
#define IMX_USB3_USBSS_OTGSIMULATE_OFFSET 0x40
/* Field OTG_CFG_FAST_SIMS - Debug Feature. This bit is for simulation modes only. It enables reductions to OTG timings. '0': Normal timings '1': Enable fast simulation timing modes This bit should be written '0' in normal operation */
#define IMX_USB3_USBSS_OTGSIMULATE_OTG_CFG_FAST_SIMS_SHIFT 0
#define IMX_USB3_USBSS_OTGSIMULATE_OTG_CFG_FAST_SIMS_MASK 0x1
#define IMX_USB3_USBSS_OTGSIMULATE_OTG_CFG_FAST_SIMS(v) (((v) << 0) & 0x1)

/* IMX_USB3_USBSS_OTGANASTS - OTG Attach Detection Protocol (ADP) BC Status */
typedef union IMX_USB3_USBSS_OTGANASTS_union_t {
    uint32_t R;
    struct {
        uint32_t DP_VDAT_REF_COMP_STS :1;        /* 1: DP > VDAT_REF Detected 0: DP < VDAT_REF Detected Note: This status shall be re-used from the single ended receiver output of D+ whenever dp_vdat_ref_comp_en is '1'. */
        uint32_t DM_VDAT_REF_COMP_STS :1;        /* 1: DM > VDAT_REF Detected 0: DM < VDAT_REF Detected Note: This status shall be re-used from the single ended receiver output of D- whenever dm_vdat_ref_comp_en is '1'. */
        uint32_t DM_VLGC_COMP_STS :1;            /* 1: DM > VLGC Detected 0: DM < VLGC Detected Note: This status shall be re-used from the single ended receiver output of D- whenever dm_vlgc_comp_en is '1'. */
        uint32_t DCD_COMP_STS :1;                /* Data Contact Detect (DCD) Comparator Status 1: DP line is asserted 0: DP line is not asserted */
        uint32_t OTGSESSVALID :1;                /* B-Peripheral is Valid: Indicates if the session for a B-Peripheral is valid (0.8V < VTH < 4.0V). The signal bvalid from OTG 1.3 is now renamed as otgsessvalid. 0: VBUS < 0.8V 1: VBUS > 4.0V */
        uint32_t ADP_PROBE_ANA :1;               /* Output of ADP Probe Comparator. 0: VBUS < 0.6V 1: VBUS > 0.75V */
        uint32_t ADP_SENSE_ANA :1;               /* Output of ADP Sense Comparator. 0: VBUS < 0.2V 1: VBUS > 0.55V */
        uint32_t SESSEND     :1;                 /* VBUS Valid: Indicates if the voltage on VBUS is at a valid level for operation (4.4V < VTH < 4.75V). 0: VBUS < 4.4V 1: VBUS > 4.75V */
        uint32_t RID_FLOAT_COMP_STS :1;          /* RID float comparator status 1: RID_FLOAT Detected on ID Pin 0: RID_FLOAT not Detected on ID Pin */
        uint32_t RID_GND_COMP_STS :1;            /* RID GND comparator status 1: RID_GND Detected on ID Pin 0: RID_GND not Detected on ID Pin */
        uint32_t RID_C_COMP_STS :1;              /* RID C comparator status 1: RID_C Detected on ID Pin 0: RID_C not Detected on ID Pin */
        uint32_t RID_B_COMP_STS :1;              /* RID B comparator status 1: RID_B Detected on ID Pin 0: RID_B not Detected on ID Pin */
        uint32_t RID_A_COMP_STS :1;              /* RID A comparator status 1: RID_A Detected on ID Pin 0: RID_A not Detected on ID Pin */
        uint32_t IDDIG       :1;                 /* ID Pin Status: Indicates whether the connected USB plug is Micro-A or Micro-B. This is only valid when idpullup is set to '1'. It must be valid within 50ms after idpullup is set to '1'. 0: Connected plug is a Micro-A 1: Connected plug is a Micro-B */
        uint32_t LINESTATE   :2;                 /* Line State: These signals reflect the current state of the single ended receivers. They are combinatorial until a 'usable' sieclock is available, then they are synchronized to sieclock. They reflect the current state of the DP (linestate [0]) and DM (linestate [1]) signals. 00: SE0 (Single Ended Zero) 01: 'J' State 10: 'K' State 11: SE1 (Single Ended One) */
        uint32_t RID_FLOAT   :1;                 /* RID float status reg */
        uint32_t RID_GND     :1;                 /* RID GND status reg */
        uint32_t RID_C       :1;                 /* RID C status reg */
        uint32_t RID_B       :1;                 /* RID B status reg */
        uint32_t RID_A       :1;                 /* RID A status reg */
        uint32_t _unused21   :3;
        uint32_t ADP_CHRG_TMOUT_DET :1;          /* ADP charge timeout detected */
        uint32_t _unused25   :7;
    } B;
} IMX_USB3_USBSS_OTGANASTS_t;

/* Register OTGANASTS - OTG Attach Detection Protocol (ADP) BC Status */
#define IMX_USB3_USBSS_OTGANASTS_OFFSET 0x50
/* Field DP_VDAT_REF_COMP_STS - 1: DP > VDAT_REF Detected 0: DP < VDAT_REF Detected Note: This status shall be re-used from the single ended receiver output of D+ whenever dp_vdat_ref_comp_en is '1'. */
#define IMX_USB3_USBSS_OTGANASTS_DP_VDAT_REF_COMP_STS_SHIFT 0
#define IMX_USB3_USBSS_OTGANASTS_DP_VDAT_REF_COMP_STS_MASK 0x1
#define IMX_USB3_USBSS_OTGANASTS_DP_VDAT_REF_COMP_STS(v) (((v) << 0) & 0x1)
/* Field DM_VDAT_REF_COMP_STS - 1: DM > VDAT_REF Detected 0: DM < VDAT_REF Detected Note: This status shall be re-used from the single ended receiver output of D- whenever dm_vdat_ref_comp_en is '1'. */
#define IMX_USB3_USBSS_OTGANASTS_DM_VDAT_REF_COMP_STS_SHIFT 1
#define IMX_USB3_USBSS_OTGANASTS_DM_VDAT_REF_COMP_STS_MASK 0x2
#define IMX_USB3_USBSS_OTGANASTS_DM_VDAT_REF_COMP_STS(v) (((v) << 0x1) & 0x2)
/* Field DM_VLGC_COMP_STS - 1: DM > VLGC Detected 0: DM < VLGC Detected Note: This status shall be re-used from the single ended receiver output of D- whenever dm_vlgc_comp_en is '1'. */
#define IMX_USB3_USBSS_OTGANASTS_DM_VLGC_COMP_STS_SHIFT 2
#define IMX_USB3_USBSS_OTGANASTS_DM_VLGC_COMP_STS_MASK 0x4
#define IMX_USB3_USBSS_OTGANASTS_DM_VLGC_COMP_STS(v) (((v) << 0x2) & 0x4)
/* Field DCD_COMP_STS - Data Contact Detect (DCD) Comparator Status 1: DP line is asserted 0: DP line is not asserted */
#define IMX_USB3_USBSS_OTGANASTS_DCD_COMP_STS_SHIFT 3
#define IMX_USB3_USBSS_OTGANASTS_DCD_COMP_STS_MASK 0x8
#define IMX_USB3_USBSS_OTGANASTS_DCD_COMP_STS(v) (((v) << 0x3) & 0x8)
/* Field OTGSESSVALID - B-Peripheral is Valid: Indicates if the session for a B-Peripheral is valid (0.8V < VTH < 4.0V). The signal bvalid from OTG 1.3 is now renamed as otgsessvalid. 0: VBUS < 0.8V 1: VBUS > 4.0V */
#define IMX_USB3_USBSS_OTGANASTS_OTGSESSVALID_SHIFT 4
#define IMX_USB3_USBSS_OTGANASTS_OTGSESSVALID_MASK 0x10
#define IMX_USB3_USBSS_OTGANASTS_OTGSESSVALID(v) (((v) << 0x4) & 0x10)
/* Field ADP_PROBE_ANA - Output of ADP Probe Comparator. 0: VBUS < 0.6V 1: VBUS > 0.75V */
#define IMX_USB3_USBSS_OTGANASTS_ADP_PROBE_ANA_SHIFT 5
#define IMX_USB3_USBSS_OTGANASTS_ADP_PROBE_ANA_MASK 0x20
#define IMX_USB3_USBSS_OTGANASTS_ADP_PROBE_ANA(v) (((v) << 0x5) & 0x20)
/* Field ADP_SENSE_ANA - Output of ADP Sense Comparator. 0: VBUS < 0.2V 1: VBUS > 0.55V */
#define IMX_USB3_USBSS_OTGANASTS_ADP_SENSE_ANA_SHIFT 6
#define IMX_USB3_USBSS_OTGANASTS_ADP_SENSE_ANA_MASK 0x40
#define IMX_USB3_USBSS_OTGANASTS_ADP_SENSE_ANA(v) (((v) << 0x6) & 0x40)
/* Field SESSEND - VBUS Valid: Indicates if the voltage on VBUS is at a valid level for operation (4.4V < VTH < 4.75V). 0: VBUS < 4.4V 1: VBUS > 4.75V */
#define IMX_USB3_USBSS_OTGANASTS_SESSEND_SHIFT 7
#define IMX_USB3_USBSS_OTGANASTS_SESSEND_MASK 0x80
#define IMX_USB3_USBSS_OTGANASTS_SESSEND(v) (((v) << 0x7) & 0x80)
/* Field RID_FLOAT_COMP_STS - RID float comparator status 1: RID_FLOAT Detected on ID Pin 0: RID_FLOAT not Detected on ID Pin */
#define IMX_USB3_USBSS_OTGANASTS_RID_FLOAT_COMP_STS_SHIFT 8
#define IMX_USB3_USBSS_OTGANASTS_RID_FLOAT_COMP_STS_MASK 0x100
#define IMX_USB3_USBSS_OTGANASTS_RID_FLOAT_COMP_STS(v) (((v) << 0x8) & 0x100)
/* Field RID_GND_COMP_STS - RID GND comparator status 1: RID_GND Detected on ID Pin 0: RID_GND not Detected on ID Pin */
#define IMX_USB3_USBSS_OTGANASTS_RID_GND_COMP_STS_SHIFT 9
#define IMX_USB3_USBSS_OTGANASTS_RID_GND_COMP_STS_MASK 0x200
#define IMX_USB3_USBSS_OTGANASTS_RID_GND_COMP_STS(v) (((v) << 0x9) & 0x200)
/* Field RID_C_COMP_STS - RID C comparator status 1: RID_C Detected on ID Pin 0: RID_C not Detected on ID Pin */
#define IMX_USB3_USBSS_OTGANASTS_RID_C_COMP_STS_SHIFT 10
#define IMX_USB3_USBSS_OTGANASTS_RID_C_COMP_STS_MASK 0x400
#define IMX_USB3_USBSS_OTGANASTS_RID_C_COMP_STS(v) (((v) << 0xA) & 0x400)
/* Field RID_B_COMP_STS - RID B comparator status 1: RID_B Detected on ID Pin 0: RID_B not Detected on ID Pin */
#define IMX_USB3_USBSS_OTGANASTS_RID_B_COMP_STS_SHIFT 11
#define IMX_USB3_USBSS_OTGANASTS_RID_B_COMP_STS_MASK 0x800
#define IMX_USB3_USBSS_OTGANASTS_RID_B_COMP_STS(v) (((v) << 0xB) & 0x800)
/* Field RID_A_COMP_STS - RID A comparator status 1: RID_A Detected on ID Pin 0: RID_A not Detected on ID Pin */
#define IMX_USB3_USBSS_OTGANASTS_RID_A_COMP_STS_SHIFT 12
#define IMX_USB3_USBSS_OTGANASTS_RID_A_COMP_STS_MASK 0x1000
#define IMX_USB3_USBSS_OTGANASTS_RID_A_COMP_STS(v) (((v) << 0xC) & 0x1000)
/* Field IDDIG - ID Pin Status: Indicates whether the connected USB plug is Micro-A or Micro-B. This is only valid when idpullup is set to '1'. It must be valid within 50ms after idpullup is set to '1'. 0: Connected plug is a Micro-A 1: Connected plug is a Micro-B */
#define IMX_USB3_USBSS_OTGANASTS_IDDIG_SHIFT 13
#define IMX_USB3_USBSS_OTGANASTS_IDDIG_MASK 0x2000
#define IMX_USB3_USBSS_OTGANASTS_IDDIG(v) (((v) << 0xD) & 0x2000)
/* Field LINESTATE - Line State: These signals reflect the current state of the single ended receivers. They are combinatorial until a 'usable' sieclock is available, then they are synchronized to sieclock. They reflect the current state of the DP (linestate [0]) and DM (linestate [1]) signals. 00: SE0 (Single Ended Zero) 01: 'J' State 10: 'K' State 11: SE1 (Single Ended One) */
#define IMX_USB3_USBSS_OTGANASTS_LINESTATE_SHIFT 14
#define IMX_USB3_USBSS_OTGANASTS_LINESTATE_MASK 0xC000
#define IMX_USB3_USBSS_OTGANASTS_LINESTATE(v) (((v) << 0xE) & 0xC000)
/* Field RID_FLOAT - RID float status reg */
#define IMX_USB3_USBSS_OTGANASTS_RID_FLOAT_SHIFT 16
#define IMX_USB3_USBSS_OTGANASTS_RID_FLOAT_MASK 0x10000
#define IMX_USB3_USBSS_OTGANASTS_RID_FLOAT(v) (((v) << 0x10) & 0x10000)
/* Field RID_GND - RID GND status reg */
#define IMX_USB3_USBSS_OTGANASTS_RID_GND_SHIFT 17
#define IMX_USB3_USBSS_OTGANASTS_RID_GND_MASK 0x20000
#define IMX_USB3_USBSS_OTGANASTS_RID_GND(v) (((v) << 0x11) & 0x20000)
/* Field RID_C - RID C status reg */
#define IMX_USB3_USBSS_OTGANASTS_RID_C_SHIFT 18
#define IMX_USB3_USBSS_OTGANASTS_RID_C_MASK 0x40000
#define IMX_USB3_USBSS_OTGANASTS_RID_C(v) (((v) << 0x12) & 0x40000)
/* Field RID_B - RID B status reg */
#define IMX_USB3_USBSS_OTGANASTS_RID_B_SHIFT 19
#define IMX_USB3_USBSS_OTGANASTS_RID_B_MASK 0x80000
#define IMX_USB3_USBSS_OTGANASTS_RID_B(v) (((v) << 0x13) & 0x80000)
/* Field RID_A - RID A status reg */
#define IMX_USB3_USBSS_OTGANASTS_RID_A_SHIFT 20
#define IMX_USB3_USBSS_OTGANASTS_RID_A_MASK 0x100000
#define IMX_USB3_USBSS_OTGANASTS_RID_A(v) (((v) << 0x14) & 0x100000)
/* Field ADP_CHRG_TMOUT_DET - ADP charge timeout detected */
#define IMX_USB3_USBSS_OTGANASTS_ADP_CHRG_TMOUT_DET_SHIFT 24
#define IMX_USB3_USBSS_OTGANASTS_ADP_CHRG_TMOUT_DET_MASK 0x1000000
#define IMX_USB3_USBSS_OTGANASTS_ADP_CHRG_TMOUT_DET(v) (((v) << 0x18) & 0x1000000)

/* IMX_USB3_USBSS_ADP_RAMP_TIME - Attach Detection Protocol (ADP) Ramp Time */
typedef union IMX_USB3_USBSS_ADP_RAMP_TIME_union_t {
    uint32_t R;
    struct {
        uint32_t ADP_RAMP_TIME :32;              /* ADP ramp time measurement value. Software should read this register upon ADP_PROBE_COMPLETED_INT_EN interrupt detection */
    } B;
} IMX_USB3_USBSS_ADP_RAMP_TIME_t;

/* Register ADP_RAMP_TIME - Attach Detection Protocol (ADP) Ramp Time */
#define IMX_USB3_USBSS_ADP_RAMP_TIME_OFFSET 0x54
/* Field ADP_RAMP_TIME - ADP ramp time measurement value. Software should read this register upon ADP_PROBE_COMPLETED_INT_EN interrupt detection */
#define IMX_USB3_USBSS_ADP_RAMP_TIME_ADP_RAMP_TIME_SHIFT 0
#define IMX_USB3_USBSS_ADP_RAMP_TIME_ADP_RAMP_TIME_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ADP_RAMP_TIME_ADP_RAMP_TIME(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_OTGCTRL1 - OTG Control Register 1 */
typedef union IMX_USB3_USBSS_OTGCTRL1_union_t {
    uint32_t R;
    struct {
        uint32_t ADP_EN      :1;                 /* ADP Feature Enable. This signal is the master enable for all the ADP PHY logics. 0: ADP Logics are powered OFF 1: ADP Logics are powered ON */
        uint32_t ADP_PROBE_EN :1;                /* This signal enables the probe mode of the ADP. During this mode, probe comparators and the current sources will be ON based on the source and sink current enables. 0: ADP Probe Mode OFF 1: ADP Probe Mode ON */
        uint32_t ADP_SENSE_EN :1;                /* This signal enables the probe mode of the ADP. During this mode, sense comparators and the current sources will be ON based on the source and sink current enables. 0: ADP Probe Sense OFF 1: ADP Probe Sense ON */
        uint32_t ADP_SINK_CURRENT_EN :1;         /* When this signal is high, VBUS is discharged to ground. This signal should be asserted 5us after the assertion of adp_en. 0: ADP Sink Current Enable OFF 1: ADP Sink Current Enable ON */
        uint32_t ADP_SOURCE_CURRENT_EN :1;       /* When this signal is high, VBUS is charged to the probe threshold (0.75V). This signal should be asserted 5us after the assertion of adp_en. 0: ADP Source Current Enable OFF 1: ADP Source Current Enable ON */
        uint32_t DO_ADP_PRB  :1;                 /* ADP probing enable in automated mode */
        uint32_t DO_ADP_SNS  :1;                 /* ADP sensing enable in automated mode */
        uint32_t ADP_AUTO    :1;                 /* ADP mode. If set to 1 ADP probing is controlled by internal FSM. If set to 0 then software should control ADP sequence. */
        uint32_t BC_EN       :1;                 /* Battery Charging Circuits Master Enable. 1: BC Enabled 0: BC Disabled */
        uint32_t IDM_SINK_EN :1;                 /* 1: Current Sink on DM Enabled 0: Current Sink on DM Disabled */
        uint32_t IDP_SINK_EN :1;                 /* 1: Current Sink on DP Enabled 0: Current Sink on DP Disabled */
        uint32_t IDP_SRC_EN  :1;                 /* 1: Current Source on DP Enabled 0: Current Source on DP Disabled */
        uint32_t VDM_SRC_EN  :1;                 /* 1: Voltage Source on DM Enabled 0: Voltage Source on DM Disabled */
        uint32_t VDP_SRC_EN  :1;                 /* 1: Voltage Source on DP Enabled 0: Voltage Source on DP Disabled */
        uint32_t _unused14   :2;
        uint32_t DM_VDAT_REF_COMP_EN :1;         /* 1: DM to VDAT_REF Comparator Enabled 0: DM to VDAT_REF Comparator Disabled */
        uint32_t DM_VLGC_COMP_EN :1;             /* 1: DM to VLGC Comparator Enabled 0: DM to VLGC Comparator Disabled */
        uint32_t DP_VDAT_REF_COMP_EN :1;         /* 1: DP to VDAT_REF Comparator Enabled 0: DP to VDAT_REF Comparator Disabled */
        uint32_t RID_FLOAT_COMP_EN :1;           /* 1: RID Float Comparator Enabled 0: RID Float Comparator Disabled Note: This ID Comparator enable is used to detect whether the ID line is floating or non-floating. If it is identified to be non-floating, then rid_nonfloat_comp_en is enabled to check for RID_A or RID_B or RID_C or RID_GND. */
        uint32_t RID_NONFLOAT_COMP_EN :1;        /* 1: RID Non-Float Comparator Enabled 0: RID Non-Float Comparator Disabled Note: This ID Comparator enable is used to detect the presence of RID_A or RID_B or RID_C or RID_GND when the ID pin is non-floating. */
        uint32_t BC_DMPULLDOWN :1;               /* BC dmpulldown enable */
        uint32_t BC_DPPULLDOWN :1;               /* BC dppulldown enable */
        uint32_t BC_PULLDOWNCTRL :1;             /* BC pulldowncotrol 1: puldowns are controlled by bc_dppulldown and bc_dmpulldown 0: puldowns are controlled by OTG */
        uint32_t IDPULLUP    :1;                 /* ID Pin Sample Enable: Active High. Signal that enables the sampling of the analog ID line. 0: Sampling of ID pin is disabled, iddig is not valid 1: Sampling of ID pin is enabled */
        uint32_t DRIVE_VBUS_SEL :1;              /* VBUS drive control select. This register allows SW driver take control over drive_vbus as follows: 0: drive_vbus controlled from OTG controller 1: drive_vbus controlled from SFR */
        uint32_t DRIVE_VBUS_SFR :1;              /* SFR drive_vbus control. 0: drive_vbus = 0 1: drive_vbus = 1 This bit is valid only with OTGCTRL1.drive_vbus_sel set to '1'. This bit is auto-cleared upon over-current condition. */
        uint32_t FORCE_OPMODE01 :1;              /* with both cores disabled seting this bit to '1' will result with forcing UTMI opmode set to 2'b01 (non-driving) */
        uint32_t _unused28   :4;
    } B;
} IMX_USB3_USBSS_OTGCTRL1_t;

/* Register OTGCTRL1 - OTG Control Register 1 */
#define IMX_USB3_USBSS_OTGCTRL1_OFFSET 0x58
/* Field ADP_EN - ADP Feature Enable. This signal is the master enable for all the ADP PHY logics. 0: ADP Logics are powered OFF 1: ADP Logics are powered ON */
#define IMX_USB3_USBSS_OTGCTRL1_ADP_EN_SHIFT 0
#define IMX_USB3_USBSS_OTGCTRL1_ADP_EN_MASK 0x1
#define IMX_USB3_USBSS_OTGCTRL1_ADP_EN(v) (((v) << 0) & 0x1)
/* Field ADP_PROBE_EN - This signal enables the probe mode of the ADP. During this mode, probe comparators and the current sources will be ON based on the source and sink current enables. 0: ADP Probe Mode OFF 1: ADP Probe Mode ON */
#define IMX_USB3_USBSS_OTGCTRL1_ADP_PROBE_EN_SHIFT 1
#define IMX_USB3_USBSS_OTGCTRL1_ADP_PROBE_EN_MASK 0x2
#define IMX_USB3_USBSS_OTGCTRL1_ADP_PROBE_EN(v) (((v) << 0x1) & 0x2)
/* Field ADP_SENSE_EN - This signal enables the probe mode of the ADP. During this mode, sense comparators and the current sources will be ON based on the source and sink current enables. 0: ADP Probe Sense OFF 1: ADP Probe Sense ON */
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SENSE_EN_SHIFT 2
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SENSE_EN_MASK 0x4
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SENSE_EN(v) (((v) << 0x2) & 0x4)
/* Field ADP_SINK_CURRENT_EN - When this signal is high, VBUS is discharged to ground. This signal should be asserted 5us after the assertion of adp_en. 0: ADP Sink Current Enable OFF 1: ADP Sink Current Enable ON */
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SINK_CURRENT_EN_SHIFT 3
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SINK_CURRENT_EN_MASK 0x8
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SINK_CURRENT_EN(v) (((v) << 0x3) & 0x8)
/* Field ADP_SOURCE_CURRENT_EN - When this signal is high, VBUS is charged to the probe threshold (0.75V). This signal should be asserted 5us after the assertion of adp_en. 0: ADP Source Current Enable OFF 1: ADP Source Current Enable ON */
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SOURCE_CURRENT_EN_SHIFT 4
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SOURCE_CURRENT_EN_MASK 0x10
#define IMX_USB3_USBSS_OTGCTRL1_ADP_SOURCE_CURRENT_EN(v) (((v) << 0x4) & 0x10)
/* Field DO_ADP_PRB - ADP probing enable in automated mode */
#define IMX_USB3_USBSS_OTGCTRL1_DO_ADP_PRB_SHIFT 5
#define IMX_USB3_USBSS_OTGCTRL1_DO_ADP_PRB_MASK 0x20
#define IMX_USB3_USBSS_OTGCTRL1_DO_ADP_PRB(v) (((v) << 0x5) & 0x20)
/* Field DO_ADP_SNS - ADP sensing enable in automated mode */
#define IMX_USB3_USBSS_OTGCTRL1_DO_ADP_SNS_SHIFT 6
#define IMX_USB3_USBSS_OTGCTRL1_DO_ADP_SNS_MASK 0x40
#define IMX_USB3_USBSS_OTGCTRL1_DO_ADP_SNS(v) (((v) << 0x6) & 0x40)
/* Field ADP_AUTO - ADP mode. If set to 1 ADP probing is controlled by internal FSM. If set to 0 then software should control ADP sequence. */
#define IMX_USB3_USBSS_OTGCTRL1_ADP_AUTO_SHIFT 7
#define IMX_USB3_USBSS_OTGCTRL1_ADP_AUTO_MASK 0x80
#define IMX_USB3_USBSS_OTGCTRL1_ADP_AUTO(v) (((v) << 0x7) & 0x80)
/* Field BC_EN - Battery Charging Circuits Master Enable. 1: BC Enabled 0: BC Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_BC_EN_SHIFT 8
#define IMX_USB3_USBSS_OTGCTRL1_BC_EN_MASK 0x100
#define IMX_USB3_USBSS_OTGCTRL1_BC_EN(v) (((v) << 0x8) & 0x100)
/* Field IDM_SINK_EN - 1: Current Sink on DM Enabled 0: Current Sink on DM Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_IDM_SINK_EN_SHIFT 9
#define IMX_USB3_USBSS_OTGCTRL1_IDM_SINK_EN_MASK 0x200
#define IMX_USB3_USBSS_OTGCTRL1_IDM_SINK_EN(v) (((v) << 0x9) & 0x200)
/* Field IDP_SINK_EN - 1: Current Sink on DP Enabled 0: Current Sink on DP Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_IDP_SINK_EN_SHIFT 10
#define IMX_USB3_USBSS_OTGCTRL1_IDP_SINK_EN_MASK 0x400
#define IMX_USB3_USBSS_OTGCTRL1_IDP_SINK_EN(v) (((v) << 0xA) & 0x400)
/* Field IDP_SRC_EN - 1: Current Source on DP Enabled 0: Current Source on DP Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_IDP_SRC_EN_SHIFT 11
#define IMX_USB3_USBSS_OTGCTRL1_IDP_SRC_EN_MASK 0x800
#define IMX_USB3_USBSS_OTGCTRL1_IDP_SRC_EN(v) (((v) << 0xB) & 0x800)
/* Field VDM_SRC_EN - 1: Voltage Source on DM Enabled 0: Voltage Source on DM Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_VDM_SRC_EN_SHIFT 12
#define IMX_USB3_USBSS_OTGCTRL1_VDM_SRC_EN_MASK 0x1000
#define IMX_USB3_USBSS_OTGCTRL1_VDM_SRC_EN(v) (((v) << 0xC) & 0x1000)
/* Field VDP_SRC_EN - 1: Voltage Source on DP Enabled 0: Voltage Source on DP Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_VDP_SRC_EN_SHIFT 13
#define IMX_USB3_USBSS_OTGCTRL1_VDP_SRC_EN_MASK 0x2000
#define IMX_USB3_USBSS_OTGCTRL1_VDP_SRC_EN(v) (((v) << 0xD) & 0x2000)
/* Field DM_VDAT_REF_COMP_EN - 1: DM to VDAT_REF Comparator Enabled 0: DM to VDAT_REF Comparator Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_DM_VDAT_REF_COMP_EN_SHIFT 16
#define IMX_USB3_USBSS_OTGCTRL1_DM_VDAT_REF_COMP_EN_MASK 0x10000
#define IMX_USB3_USBSS_OTGCTRL1_DM_VDAT_REF_COMP_EN(v) (((v) << 0x10) & 0x10000)
/* Field DM_VLGC_COMP_EN - 1: DM to VLGC Comparator Enabled 0: DM to VLGC Comparator Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_DM_VLGC_COMP_EN_SHIFT 17
#define IMX_USB3_USBSS_OTGCTRL1_DM_VLGC_COMP_EN_MASK 0x20000
#define IMX_USB3_USBSS_OTGCTRL1_DM_VLGC_COMP_EN(v) (((v) << 0x11) & 0x20000)
/* Field DP_VDAT_REF_COMP_EN - 1: DP to VDAT_REF Comparator Enabled 0: DP to VDAT_REF Comparator Disabled */
#define IMX_USB3_USBSS_OTGCTRL1_DP_VDAT_REF_COMP_EN_SHIFT 18
#define IMX_USB3_USBSS_OTGCTRL1_DP_VDAT_REF_COMP_EN_MASK 0x40000
#define IMX_USB3_USBSS_OTGCTRL1_DP_VDAT_REF_COMP_EN(v) (((v) << 0x12) & 0x40000)
/* Field RID_FLOAT_COMP_EN - 1: RID Float Comparator Enabled 0: RID Float Comparator Disabled Note: This ID Comparator enable is used to detect whether the ID line is floating or non-floating. If it is identified to be non-floating, then rid_nonfloat_comp_en is enabled to check for RID_A or RID_B or RID_C or RID_GND. */
#define IMX_USB3_USBSS_OTGCTRL1_RID_FLOAT_COMP_EN_SHIFT 19
#define IMX_USB3_USBSS_OTGCTRL1_RID_FLOAT_COMP_EN_MASK 0x80000
#define IMX_USB3_USBSS_OTGCTRL1_RID_FLOAT_COMP_EN(v) (((v) << 0x13) & 0x80000)
/* Field RID_NONFLOAT_COMP_EN - 1: RID Non-Float Comparator Enabled 0: RID Non-Float Comparator Disabled Note: This ID Comparator enable is used to detect the presence of RID_A or RID_B or RID_C or RID_GND when the ID pin is non-floating. */
#define IMX_USB3_USBSS_OTGCTRL1_RID_NONFLOAT_COMP_EN_SHIFT 20
#define IMX_USB3_USBSS_OTGCTRL1_RID_NONFLOAT_COMP_EN_MASK 0x100000
#define IMX_USB3_USBSS_OTGCTRL1_RID_NONFLOAT_COMP_EN(v) (((v) << 0x14) & 0x100000)
/* Field BC_DMPULLDOWN - BC dmpulldown enable */
#define IMX_USB3_USBSS_OTGCTRL1_BC_DMPULLDOWN_SHIFT 21
#define IMX_USB3_USBSS_OTGCTRL1_BC_DMPULLDOWN_MASK 0x200000
#define IMX_USB3_USBSS_OTGCTRL1_BC_DMPULLDOWN(v) (((v) << 0x15) & 0x200000)
/* Field BC_DPPULLDOWN - BC dppulldown enable */
#define IMX_USB3_USBSS_OTGCTRL1_BC_DPPULLDOWN_SHIFT 22
#define IMX_USB3_USBSS_OTGCTRL1_BC_DPPULLDOWN_MASK 0x400000
#define IMX_USB3_USBSS_OTGCTRL1_BC_DPPULLDOWN(v) (((v) << 0x16) & 0x400000)
/* Field BC_PULLDOWNCTRL - BC pulldowncotrol 1: puldowns are controlled by bc_dppulldown and bc_dmpulldown 0: puldowns are controlled by OTG */
#define IMX_USB3_USBSS_OTGCTRL1_BC_PULLDOWNCTRL_SHIFT 23
#define IMX_USB3_USBSS_OTGCTRL1_BC_PULLDOWNCTRL_MASK 0x800000
#define IMX_USB3_USBSS_OTGCTRL1_BC_PULLDOWNCTRL(v) (((v) << 0x17) & 0x800000)
/* Field IDPULLUP - ID Pin Sample Enable: Active High. Signal that enables the sampling of the analog ID line. 0: Sampling of ID pin is disabled, iddig is not valid 1: Sampling of ID pin is enabled */
#define IMX_USB3_USBSS_OTGCTRL1_IDPULLUP_SHIFT 24
#define IMX_USB3_USBSS_OTGCTRL1_IDPULLUP_MASK 0x1000000
#define IMX_USB3_USBSS_OTGCTRL1_IDPULLUP(v) (((v) << 0x18) & 0x1000000)
/* Field DRIVE_VBUS_SEL - VBUS drive control select. This register allows SW driver take control over drive_vbus as follows: 0: drive_vbus controlled from OTG controller 1: drive_vbus controlled from SFR */
#define IMX_USB3_USBSS_OTGCTRL1_DRIVE_VBUS_SEL_SHIFT 25
#define IMX_USB3_USBSS_OTGCTRL1_DRIVE_VBUS_SEL_MASK 0x2000000
#define IMX_USB3_USBSS_OTGCTRL1_DRIVE_VBUS_SEL(v) (((v) << 0x19) & 0x2000000)
/* Field DRIVE_VBUS_SFR - SFR drive_vbus control. 0: drive_vbus = 0 1: drive_vbus = 1 This bit is valid only with OTGCTRL1.drive_vbus_sel set to '1'. This bit is auto-cleared upon over-current condition. */
#define IMX_USB3_USBSS_OTGCTRL1_DRIVE_VBUS_SFR_SHIFT 26
#define IMX_USB3_USBSS_OTGCTRL1_DRIVE_VBUS_SFR_MASK 0x4000000
#define IMX_USB3_USBSS_OTGCTRL1_DRIVE_VBUS_SFR(v) (((v) << 0x1A) & 0x4000000)
/* Field FORCE_OPMODE01 - with both cores disabled seting this bit to '1' will result with forcing UTMI opmode set to 2'b01 (non-driving) */
#define IMX_USB3_USBSS_OTGCTRL1_FORCE_OPMODE01_SHIFT 27
#define IMX_USB3_USBSS_OTGCTRL1_FORCE_OPMODE01_MASK 0x8000000
#define IMX_USB3_USBSS_OTGCTRL1_FORCE_OPMODE01(v) (((v) << 0x1B) & 0x8000000)

/* IMX_USB3_USBSS_OTGCTRL2 - OTG Control Register 2 */
typedef union IMX_USB3_USBSS_OTGCTRL2_union_t {
    uint32_t R;
    struct {
        uint32_t TA_ADP_PRB  :8;                 /* A-device ADP probing period. TA_ADP_PRB = {reg_value} * 10 ms */
        uint32_t TB_ADP_PRB  :8;                 /* B-device ADP probing period. TB_ADP_PRB = {reg_value} * 10 ms */
        uint32_t ADP_CHRG_TMOUT :8;              /* ADP probing timeout value. Defines maximum time for ADP charging. If this time is reached during charging then adp_chrg_tmout_det bit in OTGADPBCSTS is set ADP_CHRG_TMOUT = {reg_value} * 1 ms */
        uint32_t T_ADP_DSCHG :8;                 /* ADP probing discharge time. T_ADP_DSCHG = {reg_value} * 1 ms */
    } B;
} IMX_USB3_USBSS_OTGCTRL2_t;

/* Register OTGCTRL2 - OTG Control Register 2 */
#define IMX_USB3_USBSS_OTGCTRL2_OFFSET 0x5C
/* Field TA_ADP_PRB - A-device ADP probing period. TA_ADP_PRB = {reg_value} * 10 ms */
#define IMX_USB3_USBSS_OTGCTRL2_TA_ADP_PRB_SHIFT 0
#define IMX_USB3_USBSS_OTGCTRL2_TA_ADP_PRB_MASK 0xFF
#define IMX_USB3_USBSS_OTGCTRL2_TA_ADP_PRB(v) (((v) << 0) & 0xFF)
/* Field TB_ADP_PRB - B-device ADP probing period. TB_ADP_PRB = {reg_value} * 10 ms */
#define IMX_USB3_USBSS_OTGCTRL2_TB_ADP_PRB_SHIFT 8
#define IMX_USB3_USBSS_OTGCTRL2_TB_ADP_PRB_MASK 0xFF00
#define IMX_USB3_USBSS_OTGCTRL2_TB_ADP_PRB(v) (((v) << 0x8) & 0xFF00)
/* Field ADP_CHRG_TMOUT - ADP probing timeout value. Defines maximum time for ADP charging. If this time is reached during charging then adp_chrg_tmout_det bit in OTGADPBCSTS is set ADP_CHRG_TMOUT = {reg_value} * 1 ms */
#define IMX_USB3_USBSS_OTGCTRL2_ADP_CHRG_TMOUT_SHIFT 16
#define IMX_USB3_USBSS_OTGCTRL2_ADP_CHRG_TMOUT_MASK 0xFF0000
#define IMX_USB3_USBSS_OTGCTRL2_ADP_CHRG_TMOUT(v) (((v) << 0x10) & 0xFF0000)
/* Field T_ADP_DSCHG - ADP probing discharge time. T_ADP_DSCHG = {reg_value} * 1 ms */
#define IMX_USB3_USBSS_OTGCTRL2_T_ADP_DSCHG_SHIFT 24
#define IMX_USB3_USBSS_OTGCTRL2_T_ADP_DSCHG_MASK 0xFF000000
#define IMX_USB3_USBSS_OTGCTRL2_T_ADP_DSCHG(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_HCIVERSION_CAPLENGTH - HCIVERSION_CAPLENGTH */
typedef union IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_union_t {
    uint32_t R;
    struct {
        uint32_t CAPLENGTH   :8;                 /* Capability Registers Length (CAPLENGTH). This register is used as an offset to add to register base to find the beginning of the Operational Register Space. */
        uint32_t _unused8    :8;
        uint32_t HCIVERSION  :16;                /* Host Controller Interface Version Number (HCIVERSION). This is a two-byte register containing a BCD encoding of the xHCI specification revision number supported by this host controller. The most significant byte of this register represents a major revision and the least significant byte is the minor revision. e.g. 0100h corresponds to xHCI version 1.0. */
    } B;
} IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_t;

/* Register HCIVERSION_CAPLENGTH - HCIVERSION_CAPLENGTH */
#define IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_OFFSET 0x10000
/* Field CAPLENGTH - Capability Registers Length (CAPLENGTH). This register is used as an offset to add to register base to find the beginning of the Operational Register Space. */
#define IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_CAPLENGTH_SHIFT 0
#define IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_CAPLENGTH_MASK 0xFF
#define IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_CAPLENGTH(v) (((v) << 0) & 0xFF)
/* Field HCIVERSION - Host Controller Interface Version Number (HCIVERSION). This is a two-byte register containing a BCD encoding of the xHCI specification revision number supported by this host controller. The most significant byte of this register represents a major revision and the least significant byte is the minor revision. e.g. 0100h corresponds to xHCI version 1.0. */
#define IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_HCIVERSION_SHIFT 16
#define IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_HCIVERSION_MASK 0xFFFF0000
#define IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_HCIVERSION(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_HCSPARAMS1 - Structural Parameters 1 (HCSPARAMS1). */
typedef union IMX_USB3_USBSS_HCSPARAMS1_union_t {
    uint32_t R;
    struct {
        uint32_t MAXSLOTS    :8;                 /* Number of Device Slots (MaxSlots). This field specifies the maximum number of Device Context Structures and Doorbell Array entries this host controller can support. Valid values are in the range of 1 to 255. The value of 0 is reserved. */
        uint32_t MAXINTRS    :11;                /* Number of Interrupters (MaxIntrs). This field specifies the number of Interrupters implemented on this host controller. Each Interrupter may be allocated to a MSI or MSI-X vector and controls its generation and moderation. The value of this field determines how many Interrupter Register Sets are addressable in the Runtime Register Space (refer to section 5.5 of xHCI specification). Valid values are in the range of 1h to 400h. A '0' in this field is undefined. */
        uint32_t _unused19   :5;
        uint32_t MAXPORTS    :8;                 /* Number of Ports (MaxPorts). This field specifies the maximum Port Number value, i.e. the highest numbered Port Register Set that are addressable in the Operational Register Space. Valid values are in the range of 1h to FFh. The value in this field shall reflect the maximum Port Number value assigned by an xHCI Supported Protocol Capability, described in section 7.2 of xHCI specification. Software shall refer to these capabilities to identify whether a specific Port Number is valid, and the protocol supported by the associated Port Register Set. */
    } B;
} IMX_USB3_USBSS_HCSPARAMS1_t;

/* Register HCSPARAMS1 - Structural Parameters 1 (HCSPARAMS1). */
#define IMX_USB3_USBSS_HCSPARAMS1_OFFSET 0x10004
/* Field MAXSLOTS - Number of Device Slots (MaxSlots). This field specifies the maximum number of Device Context Structures and Doorbell Array entries this host controller can support. Valid values are in the range of 1 to 255. The value of 0 is reserved. */
#define IMX_USB3_USBSS_HCSPARAMS1_MAXSLOTS_SHIFT 0
#define IMX_USB3_USBSS_HCSPARAMS1_MAXSLOTS_MASK 0xFF
#define IMX_USB3_USBSS_HCSPARAMS1_MAXSLOTS(v) (((v) << 0) & 0xFF)
/* Field MAXINTRS - Number of Interrupters (MaxIntrs). This field specifies the number of Interrupters implemented on this host controller. Each Interrupter may be allocated to a MSI or MSI-X vector and controls its generation and moderation. The value of this field determines how many Interrupter Register Sets are addressable in the Runtime Register Space (refer to section 5.5 of xHCI specification). Valid values are in the range of 1h to 400h. A '0' in this field is undefined. */
#define IMX_USB3_USBSS_HCSPARAMS1_MAXINTRS_SHIFT 8
#define IMX_USB3_USBSS_HCSPARAMS1_MAXINTRS_MASK 0x7FF00
#define IMX_USB3_USBSS_HCSPARAMS1_MAXINTRS(v) (((v) << 0x8) & 0x7FF00)
/* Field MAXPORTS - Number of Ports (MaxPorts). This field specifies the maximum Port Number value, i.e. the highest numbered Port Register Set that are addressable in the Operational Register Space. Valid values are in the range of 1h to FFh. The value in this field shall reflect the maximum Port Number value assigned by an xHCI Supported Protocol Capability, described in section 7.2 of xHCI specification. Software shall refer to these capabilities to identify whether a specific Port Number is valid, and the protocol supported by the associated Port Register Set. */
#define IMX_USB3_USBSS_HCSPARAMS1_MAXPORTS_SHIFT 24
#define IMX_USB3_USBSS_HCSPARAMS1_MAXPORTS_MASK 0xFF000000
#define IMX_USB3_USBSS_HCSPARAMS1_MAXPORTS(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_HCSPARAMS2 - Structural Parameters 2 (HCSPARAMS 2). */
typedef union IMX_USB3_USBSS_HCSPARAMS2_union_t {
    uint32_t R;
    struct {
        uint32_t IST         :4;                 /* Isochronous Scheduling Threshold (IST). Default = implementation dependent. The value in this field indicates to system software the minimum distance (in time) that it is required to stay ahead of the host controller while adding TRBs, in order to have the host controller process them at the correct time. The value shall be specified in terms of number of frames/microframes. If bit [3] of IST is cleared to '0', software can add a TRB no later than IST[2:0] Microframes before that TRB is scheduled to be executed. If bit [3] of IST is set to '1', software can add a TRB no later than IST[2:0] Frames before that TRB is scheduled to be executed. Refer to Section 4.14.2 of xHCI specification for details on how software uses this information for scheduling isochronous transfers. */
        uint32_t ERSTMAX     :4;                 /* Event Ring Segment Table Max (ERST Max). Default = implementation dependent. Valid values are 0-15. This field determines the maximum value supported the Event Ring Segment Table Base Size registers (5.5.2.3.1), where: The maximum number of Event Ring Segment Table entries = 2 ^(ERSTMax), e.g. if the ERST Max = 7, then the xHC Event Ring Segment Table(s) supports up to 128 entries, 15 then 32K entries, etc. */
        uint32_t _unused8    :13;
        uint32_t MAXSPBUFHI  :5;                 /* Max Scratchpad Buffers (Max Scratchpad Bufs Hi). Default = implementation dependent. This field indicates the high order 5 bits of the number of Scratchpad Buffers system software shall reserve for the xHC. Refer to section 4.20 of xHCI specification for more information. */
        uint32_t SPR         :1;                 /* Scratchpad Restore (SPR). Default = implementation dependent. If Max Scratchpad Buffers is > 0 then this flag indicates whether the xHC uses the Scratchpad Buffers for saving state when executing Save and Restore State operations. If Max Scratchpad Buffers is = 0 then this flag shall be 0. Refer to section 4.23.2 of xHCI specification for more information. A value of '1' indicates that the xHC requires the integrity of the Scratchpad Buffer space to be maintained across power events. A value of '0' indicates that the Scratchpad Buffer space may be freed and reallocated between power events. */
        uint32_t MAXSPBUFLO  :5;                 /* Max Scratchpad Buffers (Max Scratchpad Bufs Lo). Default = implementation dependent. Valid values for Max Scratchpad Buffers (Hi and Lo) are 0-1023. This field indicates the low order 5 bits of the number of Scratchpad Buffers system software shall reserve for the xHC. Refer to section 4.20 of xHCI specification for more information. */
    } B;
} IMX_USB3_USBSS_HCSPARAMS2_t;

/* Register HCSPARAMS2 - Structural Parameters 2 (HCSPARAMS 2). */
#define IMX_USB3_USBSS_HCSPARAMS2_OFFSET 0x10008
/* Field IST - Isochronous Scheduling Threshold (IST). Default = implementation dependent. The value in this field indicates to system software the minimum distance (in time) that it is required to stay ahead of the host controller while adding TRBs, in order to have the host controller process them at the correct time. The value shall be specified in terms of number of frames/microframes. If bit [3] of IST is cleared to '0', software can add a TRB no later than IST[2:0] Microframes before that TRB is scheduled to be executed. If bit [3] of IST is set to '1', software can add a TRB no later than IST[2:0] Frames before that TRB is scheduled to be executed. Refer to Section 4.14.2 of xHCI specification for details on how software uses this information for scheduling isochronous transfers. */
#define IMX_USB3_USBSS_HCSPARAMS2_IST_SHIFT 0
#define IMX_USB3_USBSS_HCSPARAMS2_IST_MASK 0xF
#define IMX_USB3_USBSS_HCSPARAMS2_IST(v) (((v) << 0) & 0xF)
/* Field ERSTMAX - Event Ring Segment Table Max (ERST Max). Default = implementation dependent. Valid values are 0-15. This field determines the maximum value supported the Event Ring Segment Table Base Size registers (5.5.2.3.1), where: The maximum number of Event Ring Segment Table entries = 2 ^(ERSTMax), e.g. if the ERST Max = 7, then the xHC Event Ring Segment Table(s) supports up to 128 entries, 15 then 32K entries, etc. */
#define IMX_USB3_USBSS_HCSPARAMS2_ERSTMAX_SHIFT 4
#define IMX_USB3_USBSS_HCSPARAMS2_ERSTMAX_MASK 0xF0
#define IMX_USB3_USBSS_HCSPARAMS2_ERSTMAX(v) (((v) << 0x4) & 0xF0)
/* Field MAXSPBUFHI - Max Scratchpad Buffers (Max Scratchpad Bufs Hi). Default = implementation dependent. This field indicates the high order 5 bits of the number of Scratchpad Buffers system software shall reserve for the xHC. Refer to section 4.20 of xHCI specification for more information. */
#define IMX_USB3_USBSS_HCSPARAMS2_MAXSPBUFHI_SHIFT 21
#define IMX_USB3_USBSS_HCSPARAMS2_MAXSPBUFHI_MASK 0x3E00000
#define IMX_USB3_USBSS_HCSPARAMS2_MAXSPBUFHI(v) (((v) << 0x15) & 0x3E00000)
/* Field SPR - Scratchpad Restore (SPR). Default = implementation dependent. If Max Scratchpad Buffers is > 0 then this flag indicates whether the xHC uses the Scratchpad Buffers for saving state when executing Save and Restore State operations. If Max Scratchpad Buffers is = 0 then this flag shall be 0. Refer to section 4.23.2 of xHCI specification for more information. A value of '1' indicates that the xHC requires the integrity of the Scratchpad Buffer space to be maintained across power events. A value of '0' indicates that the Scratchpad Buffer space may be freed and reallocated between power events. */
#define IMX_USB3_USBSS_HCSPARAMS2_SPR_SHIFT 26
#define IMX_USB3_USBSS_HCSPARAMS2_SPR_MASK 0x4000000
#define IMX_USB3_USBSS_HCSPARAMS2_SPR(v) (((v) << 0x1A) & 0x4000000)
/* Field MAXSPBUFLO - Max Scratchpad Buffers (Max Scratchpad Bufs Lo). Default = implementation dependent. Valid values for Max Scratchpad Buffers (Hi and Lo) are 0-1023. This field indicates the low order 5 bits of the number of Scratchpad Buffers system software shall reserve for the xHC. Refer to section 4.20 of xHCI specification for more information. */
#define IMX_USB3_USBSS_HCSPARAMS2_MAXSPBUFLO_SHIFT 27
#define IMX_USB3_USBSS_HCSPARAMS2_MAXSPBUFLO_MASK 0xF8000000
#define IMX_USB3_USBSS_HCSPARAMS2_MAXSPBUFLO(v) (((v) << 0x1B) & 0xF8000000)

/* IMX_USB3_USBSS_HCSPARAMS3 - Structural Parameters 3 (HCSPARAMS3). */
typedef union IMX_USB3_USBSS_HCSPARAMS3_union_t {
    uint32_t R;
    struct {
        uint32_t U1DEVEXITLAT :8;                /* U1 Device Exit Latency. Worst case latency to transition a root hub Port Link State (PLS) from U1 to U0. Applies to all root hub ports. The following are permissible values: 00h Zero, 01h Less than 1 s., 02h Less than 2 s., ... 0Ah Less than 10 s., 0B-FFh Reserved. */
        uint32_t _unused8    :8;
        uint32_t U2DEVEXITLAT :16;               /* U2 Device Exit Latency. Worst case latency to transition from U2 to U0. Applies to all root hub ports. The following are permissible values: 0000h Zero, 0001h Less than 1 s., 0002h Less than 2 s., ... 07FFh Less than 2047 s., 0800-FFFFh Reserved */
    } B;
} IMX_USB3_USBSS_HCSPARAMS3_t;

/* Register HCSPARAMS3 - Structural Parameters 3 (HCSPARAMS3). */
#define IMX_USB3_USBSS_HCSPARAMS3_OFFSET 0x1000C
/* Field U1DEVEXITLAT - U1 Device Exit Latency. Worst case latency to transition a root hub Port Link State (PLS) from U1 to U0. Applies to all root hub ports. The following are permissible values: 00h Zero, 01h Less than 1 s., 02h Less than 2 s., ... 0Ah Less than 10 s., 0B-FFh Reserved. */
#define IMX_USB3_USBSS_HCSPARAMS3_U1DEVEXITLAT_SHIFT 0
#define IMX_USB3_USBSS_HCSPARAMS3_U1DEVEXITLAT_MASK 0xFF
#define IMX_USB3_USBSS_HCSPARAMS3_U1DEVEXITLAT(v) (((v) << 0) & 0xFF)
/* Field U2DEVEXITLAT - U2 Device Exit Latency. Worst case latency to transition from U2 to U0. Applies to all root hub ports. The following are permissible values: 0000h Zero, 0001h Less than 1 s., 0002h Less than 2 s., ... 07FFh Less than 2047 s., 0800-FFFFh Reserved */
#define IMX_USB3_USBSS_HCSPARAMS3_U2DEVEXITLAT_SHIFT 16
#define IMX_USB3_USBSS_HCSPARAMS3_U2DEVEXITLAT_MASK 0xFFFF0000
#define IMX_USB3_USBSS_HCSPARAMS3_U2DEVEXITLAT(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_HCCPARAMS - Capability Parameters (HCCPARAMS). */
typedef union IMX_USB3_USBSS_HCCPARAMS_union_t {
    uint32_t R;
    struct {
        uint32_t AC64        :1;                 /* 64-bit Addressing Capability (AC64). This flag documents the addressing range capability of this implementation. The value of this flag determines whether the xHC has implemented the high order 32 bits of 64 bit register and data structure pointer fields. Values for this flag have the following interpretation: '0': 32-bit address memory pointers implemented, '1': 64-bit address memory pointers implemented. If 32-bit address memory pointers are implemented, the xHC shall ignore the high order 32 bits of 64 bit data structure pointer fields, and system software shall ignore the high order 32 bits of 64 bit xHC registers. */
        uint32_t BNC         :1;                 /* BW Negotiation Capability (BNC). This flag identifies whether the xHC has implemented the Bandwidth Negotiation. Values for this flag have the following interpretation: '0': BW Negotiation not implemented '1': BW Negotiation implemented Refer to section 4.16 of xHCI specification for more information on Bandwidth Negotiation. */
        uint32_t CSZ         :1;                 /* Context Size (CSZ). If this bit is set to '1', then the xHC uses 64 byte Context data structures. If this bit is cleared to 0, then the xHC uses 32 byte Context data structures. Note: This flag does not apply to Stream Contexts. */
        uint32_t PPC         :1;                 /* Port Power Control (PPC). This flag indicates whether the host controller implementation includes port power control. A '1' in this bit indicates the ports have port power switches. A '0' in this bit indicates the port do not have port power switches. The value of this flag affects the functionality of the PP flag in each port status and control register (refer to Section 5.4.8 of xHCI specification). When DEBUG_CTRL_REG capability is used (CDNS_RM_CBIT_DEBUG_CTRL_REG is not defined) then this bit is treated as RW. Its value can be changed only by writes to bit 8 of DEBUG_CTRL_REG (port_pwr_ctrl_toggle). Direct writes to this bit are not possible. */
        uint32_t PIND        :1;                 /* Port Indicators (PIND). This bit indicates whether the xHC root hub ports support port indicator control. When this bit is a '1', the port status and control registers include a read/writeable field for controlling the state of the port indicator. Refer to Section 5.4.8 of xHCI specification for definition of the Port Indicator Control field (PIC field of PORTSC register). */
        uint32_t LHRC        :1;                 /* Light HC Reset Capability (LHRC). This flag indicates whether the host controller implementation supports a Light Host Controller Reset. A '1' in this bit indicates that Light Host Controller Reset is supported. A '0' in this bit indicates that Light Host Controller Reset is not supported. The value of this flag affects the functionality of the Light Host Controller Reset (LHCRST) flag in the USBCMD register (refer to Section 5.4.1 of xHCI specification). */
        uint32_t LTC         :1;                 /* Latency Tolerance Messaging Capability (LTC). This flag indicates whether the host controller implementation supports Latency Tolerance Messaging (LTM). A '1' in this bit indicates that LTM is supported. A 0 in this bit indicates that LTM is not supported. Refer to section 4.13.1 of xHCI specification for more information on LTM. */
        uint32_t NSS         :1;                 /* No Secondary SID Support (NSS). This flag indicates whether the host controller implementation supports Secondary Stream IDs. A '1'in this bit indicates that Secondary Stream ID decoding is not supported. A '0' in this bit indicates that Secondary Stream ID decoding is supported. (refer to Sections 4.12.2 and 6.2.3 of xHCI specification). */
        uint32_t PAE         :1;                 /* Parse All Event Data (PAE). This flag indicates whether the host controller implementation Parses all Event Data TRBs while advancing to the next TD after a Short Packet, or it skips all but the first Event Data TRB. A '1' in this bit indicates that all Event Data TRBs are parsed. A '0' in this bit indicates that only the first Event Data TRB is parsed (refer to section 4.10.1.1 of xHCI specification). */
        uint32_t SPC         :1;                 /* Stopped - Short Packet Capability (SPC). This flag indicates that the host controller implementation is capable of generating a Stopped - Short Packet Completion Code. Refer to section 4.6.9 of xHCI specification for more information. */
        uint32_t _unused10   :2;
        uint32_t MAXPSASIZE  :4;                 /* Maximum Primary Stream Array Size (MaxPSASize). This fields identifies the maximum size Primary Stream Array that the xHC supports. The Primary Stream Array size = 2MaxPSASize+1. Valid MaxPSASize values are 0 to 15, where 0 indicates that Streams are not supported. */
        uint32_t XECP        :16;                /* xHCI Extended Capabilities Pointer (xECP). This field indicates the existence of a capabilities list. The value of this field indicates a relative offset, in 32-bit words, from Base to the beginning of the first extended capability. For example, using the offset of Base is 1000h and the xECP value of 0068h, we can calculate the following effective address of the first extended capability: 1000h + (0068h << 2) -> 1000h + 01A0h -> 11A0h */
    } B;
} IMX_USB3_USBSS_HCCPARAMS_t;

/* Register HCCPARAMS - Capability Parameters (HCCPARAMS). */
#define IMX_USB3_USBSS_HCCPARAMS_OFFSET 0x10010
/* Field AC64 - 64-bit Addressing Capability (AC64). This flag documents the addressing range capability of this implementation. The value of this flag determines whether the xHC has implemented the high order 32 bits of 64 bit register and data structure pointer fields. Values for this flag have the following interpretation: '0': 32-bit address memory pointers implemented, '1': 64-bit address memory pointers implemented. If 32-bit address memory pointers are implemented, the xHC shall ignore the high order 32 bits of 64 bit data structure pointer fields, and system software shall ignore the high order 32 bits of 64 bit xHC registers. */
#define IMX_USB3_USBSS_HCCPARAMS_AC64_SHIFT 0
#define IMX_USB3_USBSS_HCCPARAMS_AC64_MASK 0x1
#define IMX_USB3_USBSS_HCCPARAMS_AC64(v) (((v) << 0) & 0x1)
/* Field BNC - BW Negotiation Capability (BNC). This flag identifies whether the xHC has implemented the Bandwidth Negotiation. Values for this flag have the following interpretation: '0': BW Negotiation not implemented '1': BW Negotiation implemented Refer to section 4.16 of xHCI specification for more information on Bandwidth Negotiation. */
#define IMX_USB3_USBSS_HCCPARAMS_BNC_SHIFT 1
#define IMX_USB3_USBSS_HCCPARAMS_BNC_MASK 0x2
#define IMX_USB3_USBSS_HCCPARAMS_BNC(v) (((v) << 0x1) & 0x2)
/* Field CSZ - Context Size (CSZ). If this bit is set to '1', then the xHC uses 64 byte Context data structures. If this bit is cleared to 0, then the xHC uses 32 byte Context data structures. Note: This flag does not apply to Stream Contexts. */
#define IMX_USB3_USBSS_HCCPARAMS_CSZ_SHIFT 2
#define IMX_USB3_USBSS_HCCPARAMS_CSZ_MASK 0x4
#define IMX_USB3_USBSS_HCCPARAMS_CSZ(v) (((v) << 0x2) & 0x4)
/* Field PPC - Port Power Control (PPC). This flag indicates whether the host controller implementation includes port power control. A '1' in this bit indicates the ports have port power switches. A '0' in this bit indicates the port do not have port power switches. The value of this flag affects the functionality of the PP flag in each port status and control register (refer to Section 5.4.8 of xHCI specification). When DEBUG_CTRL_REG capability is used (CDNS_RM_CBIT_DEBUG_CTRL_REG is not defined) then this bit is treated as RW. Its value can be changed only by writes to bit 8 of DEBUG_CTRL_REG (port_pwr_ctrl_toggle). Direct writes to this bit are not possible. */
#define IMX_USB3_USBSS_HCCPARAMS_PPC_SHIFT 3
#define IMX_USB3_USBSS_HCCPARAMS_PPC_MASK 0x8
#define IMX_USB3_USBSS_HCCPARAMS_PPC(v) (((v) << 0x3) & 0x8)
/* Field PIND - Port Indicators (PIND). This bit indicates whether the xHC root hub ports support port indicator control. When this bit is a '1', the port status and control registers include a read/writeable field for controlling the state of the port indicator. Refer to Section 5.4.8 of xHCI specification for definition of the Port Indicator Control field (PIC field of PORTSC register). */
#define IMX_USB3_USBSS_HCCPARAMS_PIND_SHIFT 4
#define IMX_USB3_USBSS_HCCPARAMS_PIND_MASK 0x10
#define IMX_USB3_USBSS_HCCPARAMS_PIND(v) (((v) << 0x4) & 0x10)
/* Field LHRC - Light HC Reset Capability (LHRC). This flag indicates whether the host controller implementation supports a Light Host Controller Reset. A '1' in this bit indicates that Light Host Controller Reset is supported. A '0' in this bit indicates that Light Host Controller Reset is not supported. The value of this flag affects the functionality of the Light Host Controller Reset (LHCRST) flag in the USBCMD register (refer to Section 5.4.1 of xHCI specification). */
#define IMX_USB3_USBSS_HCCPARAMS_LHRC_SHIFT 5
#define IMX_USB3_USBSS_HCCPARAMS_LHRC_MASK 0x20
#define IMX_USB3_USBSS_HCCPARAMS_LHRC(v) (((v) << 0x5) & 0x20)
/* Field LTC - Latency Tolerance Messaging Capability (LTC). This flag indicates whether the host controller implementation supports Latency Tolerance Messaging (LTM). A '1' in this bit indicates that LTM is supported. A 0 in this bit indicates that LTM is not supported. Refer to section 4.13.1 of xHCI specification for more information on LTM. */
#define IMX_USB3_USBSS_HCCPARAMS_LTC_SHIFT 6
#define IMX_USB3_USBSS_HCCPARAMS_LTC_MASK 0x40
#define IMX_USB3_USBSS_HCCPARAMS_LTC(v) (((v) << 0x6) & 0x40)
/* Field NSS - No Secondary SID Support (NSS). This flag indicates whether the host controller implementation supports Secondary Stream IDs. A '1'in this bit indicates that Secondary Stream ID decoding is not supported. A '0' in this bit indicates that Secondary Stream ID decoding is supported. (refer to Sections 4.12.2 and 6.2.3 of xHCI specification). */
#define IMX_USB3_USBSS_HCCPARAMS_NSS_SHIFT 7
#define IMX_USB3_USBSS_HCCPARAMS_NSS_MASK 0x80
#define IMX_USB3_USBSS_HCCPARAMS_NSS(v) (((v) << 0x7) & 0x80)
/* Field PAE - Parse All Event Data (PAE). This flag indicates whether the host controller implementation Parses all Event Data TRBs while advancing to the next TD after a Short Packet, or it skips all but the first Event Data TRB. A '1' in this bit indicates that all Event Data TRBs are parsed. A '0' in this bit indicates that only the first Event Data TRB is parsed (refer to section 4.10.1.1 of xHCI specification). */
#define IMX_USB3_USBSS_HCCPARAMS_PAE_SHIFT 8
#define IMX_USB3_USBSS_HCCPARAMS_PAE_MASK 0x100
#define IMX_USB3_USBSS_HCCPARAMS_PAE(v) (((v) << 0x8) & 0x100)
/* Field SPC - Stopped - Short Packet Capability (SPC). This flag indicates that the host controller implementation is capable of generating a Stopped - Short Packet Completion Code. Refer to section 4.6.9 of xHCI specification for more information. */
#define IMX_USB3_USBSS_HCCPARAMS_SPC_SHIFT 9
#define IMX_USB3_USBSS_HCCPARAMS_SPC_MASK 0x200
#define IMX_USB3_USBSS_HCCPARAMS_SPC(v) (((v) << 0x9) & 0x200)
/* Field MAXPSASIZE - Maximum Primary Stream Array Size (MaxPSASize). This fields identifies the maximum size Primary Stream Array that the xHC supports. The Primary Stream Array size = 2MaxPSASize+1. Valid MaxPSASize values are 0 to 15, where 0 indicates that Streams are not supported. */
#define IMX_USB3_USBSS_HCCPARAMS_MAXPSASIZE_SHIFT 12
#define IMX_USB3_USBSS_HCCPARAMS_MAXPSASIZE_MASK 0xF000
#define IMX_USB3_USBSS_HCCPARAMS_MAXPSASIZE(v) (((v) << 0xC) & 0xF000)
/* Field XECP - xHCI Extended Capabilities Pointer (xECP). This field indicates the existence of a capabilities list. The value of this field indicates a relative offset, in 32-bit words, from Base to the beginning of the first extended capability. For example, using the offset of Base is 1000h and the xECP value of 0068h, we can calculate the following effective address of the first extended capability: 1000h + (0068h << 2) -> 1000h + 01A0h -> 11A0h */
#define IMX_USB3_USBSS_HCCPARAMS_XECP_SHIFT 16
#define IMX_USB3_USBSS_HCCPARAMS_XECP_MASK 0xFFFF0000
#define IMX_USB3_USBSS_HCCPARAMS_XECP(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DBOFF - This register defines the offset of the Doorbell Array base address from the Base. */
typedef union IMX_USB3_USBSS_DBOFF_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :2;
        uint32_t DAO         :30;                /* Doorbell Array Offset, RO. Default = implementation dependent. This field defines the offset in Dwords of the Doorbell Array base address from the Base (i.e. the base address of the xHCI Capability register address space). */
    } B;
} IMX_USB3_USBSS_DBOFF_t;

/* Register DBOFF - This register defines the offset of the Doorbell Array base address from the Base. */
#define IMX_USB3_USBSS_DBOFF_OFFSET 0x10014
/* Field DAO - Doorbell Array Offset, RO. Default = implementation dependent. This field defines the offset in Dwords of the Doorbell Array base address from the Base (i.e. the base address of the xHCI Capability register address space). */
#define IMX_USB3_USBSS_DBOFF_DAO_SHIFT 2
#define IMX_USB3_USBSS_DBOFF_DAO_MASK 0xFFFFFFFC
#define IMX_USB3_USBSS_DBOFF_DAO(v) (((v) << 0x2) & 0xFFFFFFFC)

/* IMX_USB3_USBSS_RTSOFF - This register defines the offset of the xHCI Runtime Registers from the Base. */
typedef union IMX_USB3_USBSS_RTSOFF_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :5;
        uint32_t RRSO        :27;                /* Runtime Register Space Offset, RO. Default = implementation dependent. This field defines the 32-byte offset of the xHCI Runtime Registers from the Base. i.e. Runtime Register Base Address = Base + Runtime Register Set Offset. */
    } B;
} IMX_USB3_USBSS_RTSOFF_t;

/* Register RTSOFF - This register defines the offset of the xHCI Runtime Registers from the Base. */
#define IMX_USB3_USBSS_RTSOFF_OFFSET 0x10018
/* Field RRSO - Runtime Register Space Offset, RO. Default = implementation dependent. This field defines the 32-byte offset of the xHCI Runtime Registers from the Base. i.e. Runtime Register Base Address = Base + Runtime Register Set Offset. */
#define IMX_USB3_USBSS_RTSOFF_RRSO_SHIFT 5
#define IMX_USB3_USBSS_RTSOFF_RRSO_MASK 0xFFFFFFE0
#define IMX_USB3_USBSS_RTSOFF_RRSO(v) (((v) << 0x5) & 0xFFFFFFE0)

/* IMX_USB3_USBSS_USBCMD - USB Command Register (USBCMD). */
typedef union IMX_USB3_USBSS_USBCMD_union_t {
    uint32_t R;
    struct {
        uint32_t R_S         :1;                 /* Run/Stop (R/S), RW. Default = '0'. '1' = Run. '0' = Stop. When set to a '1', the xHC proceeds with execution of the schedule. The xHC continues execution as long as this bit is set to a '1'. When this bit is cleared to '0', the xHC completes any current or queued commands or TDs, and any USB transactions associated with them, then halts. Refer to section 5.4.1.1 of xHCI specification for more information on how R/S shall be managed. The xHC shall halt within 16 ms after software clears the Run/Stop bit if the above conditions have been met. The HCHalted (HCH) bit in the USBSTS register indicates when the xHC has finished its pending pipelined transactions and has entered the stopped state. Software shall not write a '1' to this flag unless the xHC is in the Halted state (i.e. HCH in the USBSTS register is '1'). Doing so may yield undefined results. Writing a '0' to this flag when the xHC is in the Running state (i.e. HCH = '0') and any Event Rings are in the Event Ring Full state (refer to section 4.9.4 of xHCI specification) may result in lost events. When this register is exposed by a Virtual Function (VF), this bit only controls the run state of the xHC instance presented by the selected VF. Refer to section 8 of xHCI specification for more information. */
        uint32_t HCRST       :1;                 /* Host Controller Reset (HCRST), RW. Default = '0'. This control bit is used by software to reset the host controller. The effects of this bit on the xHC and the Root Hub registers are similar to a Chip Hardware Reset. When software writes a '1' to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines, etc. to their initial value. Any transaction currently in progress on the USB is immediately terminated. A USB reset shall not be driven on USB2 downstream ports, however a Hot or Warm Reset shall be initiated on USB3 Root Hub downstream ports. PCI Configuration registers are not affected by this reset. All operational registers, including port registers and port state machines are set to their initial values. Software shall reinitialize the host controller as described in Section 4.1 of xHCI specification in order to return the host controller to an operational state. This bit is cleared to '0' by the Host Controller when the reset process is complete. Software cannot terminate the reset process early by writing a '0' to this bit and shall not write any xHC Operational or Runtime registers until while HCRST is '1'. Note, the completion of the xHC reset process is not gated by the Root Hub port reset process. Software shall not set this bit to '1' when the HCHalted (HCH) bit in the USBSTS register is a '0'. Attempting to reset an actively running host controller may result in undefined behavior. When this register is exposed by a Virtual Function (VF), this bit only resets the xHC instance presented by the selected VF. Refer to section 8 of xHCI specification for more information. */
        uint32_t INTE        :1;                 /* Interrupter Enable (INTE), RW. Default = '0'. This bit provides system software with a means of enabling or disabling the host system interrupts generated by Interrupters. When this bit is a '1', then Interrupter host system interrupt generation is allowed, e.g. the xHC shall issue an interrupt at the next interrupt threshold if the host system interrupt mechanism (e.g. MSI, MSIX, etc.) is enabled. The interrupt is acknowledged by a host system interrupt specific mechanism. When this register is exposed by a Virtual Function (VF), this bit only enables the set of Interrupters assigned to the selected VF. Refer to section 7.7.2 of xHCI specification for more information. */
        uint32_t HSEE        :1;                 /* Host System Error Enable (HSEE), RW. Default = '0'. When this bit is a '1', and the HSE bit in the USBSTS register is a '1', the xHC shall assert out-of-band error signaling to the host. The signaling is acknowledged by software clearing the HSE bit. Refer to section 4.10.2.6 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the effect of the assertion of this bit on the Physical Function (PF0) is determined by the VMM. Refer to section 8 of xHCI specification for more information. */
        uint32_t _unused4    :3;                 /* Reserved */
        uint32_t LHCRST      :1;                 /* Light Host Controller Reset (LHCRST), RO or RW. Optional normative. Default = '0'. If the Light HC Reset Capability (LHRC) bit in the HCCPARAMS register is '1', then this flag allows the driver to reset the xHC without affecting the state of the ports. A system software read of this bit as '0' indicates the Light Host Controller Reset has completed and it is safe for software to re-initialize the xHC. A software read of this bit as a '1' indicates that the Light Host Controller Reset has not yet completed. If not implemented, a read of this flag shall always return a '0'. All registers in the Aux Power well shall maintain the values that had been asserted prior to the Light Host Controller Reset. Refer to section 4.23.1 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), this bit only generates a Light Reset to the xHC instance presented by the selected VF, e.g. Disable the VFs device slots and set the associated VF Run bit to Stopped. Refer to section 8 of xHCI specification for more information. */
        uint32_t CSS         :1;                 /* Controller Save State (CSS), RW. Default = '0'. When written by software with '1' and HCHalted (HCH) = '1', then the xHC shall save any internal state that may be restored by a subsequent Restore State operation. When written by software with '1' and HCHalted (HCH) = '0', or written with '0', no Save State operation shall be performed. This flag always returns '0' when read. Refer to the Save State Status (SSS) flag in the USBSTS register for information on Save State completion. Refer to section 4.23.2 of xHCI specification for more information on xHC Save/Restore operation. Note that undefined behavior may occur if a Save State operation is initiated while Restore State Status (RSS) ='1'. When this register is exposed by a Virtual Function (VF), this bit only controls saving the state of the xHC instance presented by the selected VF. Refer to section 8 of xHCI specifications for more information. */
        uint32_t CRS         :1;                 /* Controller Restore State (CRS), RW. Default = '0'. When set to '1', and HCHalted (HCH) = '1', then the xHC shall perform a Restore State operation and restore its internal state. When set to '1' and Run/Stop (R/S) = '1' or HCHalted (HCH) = '0', or when cleared to '0', no Restore State operation shall be performed. This flag always returns '0' when read. Refer to the Restore State Status (RSS) flag in the USBSTS register for information on Restore State completion. Refer to section 4.23.2 of xHCI specification for more information. Note that undefined behavior may occur if a Restore State operation is initiated while Save State Status (SSS) = '1'. When this register is exposed by a Virtual Function (VF), this bit only controls restoring the state of the xHC instance presented by the selected VF. Refer to section 8 of xHCI specification for more information. */
        uint32_t EWE         :1;                 /* Enable Wrap Event (EWE), RW. Default = '0'. When set to '1', the xHC shall generate a MFINDEX Wrap Event every time the MFINDEX register transitions from 03FFFh to 0. When cleared to '0' no MFINDEX Wrap Events are generated. Refer to section 4.14.2 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the generation of MFINDEX Wrap Events to VFs shall be emulated by the VMM. */
        uint32_t EU3S        :1;                 /* Enable U3 MFINDEX Stop (EU3S), RW. Default = '0'. When set to '1', the xHC may stop the MFINDEX counting action if all Root Hub ports are in the U3, Disconnected, Disabled, or Powered-off state. When cleared to '0' the xHC may stop the MFINDEX counting action if all Root Hub ports are in the Disconnected, Disabled, Training, or Powered-off state. Refer to section 4.14.2 of xHCI specification for more information. */
        uint32_t _unused12   :20;                /* Reserved */
    } B;
} IMX_USB3_USBSS_USBCMD_t;

/* Register USBCMD - USB Command Register (USBCMD). */
#define IMX_USB3_USBSS_USBCMD_OFFSET 0x10080
/* Field R_S - Run/Stop (R/S), RW. Default = '0'. '1' = Run. '0' = Stop. When set to a '1', the xHC proceeds with execution of the schedule. The xHC continues execution as long as this bit is set to a '1'. When this bit is cleared to '0', the xHC completes any current or queued commands or TDs, and any USB transactions associated with them, then halts. Refer to section 5.4.1.1 of xHCI specification for more information on how R/S shall be managed. The xHC shall halt within 16 ms after software clears the Run/Stop bit if the above conditions have been met. The HCHalted (HCH) bit in the USBSTS register indicates when the xHC has finished its pending pipelined transactions and has entered the stopped state. Software shall not write a '1' to this flag unless the xHC is in the Halted state (i.e. HCH in the USBSTS register is '1'). Doing so may yield undefined results. Writing a '0' to this flag when the xHC is in the Running state (i.e. HCH = '0') and any Event Rings are in the Event Ring Full state (refer to section 4.9.4 of xHCI specification) may result in lost events. When this register is exposed by a Virtual Function (VF), this bit only controls the run state of the xHC instance presented by the selected VF. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBCMD_R_S_SHIFT 0
#define IMX_USB3_USBSS_USBCMD_R_S_MASK 0x1
#define IMX_USB3_USBSS_USBCMD_R_S(v) (((v) << 0) & 0x1)
/* Field HCRST - Host Controller Reset (HCRST), RW. Default = '0'. This control bit is used by software to reset the host controller. The effects of this bit on the xHC and the Root Hub registers are similar to a Chip Hardware Reset. When software writes a '1' to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines, etc. to their initial value. Any transaction currently in progress on the USB is immediately terminated. A USB reset shall not be driven on USB2 downstream ports, however a Hot or Warm Reset shall be initiated on USB3 Root Hub downstream ports. PCI Configuration registers are not affected by this reset. All operational registers, including port registers and port state machines are set to their initial values. Software shall reinitialize the host controller as described in Section 4.1 of xHCI specification in order to return the host controller to an operational state. This bit is cleared to '0' by the Host Controller when the reset process is complete. Software cannot terminate the reset process early by writing a '0' to this bit and shall not write any xHC Operational or Runtime registers until while HCRST is '1'. Note, the completion of the xHC reset process is not gated by the Root Hub port reset process. Software shall not set this bit to '1' when the HCHalted (HCH) bit in the USBSTS register is a '0'. Attempting to reset an actively running host controller may result in undefined behavior. When this register is exposed by a Virtual Function (VF), this bit only resets the xHC instance presented by the selected VF. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBCMD_HCRST_SHIFT 1
#define IMX_USB3_USBSS_USBCMD_HCRST_MASK 0x2
#define IMX_USB3_USBSS_USBCMD_HCRST(v) (((v) << 0x1) & 0x2)
/* Field INTE - Interrupter Enable (INTE), RW. Default = '0'. This bit provides system software with a means of enabling or disabling the host system interrupts generated by Interrupters. When this bit is a '1', then Interrupter host system interrupt generation is allowed, e.g. the xHC shall issue an interrupt at the next interrupt threshold if the host system interrupt mechanism (e.g. MSI, MSIX, etc.) is enabled. The interrupt is acknowledged by a host system interrupt specific mechanism. When this register is exposed by a Virtual Function (VF), this bit only enables the set of Interrupters assigned to the selected VF. Refer to section 7.7.2 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBCMD_INTE_SHIFT 2
#define IMX_USB3_USBSS_USBCMD_INTE_MASK 0x4
#define IMX_USB3_USBSS_USBCMD_INTE(v) (((v) << 0x2) & 0x4)
/* Field HSEE - Host System Error Enable (HSEE), RW. Default = '0'. When this bit is a '1', and the HSE bit in the USBSTS register is a '1', the xHC shall assert out-of-band error signaling to the host. The signaling is acknowledged by software clearing the HSE bit. Refer to section 4.10.2.6 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the effect of the assertion of this bit on the Physical Function (PF0) is determined by the VMM. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBCMD_HSEE_SHIFT 3
#define IMX_USB3_USBSS_USBCMD_HSEE_MASK 0x8
#define IMX_USB3_USBSS_USBCMD_HSEE(v) (((v) << 0x3) & 0x8)
/* Field LHCRST - Light Host Controller Reset (LHCRST), RO or RW. Optional normative. Default = '0'. If the Light HC Reset Capability (LHRC) bit in the HCCPARAMS register is '1', then this flag allows the driver to reset the xHC without affecting the state of the ports. A system software read of this bit as '0' indicates the Light Host Controller Reset has completed and it is safe for software to re-initialize the xHC. A software read of this bit as a '1' indicates that the Light Host Controller Reset has not yet completed. If not implemented, a read of this flag shall always return a '0'. All registers in the Aux Power well shall maintain the values that had been asserted prior to the Light Host Controller Reset. Refer to section 4.23.1 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), this bit only generates a Light Reset to the xHC instance presented by the selected VF, e.g. Disable the VFs device slots and set the associated VF Run bit to Stopped. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBCMD_LHCRST_SHIFT 7
#define IMX_USB3_USBSS_USBCMD_LHCRST_MASK 0x80
#define IMX_USB3_USBSS_USBCMD_LHCRST(v) (((v) << 0x7) & 0x80)
/* Field CSS - Controller Save State (CSS), RW. Default = '0'. When written by software with '1' and HCHalted (HCH) = '1', then the xHC shall save any internal state that may be restored by a subsequent Restore State operation. When written by software with '1' and HCHalted (HCH) = '0', or written with '0', no Save State operation shall be performed. This flag always returns '0' when read. Refer to the Save State Status (SSS) flag in the USBSTS register for information on Save State completion. Refer to section 4.23.2 of xHCI specification for more information on xHC Save/Restore operation. Note that undefined behavior may occur if a Save State operation is initiated while Restore State Status (RSS) ='1'. When this register is exposed by a Virtual Function (VF), this bit only controls saving the state of the xHC instance presented by the selected VF. Refer to section 8 of xHCI specifications for more information. */
#define IMX_USB3_USBSS_USBCMD_CSS_SHIFT 8
#define IMX_USB3_USBSS_USBCMD_CSS_MASK 0x100
#define IMX_USB3_USBSS_USBCMD_CSS(v) (((v) << 0x8) & 0x100)
/* Field CRS - Controller Restore State (CRS), RW. Default = '0'. When set to '1', and HCHalted (HCH) = '1', then the xHC shall perform a Restore State operation and restore its internal state. When set to '1' and Run/Stop (R/S) = '1' or HCHalted (HCH) = '0', or when cleared to '0', no Restore State operation shall be performed. This flag always returns '0' when read. Refer to the Restore State Status (RSS) flag in the USBSTS register for information on Restore State completion. Refer to section 4.23.2 of xHCI specification for more information. Note that undefined behavior may occur if a Restore State operation is initiated while Save State Status (SSS) = '1'. When this register is exposed by a Virtual Function (VF), this bit only controls restoring the state of the xHC instance presented by the selected VF. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBCMD_CRS_SHIFT 9
#define IMX_USB3_USBSS_USBCMD_CRS_MASK 0x200
#define IMX_USB3_USBSS_USBCMD_CRS(v) (((v) << 0x9) & 0x200)
/* Field EWE - Enable Wrap Event (EWE), RW. Default = '0'. When set to '1', the xHC shall generate a MFINDEX Wrap Event every time the MFINDEX register transitions from 03FFFh to 0. When cleared to '0' no MFINDEX Wrap Events are generated. Refer to section 4.14.2 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the generation of MFINDEX Wrap Events to VFs shall be emulated by the VMM. */
#define IMX_USB3_USBSS_USBCMD_EWE_SHIFT 10
#define IMX_USB3_USBSS_USBCMD_EWE_MASK 0x400
#define IMX_USB3_USBSS_USBCMD_EWE(v) (((v) << 0xA) & 0x400)
/* Field EU3S - Enable U3 MFINDEX Stop (EU3S), RW. Default = '0'. When set to '1', the xHC may stop the MFINDEX counting action if all Root Hub ports are in the U3, Disconnected, Disabled, or Powered-off state. When cleared to '0' the xHC may stop the MFINDEX counting action if all Root Hub ports are in the Disconnected, Disabled, Training, or Powered-off state. Refer to section 4.14.2 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBCMD_EU3S_SHIFT 11
#define IMX_USB3_USBSS_USBCMD_EU3S_MASK 0x800
#define IMX_USB3_USBSS_USBCMD_EU3S(v) (((v) << 0xB) & 0x800)

/* IMX_USB3_USBSS_USBSTS - USB Status Register (USBSTS). */
typedef union IMX_USB3_USBSS_USBSTS_union_t {
    uint32_t R;
    struct {
        uint32_t HCH         :1;                 /* HCHalted (HCH), RO. Default = '1'. This bit is a '0' whenever the Run/Stop (R/S) bit is a '1'. The xHC sets this bit to '1' after it has stopped executing as a result of the Run/Stop (R/S) bit being cleared to '0', either by software or by the xHC hardware (e.g. internal error). If this bit is '1', then SOFs, microSOFs, or Isochronous Timestamp Packets (ITP) shall not be generated by the xHC, and any received Transaction Packet shall be dropped. When this register is exposed by a Virtual Function (VF), this bit only reflects the Halted state of the xHC instance presented by the selected VF. Refer to section 8 of xHCI specification for more information. */
        uint32_t _unused1    :1;                 /* Reserved */
        uint32_t HSE         :1;                 /* Host System Error (HSE), RW1C. Default = '0'. The xHC sets this bit to '1' when a serious error is detected, either internal to the xHC or during a host system access involving the xHC module. (In a PCI system, conditions that set this bit to 1 include PCI Parity error, PCI Master Abort, and PCI Target Abort.) When this error occurs, the xHC clears the Run/Stop (R/S) bit in the USBCMD register to prevent further execution of the scheduled TDs. If the HSEE bit in the USBCMD register is a '1', the xHC shall also assert out-of-band error signaling to the host. Refer to section 4.10.2.6 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the assertion of this bit affects all VFs and reflects the Host System Error state of the Physical Function (PF0). Refer to section 8 of xHCI specification for more information. */
        uint32_t EINT        :1;                 /* Event Interrupt (EINT), RW1C. Default = '0'. The xHC sets this bit to '1' when the Interrupt Pending (IP) bit of any Interrupter transitions from '0' to '1'. Refer to section 7.1.2 of xHCI specification for use. Software that uses EINT shall clear it prior to clearing any IP flags. A race condition may occur if software clears the IP flags then clears the EINT flag, and between the operations another IP '0' to '1' transition occurs. In this case the new IP transition shall be lost. When this register is exposed by a Virtual Function (VF), this bit is the logical 'OR' of the IP bits for the Interrupters assigned to the selected VF. And it shall be cleared to '0' when all associated interrupter IP bits are cleared, i.e. all the VFs Interrupter Event Ring(s) are empty. Refer to section 8 of xHCI specification for more information */
        uint32_t PCD         :1;                 /* Port Change Detect (PCD), RW1C. Default = '0'. The xHC sets this bit to a '1' when any port has a change bit transition from a '0' to a '1'. This bit is allowed to be maintained in the Aux Power well. Alternatively, it is also acceptable that on a D3 to D0 transition of the xHC, this bit is loaded with the OR of all of the PORTSC change bits. Refer to section 4.19.3 of xHCI specification. This bit provides system software an efficient means of determining if there has been Root Hub port activity. Refer to section 4.15.2.3 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the VMM determines the state of this bit as a function of the Root Hub Ports associated with the Device Slots assigned to the selected VF. Refer to section 8 of xHCI specification for more information. */
        uint32_t _unused5    :3;                 /* Reserved */
        uint32_t SSS         :1;                 /* Save State Status (SSS), RO. Default = '0'. When the Controller Save State (CSS) flag in the USBCMD register is written with '1' this bit shall be set to '1' and remain '1' while the xHC saves its internal state. When the Save State operation is complete, this bit shall be cleared to '0'. Refer to section 4.23.2 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the VMM determines the state of this bit as a function of the saving the state for the selected VF. Refer to section 8 of xHCI specification for more information. */
        uint32_t RSS         :1;                 /* Restore State Status (RSS), RO. Default = '0'. When the Controller Restore State (CRS) flag in the USBCMD register is written with '1' this bit shall be set to '1' and remain '1' while the xHC restores its internal state. When the Restore State operation is complete, this bit shall be cleared to '0'. Refer to section 4.23.2 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the VMM determines the state of this bit as a function of the restoring the state for the selected VF. Refer to section 8 of xHCI specification for more information. */
        uint32_t SRE         :1;                 /* Save/Restore Error (SRE), RW1C. Default = '0'. If an error occurs during a Save or Restore operation this bit shall be set to '1'. This bit shall be cleared to '0' when a Save or Restore operation is initiated or when written with '1'. Refer to section 4.23.2 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the VMM determines the state of this bit as a function of the Save/Restore completion status for the selected VF. Refer to section 8 of xHCI specification for more information. */
        uint32_t CNR         :1;                 /* Controller Not Ready (CNR), RO. Default = '1'. '0' = Ready and '1' = Not Ready. When this bit is '1', software shall not read or write any register of the xHC, other than those explicitly listed in the Design Specification section titled Register Accessibility. This flag is set by the xHC after a Chip Hardware Reset and cleared when the xHC is ready to begin accepting register reads or writes to all registers. This flag shall remain cleared ('0') until the next Chip Hardware Reset. */
        uint32_t HCE         :1;                 /* Host Controller Error (HCE), RO. Default = '0'. '0' = No internal xHC error conditions exist and '1' = Internal xHC error condition. This flag shall be set to indicate that an internal error condition has been detected which requires software to reset and reinitialize the xHC. Refer to section 4.24.1 of xHCI specification for more information. */
        uint32_t _unused13   :19;                /* Reserved */
    } B;
} IMX_USB3_USBSS_USBSTS_t;

/* Register USBSTS - USB Status Register (USBSTS). */
#define IMX_USB3_USBSS_USBSTS_OFFSET 0x10084
/* Field HCH - HCHalted (HCH), RO. Default = '1'. This bit is a '0' whenever the Run/Stop (R/S) bit is a '1'. The xHC sets this bit to '1' after it has stopped executing as a result of the Run/Stop (R/S) bit being cleared to '0', either by software or by the xHC hardware (e.g. internal error). If this bit is '1', then SOFs, microSOFs, or Isochronous Timestamp Packets (ITP) shall not be generated by the xHC, and any received Transaction Packet shall be dropped. When this register is exposed by a Virtual Function (VF), this bit only reflects the Halted state of the xHC instance presented by the selected VF. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBSTS_HCH_SHIFT 0
#define IMX_USB3_USBSS_USBSTS_HCH_MASK 0x1
#define IMX_USB3_USBSS_USBSTS_HCH(v) (((v) << 0) & 0x1)
/* Field HSE - Host System Error (HSE), RW1C. Default = '0'. The xHC sets this bit to '1' when a serious error is detected, either internal to the xHC or during a host system access involving the xHC module. (In a PCI system, conditions that set this bit to 1 include PCI Parity error, PCI Master Abort, and PCI Target Abort.) When this error occurs, the xHC clears the Run/Stop (R/S) bit in the USBCMD register to prevent further execution of the scheduled TDs. If the HSEE bit in the USBCMD register is a '1', the xHC shall also assert out-of-band error signaling to the host. Refer to section 4.10.2.6 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the assertion of this bit affects all VFs and reflects the Host System Error state of the Physical Function (PF0). Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBSTS_HSE_SHIFT 2
#define IMX_USB3_USBSS_USBSTS_HSE_MASK 0x4
#define IMX_USB3_USBSS_USBSTS_HSE(v) (((v) << 0x2) & 0x4)
/* Field EINT - Event Interrupt (EINT), RW1C. Default = '0'. The xHC sets this bit to '1' when the Interrupt Pending (IP) bit of any Interrupter transitions from '0' to '1'. Refer to section 7.1.2 of xHCI specification for use. Software that uses EINT shall clear it prior to clearing any IP flags. A race condition may occur if software clears the IP flags then clears the EINT flag, and between the operations another IP '0' to '1' transition occurs. In this case the new IP transition shall be lost. When this register is exposed by a Virtual Function (VF), this bit is the logical 'OR' of the IP bits for the Interrupters assigned to the selected VF. And it shall be cleared to '0' when all associated interrupter IP bits are cleared, i.e. all the VFs Interrupter Event Ring(s) are empty. Refer to section 8 of xHCI specification for more information */
#define IMX_USB3_USBSS_USBSTS_EINT_SHIFT 3
#define IMX_USB3_USBSS_USBSTS_EINT_MASK 0x8
#define IMX_USB3_USBSS_USBSTS_EINT(v) (((v) << 0x3) & 0x8)
/* Field PCD - Port Change Detect (PCD), RW1C. Default = '0'. The xHC sets this bit to a '1' when any port has a change bit transition from a '0' to a '1'. This bit is allowed to be maintained in the Aux Power well. Alternatively, it is also acceptable that on a D3 to D0 transition of the xHC, this bit is loaded with the OR of all of the PORTSC change bits. Refer to section 4.19.3 of xHCI specification. This bit provides system software an efficient means of determining if there has been Root Hub port activity. Refer to section 4.15.2.3 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the VMM determines the state of this bit as a function of the Root Hub Ports associated with the Device Slots assigned to the selected VF. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBSTS_PCD_SHIFT 4
#define IMX_USB3_USBSS_USBSTS_PCD_MASK 0x10
#define IMX_USB3_USBSS_USBSTS_PCD(v) (((v) << 0x4) & 0x10)
/* Field SSS - Save State Status (SSS), RO. Default = '0'. When the Controller Save State (CSS) flag in the USBCMD register is written with '1' this bit shall be set to '1' and remain '1' while the xHC saves its internal state. When the Save State operation is complete, this bit shall be cleared to '0'. Refer to section 4.23.2 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the VMM determines the state of this bit as a function of the saving the state for the selected VF. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBSTS_SSS_SHIFT 8
#define IMX_USB3_USBSS_USBSTS_SSS_MASK 0x100
#define IMX_USB3_USBSS_USBSTS_SSS(v) (((v) << 0x8) & 0x100)
/* Field RSS - Restore State Status (RSS), RO. Default = '0'. When the Controller Restore State (CRS) flag in the USBCMD register is written with '1' this bit shall be set to '1' and remain '1' while the xHC restores its internal state. When the Restore State operation is complete, this bit shall be cleared to '0'. Refer to section 4.23.2 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the VMM determines the state of this bit as a function of the restoring the state for the selected VF. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBSTS_RSS_SHIFT 9
#define IMX_USB3_USBSS_USBSTS_RSS_MASK 0x200
#define IMX_USB3_USBSS_USBSTS_RSS(v) (((v) << 0x9) & 0x200)
/* Field SRE - Save/Restore Error (SRE), RW1C. Default = '0'. If an error occurs during a Save or Restore operation this bit shall be set to '1'. This bit shall be cleared to '0' when a Save or Restore operation is initiated or when written with '1'. Refer to section 4.23.2 of xHCI specification for more information. When this register is exposed by a Virtual Function (VF), the VMM determines the state of this bit as a function of the Save/Restore completion status for the selected VF. Refer to section 8 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBSTS_SRE_SHIFT 10
#define IMX_USB3_USBSS_USBSTS_SRE_MASK 0x400
#define IMX_USB3_USBSS_USBSTS_SRE(v) (((v) << 0xA) & 0x400)
/* Field CNR - Controller Not Ready (CNR), RO. Default = '1'. '0' = Ready and '1' = Not Ready. When this bit is '1', software shall not read or write any register of the xHC, other than those explicitly listed in the Design Specification section titled Register Accessibility. This flag is set by the xHC after a Chip Hardware Reset and cleared when the xHC is ready to begin accepting register reads or writes to all registers. This flag shall remain cleared ('0') until the next Chip Hardware Reset. */
#define IMX_USB3_USBSS_USBSTS_CNR_SHIFT 11
#define IMX_USB3_USBSS_USBSTS_CNR_MASK 0x800
#define IMX_USB3_USBSS_USBSTS_CNR(v) (((v) << 0xB) & 0x800)
/* Field HCE - Host Controller Error (HCE), RO. Default = '0'. '0' = No internal xHC error conditions exist and '1' = Internal xHC error condition. This flag shall be set to indicate that an internal error condition has been detected which requires software to reset and reinitialize the xHC. Refer to section 4.24.1 of xHCI specification for more information. */
#define IMX_USB3_USBSS_USBSTS_HCE_SHIFT 12
#define IMX_USB3_USBSS_USBSTS_HCE_MASK 0x1000
#define IMX_USB3_USBSS_USBSTS_HCE(v) (((v) << 0xC) & 0x1000)

/* IMX_USB3_USBSS_PAGESIZE - Page Size Register (PAGESIZE). */
typedef union IMX_USB3_USBSS_PAGESIZE_union_t {
    uint32_t R;
    struct {
        uint32_t PAGESIZE    :16;                /* Page Size, RO. Default = Implementation defined. This field defines the page size supported by the xHC implementation. This xHC supports a page size of 2^(n+12) if bit n is Set. For example, if bit 0 is Set, the xHC supports 4k byte page sizes. For a Virtual Function, this register reflects the page size selected in the System Page Size field of the SR-IOV Extended Capability structure. For the Physical Function 0, this register reflects the implementation dependent default xHC page size. Various xHC resources reference PAGESIZE to describe their minimum alignment requirements. The maximum possible page size is 128M. */
        uint32_t _unused16   :16;
    } B;
} IMX_USB3_USBSS_PAGESIZE_t;

/* Register PAGESIZE - Page Size Register (PAGESIZE). */
#define IMX_USB3_USBSS_PAGESIZE_OFFSET 0x10088
/* Field PAGESIZE - Page Size, RO. Default = Implementation defined. This field defines the page size supported by the xHC implementation. This xHC supports a page size of 2^(n+12) if bit n is Set. For example, if bit 0 is Set, the xHC supports 4k byte page sizes. For a Virtual Function, this register reflects the page size selected in the System Page Size field of the SR-IOV Extended Capability structure. For the Physical Function 0, this register reflects the implementation dependent default xHC page size. Various xHC resources reference PAGESIZE to describe their minimum alignment requirements. The maximum possible page size is 128M. */
#define IMX_USB3_USBSS_PAGESIZE_PAGESIZE_SHIFT 0
#define IMX_USB3_USBSS_PAGESIZE_PAGESIZE_MASK 0xFFFF
#define IMX_USB3_USBSS_PAGESIZE_PAGESIZE(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_DNCTRL - Device Notification Control Register (DNCTRL). */
typedef union IMX_USB3_USBSS_DNCTRL_union_t {
    uint32_t R;
    struct {
        uint32_t N0          :1;                 /* Notification Enable flag 0 */
        uint32_t N1          :1;                 /* Notification Enable flag 1 */
        uint32_t N2          :1;                 /* Notification Enable flag 2. LATENCY_TOLERANCE_MESSAGE. */
        uint32_t N3          :1;                 /* Notification Enable flag 3. BUS_INTERVAL_ADJUSTMENT_MESSAGE. */
        uint32_t N4          :1;                 /* Notification Enable flag 4 */
        uint32_t N5          :1;                 /* Notification Enable flag 5 */
        uint32_t N6          :1;                 /* Notification Enable flag 6 */
        uint32_t N7          :1;                 /* Notification Enable flag 7 */
        uint32_t N8          :1;                 /* Notification Enable flag 8 */
        uint32_t N9          :1;                 /* Notification Enable flag 9 */
        uint32_t N10         :1;                 /* Notification Enable flag 10 */
        uint32_t N11         :1;                 /* Notification Enable flag 11 */
        uint32_t N12         :1;                 /* Notification Enable flag 12 */
        uint32_t N13         :1;                 /* Notification Enable flag 13 */
        uint32_t N14         :1;                 /* Notification Enable flag 14 */
        uint32_t N15         :1;                 /* Notification Enable flag 15 */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_DNCTRL_t;

/* Register DNCTRL - Device Notification Control Register (DNCTRL). */
#define IMX_USB3_USBSS_DNCTRL_OFFSET 0x10094
/* Field N0 - Notification Enable flag 0 */
#define IMX_USB3_USBSS_DNCTRL_N0_SHIFT 0
#define IMX_USB3_USBSS_DNCTRL_N0_MASK 0x1
#define IMX_USB3_USBSS_DNCTRL_N0(v) (((v) << 0) & 0x1)
/* Field N1 - Notification Enable flag 1 */
#define IMX_USB3_USBSS_DNCTRL_N1_SHIFT 1
#define IMX_USB3_USBSS_DNCTRL_N1_MASK 0x2
#define IMX_USB3_USBSS_DNCTRL_N1(v) (((v) << 0x1) & 0x2)
/* Field N2 - Notification Enable flag 2. LATENCY_TOLERANCE_MESSAGE. */
#define IMX_USB3_USBSS_DNCTRL_N2_SHIFT 2
#define IMX_USB3_USBSS_DNCTRL_N2_MASK 0x4
#define IMX_USB3_USBSS_DNCTRL_N2(v) (((v) << 0x2) & 0x4)
/* Field N3 - Notification Enable flag 3. BUS_INTERVAL_ADJUSTMENT_MESSAGE. */
#define IMX_USB3_USBSS_DNCTRL_N3_SHIFT 3
#define IMX_USB3_USBSS_DNCTRL_N3_MASK 0x8
#define IMX_USB3_USBSS_DNCTRL_N3(v) (((v) << 0x3) & 0x8)
/* Field N4 - Notification Enable flag 4 */
#define IMX_USB3_USBSS_DNCTRL_N4_SHIFT 4
#define IMX_USB3_USBSS_DNCTRL_N4_MASK 0x10
#define IMX_USB3_USBSS_DNCTRL_N4(v) (((v) << 0x4) & 0x10)
/* Field N5 - Notification Enable flag 5 */
#define IMX_USB3_USBSS_DNCTRL_N5_SHIFT 5
#define IMX_USB3_USBSS_DNCTRL_N5_MASK 0x20
#define IMX_USB3_USBSS_DNCTRL_N5(v) (((v) << 0x5) & 0x20)
/* Field N6 - Notification Enable flag 6 */
#define IMX_USB3_USBSS_DNCTRL_N6_SHIFT 6
#define IMX_USB3_USBSS_DNCTRL_N6_MASK 0x40
#define IMX_USB3_USBSS_DNCTRL_N6(v) (((v) << 0x6) & 0x40)
/* Field N7 - Notification Enable flag 7 */
#define IMX_USB3_USBSS_DNCTRL_N7_SHIFT 7
#define IMX_USB3_USBSS_DNCTRL_N7_MASK 0x80
#define IMX_USB3_USBSS_DNCTRL_N7(v) (((v) << 0x7) & 0x80)
/* Field N8 - Notification Enable flag 8 */
#define IMX_USB3_USBSS_DNCTRL_N8_SHIFT 8
#define IMX_USB3_USBSS_DNCTRL_N8_MASK 0x100
#define IMX_USB3_USBSS_DNCTRL_N8(v) (((v) << 0x8) & 0x100)
/* Field N9 - Notification Enable flag 9 */
#define IMX_USB3_USBSS_DNCTRL_N9_SHIFT 9
#define IMX_USB3_USBSS_DNCTRL_N9_MASK 0x200
#define IMX_USB3_USBSS_DNCTRL_N9(v) (((v) << 0x9) & 0x200)
/* Field N10 - Notification Enable flag 10 */
#define IMX_USB3_USBSS_DNCTRL_N10_SHIFT 10
#define IMX_USB3_USBSS_DNCTRL_N10_MASK 0x400
#define IMX_USB3_USBSS_DNCTRL_N10(v) (((v) << 0xA) & 0x400)
/* Field N11 - Notification Enable flag 11 */
#define IMX_USB3_USBSS_DNCTRL_N11_SHIFT 11
#define IMX_USB3_USBSS_DNCTRL_N11_MASK 0x800
#define IMX_USB3_USBSS_DNCTRL_N11(v) (((v) << 0xB) & 0x800)
/* Field N12 - Notification Enable flag 12 */
#define IMX_USB3_USBSS_DNCTRL_N12_SHIFT 12
#define IMX_USB3_USBSS_DNCTRL_N12_MASK 0x1000
#define IMX_USB3_USBSS_DNCTRL_N12(v) (((v) << 0xC) & 0x1000)
/* Field N13 - Notification Enable flag 13 */
#define IMX_USB3_USBSS_DNCTRL_N13_SHIFT 13
#define IMX_USB3_USBSS_DNCTRL_N13_MASK 0x2000
#define IMX_USB3_USBSS_DNCTRL_N13(v) (((v) << 0xD) & 0x2000)
/* Field N14 - Notification Enable flag 14 */
#define IMX_USB3_USBSS_DNCTRL_N14_SHIFT 14
#define IMX_USB3_USBSS_DNCTRL_N14_MASK 0x4000
#define IMX_USB3_USBSS_DNCTRL_N14(v) (((v) << 0xE) & 0x4000)
/* Field N15 - Notification Enable flag 15 */
#define IMX_USB3_USBSS_DNCTRL_N15_SHIFT 15
#define IMX_USB3_USBSS_DNCTRL_N15_MASK 0x8000
#define IMX_USB3_USBSS_DNCTRL_N15(v) (((v) << 0xF) & 0x8000)

/* IMX_USB3_USBSS_CRCR_LO - Command Ring Control Register Low (CRCR_L). */
typedef union IMX_USB3_USBSS_CRCR_LO_union_t {
    uint32_t R;
    struct {
        uint32_t RCS         :1;                 /* Ring Cycle State (RCS), RW. This bit identifies the value of the xHC Consumer Cycle State (CCS) flag for the TRB referenced by the Command Ring Pointer. Refer to section 4.9.3 of xHCI specification for more information. Writes to this flag are ignored if Command Ring Running (CRR) is '1'. If the CRCR is written while the Command Ring is stopped (CRR = '0'), then the value of this flag shall be used to fetch the first Command TRB the next time the Host Controller Doorbell register is written with the DB Reason field set to Host Controller Command. If the CRCR is not written while the Command Ring is stopped (CRR = '0'), then the Command Ring shall begin fetching Command TRBs using the current value of the internal Command Ring CCS flag. Reading this flag always returns '0'. */
        uint32_t CS          :1;                 /* Command Stop (CS), RW1S. Default = '0'. Writing a '1' to this bit shall stop the operation of the Command Ring after the completion of the currently executing command, and generate a Command Completion Event with the Completion Code set to Command Ring Stopped and the Command TRB Pointer set to the current value of the Command Ring Dequeue Pointer. Refer to section 4.6.1.1 of xHCI specification for more information on stopping a command. The next write to the Host Controller Doorbell with DB Reason field set to Host Controller Command shall restart the Command Ring operation. Writes to this flag are ignored by the xHC if Command Ring Running (CRR) = '0'. Reading this bit shall always return '0'. */
        uint32_t CA          :1;                 /* Command Abort (CA), RW1S. Default = '0'. Writing a '1' to this bit shall immediately terminate the currently executing command, stop the Command Ring, and generate a Command Completion Event with the Completion Code set to Command Ring Stopped. Refer to section 4.6.1.2 of xHCI specification for more information on aborting a command. The next write to the Host Controller Doorbell with DB Reason field set to Host Controller Command shall restart the Command Ring operation. Writes to this flag are ignored by the xHC if Command Ring Running (CRR) = '0'. Reading this bit always returns '0'. */
        uint32_t CRR         :1;                 /* Command Ring Running (CRR), RO. Default = '0'. This flag is set to '1' if the Run/Stop (R/S) bit is '1' and the Host Controller Doorbell register is written with the DB Reason field set to Host Controller Command. It is cleared to '0' when the Command Ring is stopped after writing a '1' to the Command Stop (CS) or Command Abort (CA) flags, or if the R/S bit is cleared to '0'. */
        uint32_t _unused4    :2;                 /* Reserved */
        uint32_t CRPTR_L     :26;                /* Command Ring Pointer Low, RW. Default = 0. This field defines low order bits of the initial value of the 64-bit Command Ring Dequeue Pointer. Writes to this field are ignored when Command Ring Running (CRR) = '1'. If the CRCR is written while the Command Ring is stopped (CCR = '0'), the value of this field shall be used to fetch the first Command TRB the next time the Host Controller Doorbell register is written with the DB Reason field set to Host Controller Command. If the CRCR is not written while the Command Ring is stopped (CCR = '0') then the Command Ring shall begin fetching Command TRBs at the current value of the internal xHC Command Ring Dequeue Pointer. Reading this field always returns zero. */
    } B;
} IMX_USB3_USBSS_CRCR_LO_t;

/* Register CRCR_LO - Command Ring Control Register Low (CRCR_L). */
#define IMX_USB3_USBSS_CRCR_LO_OFFSET 0x10098
/* Field RCS - Ring Cycle State (RCS), RW. This bit identifies the value of the xHC Consumer Cycle State (CCS) flag for the TRB referenced by the Command Ring Pointer. Refer to section 4.9.3 of xHCI specification for more information. Writes to this flag are ignored if Command Ring Running (CRR) is '1'. If the CRCR is written while the Command Ring is stopped (CRR = '0'), then the value of this flag shall be used to fetch the first Command TRB the next time the Host Controller Doorbell register is written with the DB Reason field set to Host Controller Command. If the CRCR is not written while the Command Ring is stopped (CRR = '0'), then the Command Ring shall begin fetching Command TRBs using the current value of the internal Command Ring CCS flag. Reading this flag always returns '0'. */
#define IMX_USB3_USBSS_CRCR_LO_RCS_SHIFT 0
#define IMX_USB3_USBSS_CRCR_LO_RCS_MASK 0x1
#define IMX_USB3_USBSS_CRCR_LO_RCS(v) (((v) << 0) & 0x1)
/* Field CS - Command Stop (CS), RW1S. Default = '0'. Writing a '1' to this bit shall stop the operation of the Command Ring after the completion of the currently executing command, and generate a Command Completion Event with the Completion Code set to Command Ring Stopped and the Command TRB Pointer set to the current value of the Command Ring Dequeue Pointer. Refer to section 4.6.1.1 of xHCI specification for more information on stopping a command. The next write to the Host Controller Doorbell with DB Reason field set to Host Controller Command shall restart the Command Ring operation. Writes to this flag are ignored by the xHC if Command Ring Running (CRR) = '0'. Reading this bit shall always return '0'. */
#define IMX_USB3_USBSS_CRCR_LO_CS_SHIFT 1
#define IMX_USB3_USBSS_CRCR_LO_CS_MASK 0x2
#define IMX_USB3_USBSS_CRCR_LO_CS(v) (((v) << 0x1) & 0x2)
/* Field CA - Command Abort (CA), RW1S. Default = '0'. Writing a '1' to this bit shall immediately terminate the currently executing command, stop the Command Ring, and generate a Command Completion Event with the Completion Code set to Command Ring Stopped. Refer to section 4.6.1.2 of xHCI specification for more information on aborting a command. The next write to the Host Controller Doorbell with DB Reason field set to Host Controller Command shall restart the Command Ring operation. Writes to this flag are ignored by the xHC if Command Ring Running (CRR) = '0'. Reading this bit always returns '0'. */
#define IMX_USB3_USBSS_CRCR_LO_CA_SHIFT 2
#define IMX_USB3_USBSS_CRCR_LO_CA_MASK 0x4
#define IMX_USB3_USBSS_CRCR_LO_CA(v) (((v) << 0x2) & 0x4)
/* Field CRR - Command Ring Running (CRR), RO. Default = '0'. This flag is set to '1' if the Run/Stop (R/S) bit is '1' and the Host Controller Doorbell register is written with the DB Reason field set to Host Controller Command. It is cleared to '0' when the Command Ring is stopped after writing a '1' to the Command Stop (CS) or Command Abort (CA) flags, or if the R/S bit is cleared to '0'. */
#define IMX_USB3_USBSS_CRCR_LO_CRR_SHIFT 3
#define IMX_USB3_USBSS_CRCR_LO_CRR_MASK 0x8
#define IMX_USB3_USBSS_CRCR_LO_CRR(v) (((v) << 0x3) & 0x8)
/* Field CRPTR_L - Command Ring Pointer Low, RW. Default = 0. This field defines low order bits of the initial value of the 64-bit Command Ring Dequeue Pointer. Writes to this field are ignored when Command Ring Running (CRR) = '1'. If the CRCR is written while the Command Ring is stopped (CCR = '0'), the value of this field shall be used to fetch the first Command TRB the next time the Host Controller Doorbell register is written with the DB Reason field set to Host Controller Command. If the CRCR is not written while the Command Ring is stopped (CCR = '0') then the Command Ring shall begin fetching Command TRBs at the current value of the internal xHC Command Ring Dequeue Pointer. Reading this field always returns zero. */
#define IMX_USB3_USBSS_CRCR_LO_CRPTR_L_SHIFT 6
#define IMX_USB3_USBSS_CRCR_LO_CRPTR_L_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_CRCR_LO_CRPTR_L(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_CRCR_HI - Command Ring Control Register High (CRCR_HI). */
typedef union IMX_USB3_USBSS_CRCR_HI_union_t {
    uint32_t R;
    struct {
        uint32_t CRPTR_H     :32;                /* Command Ring Pointer High, RW. Default = 0. This field defines high order bits of the initial value of the 64-bit Command Ring Dequeue Pointer. Writes to this field are ignored when Command Ring Running (CRR) = '1'. If the CRCR is written while the Command Ring is stopped (CCR = '0'), the value of this field shall be used to fetch the first Command TRB the next time the Host Controller Doorbell register is written with the DB Reason field set to Host Controller Command. If the CRCR is not written while the Command Ring is stopped (CCR = '0') then the Command Ring shall begin fetching Command TRBs at the current value of the internal xHC Command Ring Dequeue Pointer. Reading this field always returns zero. */
    } B;
} IMX_USB3_USBSS_CRCR_HI_t;

/* Register CRCR_HI - Command Ring Control Register High (CRCR_HI). */
#define IMX_USB3_USBSS_CRCR_HI_OFFSET 0x1009C
/* Field CRPTR_H - Command Ring Pointer High, RW. Default = 0. This field defines high order bits of the initial value of the 64-bit Command Ring Dequeue Pointer. Writes to this field are ignored when Command Ring Running (CRR) = '1'. If the CRCR is written while the Command Ring is stopped (CCR = '0'), the value of this field shall be used to fetch the first Command TRB the next time the Host Controller Doorbell register is written with the DB Reason field set to Host Controller Command. If the CRCR is not written while the Command Ring is stopped (CCR = '0') then the Command Ring shall begin fetching Command TRBs at the current value of the internal xHC Command Ring Dequeue Pointer. Reading this field always returns zero. */
#define IMX_USB3_USBSS_CRCR_HI_CRPTR_H_SHIFT 0
#define IMX_USB3_USBSS_CRCR_HI_CRPTR_H_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_CRCR_HI_CRPTR_H(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_DCBAAP_LO - Device Context Base Address Array Pointer Register (DCBAAP_LO). */
typedef union IMX_USB3_USBSS_DCBAAP_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t DCBAAPTR_L  :26;                /* Device Context Base Address Array Pointer, RW. Default = 0. This field defines low order bits of the 64-bit base address of the Device Context Pointer Array. A table of address pointers that reference Device Context structures for the devices attached to the host. */
    } B;
} IMX_USB3_USBSS_DCBAAP_LO_t;

/* Register DCBAAP_LO - Device Context Base Address Array Pointer Register (DCBAAP_LO). */
#define IMX_USB3_USBSS_DCBAAP_LO_OFFSET 0x100B0
/* Field DCBAAPTR_L - Device Context Base Address Array Pointer, RW. Default = 0. This field defines low order bits of the 64-bit base address of the Device Context Pointer Array. A table of address pointers that reference Device Context structures for the devices attached to the host. */
#define IMX_USB3_USBSS_DCBAAP_LO_DCBAAPTR_L_SHIFT 6
#define IMX_USB3_USBSS_DCBAAP_LO_DCBAAPTR_L_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_DCBAAP_LO_DCBAAPTR_L(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_DCBAAP_HI - Device Context Base Address Array Pointer Register (DCBAAP_HI). */
typedef union IMX_USB3_USBSS_DCBAAP_HI_union_t {
    uint32_t R;
    struct {
        uint32_t DCBAAPTR_H  :32;                /* Device Context Base Address Array Pointer, RW. Default = 0. This field defines high order bits of the 64-bit base address of the Device Context Pointer Array. A table of address pointers that reference Device Context structures for the devices attached to the host. */
    } B;
} IMX_USB3_USBSS_DCBAAP_HI_t;

/* Register DCBAAP_HI - Device Context Base Address Array Pointer Register (DCBAAP_HI). */
#define IMX_USB3_USBSS_DCBAAP_HI_OFFSET 0x100B4
/* Field DCBAAPTR_H - Device Context Base Address Array Pointer, RW. Default = 0. This field defines high order bits of the 64-bit base address of the Device Context Pointer Array. A table of address pointers that reference Device Context structures for the devices attached to the host. */
#define IMX_USB3_USBSS_DCBAAP_HI_DCBAAPTR_H_SHIFT 0
#define IMX_USB3_USBSS_DCBAAP_HI_DCBAAPTR_H_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_DCBAAP_HI_DCBAAPTR_H(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_CONFIG - Configure Register (CONFIG). */
typedef union IMX_USB3_USBSS_CONFIG_union_t {
    uint32_t R;
    struct {
        uint32_t MAXSLOTSEN  :8;                 /* Max Device Slots Enabled (MaxSlotsEn), RW. Default = 0. This field specifies the maximum number of enabled Device Slots. Valid values are in the range of 0 to MaxSlots. Enabled Devices Slots are allocated contiguously. e.g. A value of 16 specifies that Device Slots 1 to 16 are active. A value of 0 disables all Device Slots. A disabled Device Slot shall not respond to Doorbell Register references. This field shall not be modified by software if the xHC is running (Run/Stop (R/S) = 1). */
        uint32_t _unused8    :24;                /* Reserved */
    } B;
} IMX_USB3_USBSS_CONFIG_t;

/* Register CONFIG - Configure Register (CONFIG). */
#define IMX_USB3_USBSS_CONFIG_OFFSET 0x100B8
/* Field MAXSLOTSEN - Max Device Slots Enabled (MaxSlotsEn), RW. Default = 0. This field specifies the maximum number of enabled Device Slots. Valid values are in the range of 0 to MaxSlots. Enabled Devices Slots are allocated contiguously. e.g. A value of 16 specifies that Device Slots 1 to 16 are active. A value of 0 disables all Device Slots. A disabled Device Slot shall not respond to Doorbell Register references. This field shall not be modified by software if the xHC is running (Run/Stop (R/S) = 1). */
#define IMX_USB3_USBSS_CONFIG_MAXSLOTSEN_SHIFT 0
#define IMX_USB3_USBSS_CONFIG_MAXSLOTSEN_MASK 0xFF
#define IMX_USB3_USBSS_CONFIG_MAXSLOTSEN(v) (((v) << 0) & 0xFF)

/* IMX_USB3_USBSS_PORTSC1USB2 - Port Status and Control Register for USB2 protocol port. */
typedef union IMX_USB3_USBSS_PORTSC1USB2_union_t {
    uint32_t R;
    struct {
        uint32_t CCS         :1;                 /* Current Connect Status (CCS), ROS. Default = '0'. '1' = A device is connected to the port. '0' = A device is not connected. This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change (CSC) bit to be set to '1'. Refer to sections 4.19.3 and 4.19.4 of xHCI specification for more details on the Connect Status Change (CSC) assertion conditions. This flag is '0' if PP is '0'. */
        uint32_t PED         :1;                 /* Port Enabled/Disabled (PED), RW1CS. Default = '0'. '1' = Enabled. '0' = Disabled. Ports may only be enabled by the xHC. Software cannot enable a port by writing a '1' to this flag. A port may be disabled by software writing a '1' to this flag. This flag shall automatically be cleared to '0' by a disconnect event or other fault condition. Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller or bus events. When the port is disabled (PED = '0') downstream propagation of data is blocked on this port, except for reset. When the port is in the Disabled state, software shall reset the port (PR = '1') to transition PED to '1' and the port to the Enabled state. Note that when software writes this bit to a '1', it shall also write a '0' to the PR bit. This flag is '0' if PP is '0'. */
        uint32_t _unused2    :1;                 /* Reserved */
        uint32_t OCA         :1;                 /* Over-current Active (OCA), RO. Default = '0'. '1' = This port currently has an over-current condition. '0' = This port does not have an over-current condition. This bit shall automatically transition from a '1' to a '0' when the over-current condition is removed. */
        uint32_t PR          :1;                 /* Port Reset (PR), RW1S. Default = '0'. '1' = Port Reset signaling is asserted. '0' = Port is not in Reset. When software writes a '1' to this bit generating a '0' to '1' transition, the bus reset sequence is initiated; USB2 protocol ports shall execute the bus reset sequence as defined in the USB2 Spec. PR remains set until reset signaling is completed by the root hub. Note that software shall write a '1' to this flag to transition a USB2 port from the Polling state to the Enabled state. Refer to sections 4.15.2.3 and 4.19.1.1 of xHCI specification. This flag is '0' if PP is '0'. */
        uint32_t PLS         :4;                 /* Port Link State (PLS), RWS. Default = RxDetect ('5'). This field is used to power manage the port and reflects its current link state. When the port is in the Enabled state, system software may set the link U state by writing this field. System software may also write this field to force a Disabled to Disconnected state transition of the port. Write Values: 0: The link shall transition to a U0 state from any of the U states. 2: The link should transition to the U2 State. 3: The link shall transition to a U3 state from the U0 state. This action selectively suspends the device connected to this port. While the Port Link State = U3, the hub does not propagate downstream-directed traffic to this port, but the hub shall respond to resume signaling from the port. 1,4-14: Ignored. 15: If the port is in the U3 state (PLS = U3), then the link shall remain in the U3 state and the port shall transition to the Resume substate, else ignored. Refer to section 4.15.2 of xHCI specification for more information. State Encoding: 0: Link is in the U0 State, 1: Link is in the U1 State, 2: Link is in the U2 State, 3: Link is in the U3 State (Device Suspended), 4: Link is in the Disabled State, 5: Link is in the RxDetect State, 6: Link is in the Inactive State, 7: Link is in the Polling State, 8: Link is in the Recovery State, 9: Link is in the Hot Reset State, 10 Link is in the Compliance Mode State, 11: Link is in the Test Mode State, 12-14: Reserved, 15: Link is in the Resume State. Note: The Port Link State Write Strobe (LWS) shall also be set to '1' to write this field. This field is undefined if PP = '0'. Writing a value of '2' to this field shall request LPM, asserting L1 signaling on the USB2 bus. Software may read this field to determine if the transition to the U2 state was successful. Writing a value of '0' shall deassert L1 signaling on the USB. Writing a value of '1' shall have no effect. The U1 state shall never be reported by a USB2 protocol port. Note: Transitions between different states are not reflected until the transition is complete. Refer to section 4.19 of xHCI specification for PLS transition conditions. Refer to sections 4.15.2 and 4.23.5 for more information on the use of this field. Refer to the USB2 LPM ECR for more information on USB link power management operation. */
        uint32_t PP          :1;                 /* Port Power (PP), RWS. Default = '1'. This flag reflects a port's logical, power control state. Because host controllers can implement different methods of port power switching, this flag may or may not represent whether (VBus) power is actually applied to the port. When PP equals a '0' the port is nonfunctional and shall not report attaches, detaches, or Port Link State (PLS) changes. However, the port shall report over-current conditions when PP = '0' if PPC = '0'. After modifying PP, software shall read PP and confirm that it has reached its target state before modifying it again, undefined behavior may occur if this procedure is not followed. '0' = This port is in the Powered-off state. '1' = This port is not in the Powered-off state. If the Port Power Control (PPC) flag in the HCCPARAMS register is '1', then xHC has port power control switches and this bit represents the current setting of the switch ('0' = off, '1'=on). If the Port Power Control (PPC) flag in the HCCPARAMS register is '0', then xHC does not have port power control switches and each port is hard wired to power, and not affected by this bit. When an over-current condition is detected on a powered port, the xHC shall transition the PP bit in each affected port from a '1' to '0' (removing power from the port). Refer to section 4.19.4 for more information. */
        uint32_t PORTSPEED   :4;                 /* Port Speed (Port Speed), ROS. Default = '0'. This field identifies the speed of the connected USB Device. This field is only relevant if a device is connected (CCS = '1') in all other cases this field shall indicate Undefined Speed. Possible values: 0: Undefined Speed 1-15: Protocol Speed ID (PSI), refer to section 7.2.1 of xHCI specification for the definition of PSIV field in the PSI Dword. Note: This field is invalid on a USB2 protocol port until after the port is reset. */
        uint32_t PIC         :2;                 /* Port Indicator Control (PIC), RWS. Default = '0'. Writing to these bits has no effect if the Port Indicators (PIND) bit in the HCCPARAMS register is a '0'. If PIND bit is a '1', then the bit encodings are: 0: Port indicators are off, 1: Amber, 2: Green, 3: Undefined. Refer to the USB2 Specification section 11.5.3 for a description on how these bits shall be used. This field is '0' if PP is '0'. */
        uint32_t LWS         :1;                 /* Port Link State Write Strobe (LWS), RW. Default = '0'. When this bit is set to '1' on a write reference to this register, this flag enables writes to the PLS field. When '0', write data in PLS field is ignored. Reads to this bit return '0'. */
        uint32_t CSC         :1;                 /* Connect Status Change (CSC), RW1CS. Default = '0'. '1' = Change in CCS. '0' = No change. This flag indicates a change has occurred in the ports Current Connect Status (CCS) or Cold Attach Status (CAS) bits. Note that this flag shall not be set if the CCS transition was due to software setting PP to '0', or the CAS transition was due to software setting WPR to '1'. The xHC sets this bit to '1' for all changes to the port device connect status, even if system software has not cleared an existing Connect Status Change. For example, the insertion status changes twice before system software has cleared the changed condition, root hub hardware will be setting an already-set bit (i.e., the bit will remain 1). Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t PEC         :1;                 /* Port Enabled/Disabled Change (PEC), RW1CS. Default = '0'. '1' = change in PED. '0' = No change. Note that this flag shall not be set if the PED transition was due to software setting PP to '0'. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. This bit shall be set to '1' only when the port is disabled due to the appropriate conditions existing at the EOF2 point (refer to section 11.8.1 of the USB2 Specification for the definition of a Port Error). */
        uint32_t WRC         :1;                 /* Warm Port Reset Change (WRC), RW1CS/RsvdZ. Default = '0'. This bit is set when Warm Reset processing on this port completes. '0' = No change. '1' = Warm Reset complete. Note that this flag shall not be set to '1' if the Warm Reset processing was forced to terminate due to software clearing PP or PED to '0'. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.5.1 of xHCI specification. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. This bit only applies to USB3 protocol ports. For USB2 protocol ports it shall be RsvdZ. */
        uint32_t OCC         :1;                 /* Over-current Change (OCC), RW1CS. Default = '0'. This bit shall be set to a '1' when there is a '0' to '1' or '1' to '0' transition of Over-current Active (OCA). Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t PRC         :1;                 /* Port Reset Change (PRC), RW1CS. Default = '0'. This flag is set to '1' due to a '1' to '0' transition of Port Reset (PR), e.g. when any reset processing (Warm or Hot) on this port is complete. Note that this flag shall not be set to '1' if the reset processing was forced to terminate due to software clearing PP or PED to '0'. '0' = No change. '1' = Reset complete. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.5 of xHCI specification. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t PLC         :1;                 /* Port Link State Change (PLC), RW1CS. Default = '0'. This flag is set to '1' due to the following PLS transitions: U3 -> Resume (Wakeup signaling from a device), Resume -> Recovery -> U0 (Device Resume complete (USB3 protocol ports only)), Resume -> U0 (Device Resume complete (USB2 protocol ports only)), U3 -> Recovery -> U0 (Software Resume complete (USB3 protocol ports only)), U3 -> U0 (Software Resume complete (USB2 protocol ports only)), U2 -> U0 (L1 Resume complete (USB2 protocol ports only)), U0 -> U0 (L1 Entry Reject (USB2 protocol ports only)), Any state -> Inactive (Error (USB3 protocol ports only)). Note that this flag shall not be set if the PLS transition was due to software setting PP to 0. Refer to section 4.23.5 of xHCI specification for more information. '0' = No change. '1' = Link Status Changed. Software shall clear this bit by writing a '1' to it. Refer to PLC Condition: references in section 4.19.1 for the specific port state transitions that set this flag. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t _unused23   :1;                 /* Reserved */
        uint32_t CAS         :1;                 /* Cold Attach Status (CAS), RO. Default = '0'. '1' = Far-end Receiver Terminations were detected in the Disconnected state and the Root Hub Port State Machine was unable to advance to the Enabled state. Refer to sections 4.19.8 of xHCI specification for more details on the Cold Attach Status (CAS) assertion conditions. Software shall clear this bit by writing a '1' to WPR or the xHC shall clear this bit if CCS transitions to '1'. This flag is '0' for USB2 protocol ports. */
        uint32_t WCE         :1;                 /* Wake on Connect Enable (WCE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to device connects as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
        uint32_t WDE         :1;                 /* Wake on Disconnect Enable (WDE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to device disconnects as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
        uint32_t WOE         :1;                 /* Wake on Over-current Enable (WOE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to over-current conditions as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
        uint32_t _unused28   :2;                 /* Reserved */
        uint32_t DR          :1;                 /* Device Removable (DR), RO. This flag indicates if this port has a removable device attached. '0' = Device is removable; '1' = Device is non-removable. */
        uint32_t _unused31   :1;                 /* Reserved */
    } B;
} IMX_USB3_USBSS_PORTSC1USB2_t;

/* Register PORTSC1USB2 - Port Status and Control Register for USB2 protocol port. */
#define IMX_USB3_USBSS_PORTSC1USB2_OFFSET 0x10480
/* Field CCS - Current Connect Status (CCS), ROS. Default = '0'. '1' = A device is connected to the port. '0' = A device is not connected. This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change (CSC) bit to be set to '1'. Refer to sections 4.19.3 and 4.19.4 of xHCI specification for more details on the Connect Status Change (CSC) assertion conditions. This flag is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTSC1USB2_CCS_SHIFT 0
#define IMX_USB3_USBSS_PORTSC1USB2_CCS_MASK 0x1
#define IMX_USB3_USBSS_PORTSC1USB2_CCS(v) (((v) << 0) & 0x1)
/* Field PED - Port Enabled/Disabled (PED), RW1CS. Default = '0'. '1' = Enabled. '0' = Disabled. Ports may only be enabled by the xHC. Software cannot enable a port by writing a '1' to this flag. A port may be disabled by software writing a '1' to this flag. This flag shall automatically be cleared to '0' by a disconnect event or other fault condition. Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller or bus events. When the port is disabled (PED = '0') downstream propagation of data is blocked on this port, except for reset. When the port is in the Disabled state, software shall reset the port (PR = '1') to transition PED to '1' and the port to the Enabled state. Note that when software writes this bit to a '1', it shall also write a '0' to the PR bit. This flag is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTSC1USB2_PED_SHIFT 1
#define IMX_USB3_USBSS_PORTSC1USB2_PED_MASK 0x2
#define IMX_USB3_USBSS_PORTSC1USB2_PED(v) (((v) << 0x1) & 0x2)
/* Field OCA - Over-current Active (OCA), RO. Default = '0'. '1' = This port currently has an over-current condition. '0' = This port does not have an over-current condition. This bit shall automatically transition from a '1' to a '0' when the over-current condition is removed. */
#define IMX_USB3_USBSS_PORTSC1USB2_OCA_SHIFT 3
#define IMX_USB3_USBSS_PORTSC1USB2_OCA_MASK 0x8
#define IMX_USB3_USBSS_PORTSC1USB2_OCA(v) (((v) << 0x3) & 0x8)
/* Field PR - Port Reset (PR), RW1S. Default = '0'. '1' = Port Reset signaling is asserted. '0' = Port is not in Reset. When software writes a '1' to this bit generating a '0' to '1' transition, the bus reset sequence is initiated; USB2 protocol ports shall execute the bus reset sequence as defined in the USB2 Spec. PR remains set until reset signaling is completed by the root hub. Note that software shall write a '1' to this flag to transition a USB2 port from the Polling state to the Enabled state. Refer to sections 4.15.2.3 and 4.19.1.1 of xHCI specification. This flag is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTSC1USB2_PR_SHIFT 4
#define IMX_USB3_USBSS_PORTSC1USB2_PR_MASK 0x10
#define IMX_USB3_USBSS_PORTSC1USB2_PR(v) (((v) << 0x4) & 0x10)
/* Field PLS - Port Link State (PLS), RWS. Default = RxDetect ('5'). This field is used to power manage the port and reflects its current link state. When the port is in the Enabled state, system software may set the link U state by writing this field. System software may also write this field to force a Disabled to Disconnected state transition of the port. Write Values: 0: The link shall transition to a U0 state from any of the U states. 2: The link should transition to the U2 State. 3: The link shall transition to a U3 state from the U0 state. This action selectively suspends the device connected to this port. While the Port Link State = U3, the hub does not propagate downstream-directed traffic to this port, but the hub shall respond to resume signaling from the port. 1,4-14: Ignored. 15: If the port is in the U3 state (PLS = U3), then the link shall remain in the U3 state and the port shall transition to the Resume substate, else ignored. Refer to section 4.15.2 of xHCI specification for more information. State Encoding: 0: Link is in the U0 State, 1: Link is in the U1 State, 2: Link is in the U2 State, 3: Link is in the U3 State (Device Suspended), 4: Link is in the Disabled State, 5: Link is in the RxDetect State, 6: Link is in the Inactive State, 7: Link is in the Polling State, 8: Link is in the Recovery State, 9: Link is in the Hot Reset State, 10 Link is in the Compliance Mode State, 11: Link is in the Test Mode State, 12-14: Reserved, 15: Link is in the Resume State. Note: The Port Link State Write Strobe (LWS) shall also be set to '1' to write this field. This field is undefined if PP = '0'. Writing a value of '2' to this field shall request LPM, asserting L1 signaling on the USB2 bus. Software may read this field to determine if the transition to the U2 state was successful. Writing a value of '0' shall deassert L1 signaling on the USB. Writing a value of '1' shall have no effect. The U1 state shall never be reported by a USB2 protocol port. Note: Transitions between different states are not reflected until the transition is complete. Refer to section 4.19 of xHCI specification for PLS transition conditions. Refer to sections 4.15.2 and 4.23.5 for more information on the use of this field. Refer to the USB2 LPM ECR for more information on USB link power management operation. */
#define IMX_USB3_USBSS_PORTSC1USB2_PLS_SHIFT 5
#define IMX_USB3_USBSS_PORTSC1USB2_PLS_MASK 0x1E0
#define IMX_USB3_USBSS_PORTSC1USB2_PLS(v) (((v) << 0x5) & 0x1E0)
/* Field PP - Port Power (PP), RWS. Default = '1'. This flag reflects a port's logical, power control state. Because host controllers can implement different methods of port power switching, this flag may or may not represent whether (VBus) power is actually applied to the port. When PP equals a '0' the port is nonfunctional and shall not report attaches, detaches, or Port Link State (PLS) changes. However, the port shall report over-current conditions when PP = '0' if PPC = '0'. After modifying PP, software shall read PP and confirm that it has reached its target state before modifying it again, undefined behavior may occur if this procedure is not followed. '0' = This port is in the Powered-off state. '1' = This port is not in the Powered-off state. If the Port Power Control (PPC) flag in the HCCPARAMS register is '1', then xHC has port power control switches and this bit represents the current setting of the switch ('0' = off, '1'=on). If the Port Power Control (PPC) flag in the HCCPARAMS register is '0', then xHC does not have port power control switches and each port is hard wired to power, and not affected by this bit. When an over-current condition is detected on a powered port, the xHC shall transition the PP bit in each affected port from a '1' to '0' (removing power from the port). Refer to section 4.19.4 for more information. */
#define IMX_USB3_USBSS_PORTSC1USB2_PP_SHIFT 9
#define IMX_USB3_USBSS_PORTSC1USB2_PP_MASK 0x200
#define IMX_USB3_USBSS_PORTSC1USB2_PP(v) (((v) << 0x9) & 0x200)
/* Field PORTSPEED - Port Speed (Port Speed), ROS. Default = '0'. This field identifies the speed of the connected USB Device. This field is only relevant if a device is connected (CCS = '1') in all other cases this field shall indicate Undefined Speed. Possible values: 0: Undefined Speed 1-15: Protocol Speed ID (PSI), refer to section 7.2.1 of xHCI specification for the definition of PSIV field in the PSI Dword. Note: This field is invalid on a USB2 protocol port until after the port is reset. */
#define IMX_USB3_USBSS_PORTSC1USB2_PORTSPEED_SHIFT 10
#define IMX_USB3_USBSS_PORTSC1USB2_PORTSPEED_MASK 0x3C00
#define IMX_USB3_USBSS_PORTSC1USB2_PORTSPEED(v) (((v) << 0xA) & 0x3C00)
/* Field PIC - Port Indicator Control (PIC), RWS. Default = '0'. Writing to these bits has no effect if the Port Indicators (PIND) bit in the HCCPARAMS register is a '0'. If PIND bit is a '1', then the bit encodings are: 0: Port indicators are off, 1: Amber, 2: Green, 3: Undefined. Refer to the USB2 Specification section 11.5.3 for a description on how these bits shall be used. This field is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTSC1USB2_PIC_SHIFT 14
#define IMX_USB3_USBSS_PORTSC1USB2_PIC_MASK 0xC000
#define IMX_USB3_USBSS_PORTSC1USB2_PIC(v) (((v) << 0xE) & 0xC000)
/* Field LWS - Port Link State Write Strobe (LWS), RW. Default = '0'. When this bit is set to '1' on a write reference to this register, this flag enables writes to the PLS field. When '0', write data in PLS field is ignored. Reads to this bit return '0'. */
#define IMX_USB3_USBSS_PORTSC1USB2_LWS_SHIFT 16
#define IMX_USB3_USBSS_PORTSC1USB2_LWS_MASK 0x10000
#define IMX_USB3_USBSS_PORTSC1USB2_LWS(v) (((v) << 0x10) & 0x10000)
/* Field CSC - Connect Status Change (CSC), RW1CS. Default = '0'. '1' = Change in CCS. '0' = No change. This flag indicates a change has occurred in the ports Current Connect Status (CCS) or Cold Attach Status (CAS) bits. Note that this flag shall not be set if the CCS transition was due to software setting PP to '0', or the CAS transition was due to software setting WPR to '1'. The xHC sets this bit to '1' for all changes to the port device connect status, even if system software has not cleared an existing Connect Status Change. For example, the insertion status changes twice before system software has cleared the changed condition, root hub hardware will be setting an already-set bit (i.e., the bit will remain 1). Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB2_CSC_SHIFT 17
#define IMX_USB3_USBSS_PORTSC1USB2_CSC_MASK 0x20000
#define IMX_USB3_USBSS_PORTSC1USB2_CSC(v) (((v) << 0x11) & 0x20000)
/* Field PEC - Port Enabled/Disabled Change (PEC), RW1CS. Default = '0'. '1' = change in PED. '0' = No change. Note that this flag shall not be set if the PED transition was due to software setting PP to '0'. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. This bit shall be set to '1' only when the port is disabled due to the appropriate conditions existing at the EOF2 point (refer to section 11.8.1 of the USB2 Specification for the definition of a Port Error). */
#define IMX_USB3_USBSS_PORTSC1USB2_PEC_SHIFT 18
#define IMX_USB3_USBSS_PORTSC1USB2_PEC_MASK 0x40000
#define IMX_USB3_USBSS_PORTSC1USB2_PEC(v) (((v) << 0x12) & 0x40000)
/* Field WRC - Warm Port Reset Change (WRC), RW1CS/RsvdZ. Default = '0'. This bit is set when Warm Reset processing on this port completes. '0' = No change. '1' = Warm Reset complete. Note that this flag shall not be set to '1' if the Warm Reset processing was forced to terminate due to software clearing PP or PED to '0'. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.5.1 of xHCI specification. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. This bit only applies to USB3 protocol ports. For USB2 protocol ports it shall be RsvdZ. */
#define IMX_USB3_USBSS_PORTSC1USB2_WRC_SHIFT 19
#define IMX_USB3_USBSS_PORTSC1USB2_WRC_MASK 0x80000
#define IMX_USB3_USBSS_PORTSC1USB2_WRC(v) (((v) << 0x13) & 0x80000)
/* Field OCC - Over-current Change (OCC), RW1CS. Default = '0'. This bit shall be set to a '1' when there is a '0' to '1' or '1' to '0' transition of Over-current Active (OCA). Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB2_OCC_SHIFT 20
#define IMX_USB3_USBSS_PORTSC1USB2_OCC_MASK 0x100000
#define IMX_USB3_USBSS_PORTSC1USB2_OCC(v) (((v) << 0x14) & 0x100000)
/* Field PRC - Port Reset Change (PRC), RW1CS. Default = '0'. This flag is set to '1' due to a '1' to '0' transition of Port Reset (PR), e.g. when any reset processing (Warm or Hot) on this port is complete. Note that this flag shall not be set to '1' if the reset processing was forced to terminate due to software clearing PP or PED to '0'. '0' = No change. '1' = Reset complete. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.5 of xHCI specification. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB2_PRC_SHIFT 21
#define IMX_USB3_USBSS_PORTSC1USB2_PRC_MASK 0x200000
#define IMX_USB3_USBSS_PORTSC1USB2_PRC(v) (((v) << 0x15) & 0x200000)
/* Field PLC - Port Link State Change (PLC), RW1CS. Default = '0'. This flag is set to '1' due to the following PLS transitions: U3 -> Resume (Wakeup signaling from a device), Resume -> Recovery -> U0 (Device Resume complete (USB3 protocol ports only)), Resume -> U0 (Device Resume complete (USB2 protocol ports only)), U3 -> Recovery -> U0 (Software Resume complete (USB3 protocol ports only)), U3 -> U0 (Software Resume complete (USB2 protocol ports only)), U2 -> U0 (L1 Resume complete (USB2 protocol ports only)), U0 -> U0 (L1 Entry Reject (USB2 protocol ports only)), Any state -> Inactive (Error (USB3 protocol ports only)). Note that this flag shall not be set if the PLS transition was due to software setting PP to 0. Refer to section 4.23.5 of xHCI specification for more information. '0' = No change. '1' = Link Status Changed. Software shall clear this bit by writing a '1' to it. Refer to PLC Condition: references in section 4.19.1 for the specific port state transitions that set this flag. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB2_PLC_SHIFT 22
#define IMX_USB3_USBSS_PORTSC1USB2_PLC_MASK 0x400000
#define IMX_USB3_USBSS_PORTSC1USB2_PLC(v) (((v) << 0x16) & 0x400000)
/* Field CAS - Cold Attach Status (CAS), RO. Default = '0'. '1' = Far-end Receiver Terminations were detected in the Disconnected state and the Root Hub Port State Machine was unable to advance to the Enabled state. Refer to sections 4.19.8 of xHCI specification for more details on the Cold Attach Status (CAS) assertion conditions. Software shall clear this bit by writing a '1' to WPR or the xHC shall clear this bit if CCS transitions to '1'. This flag is '0' for USB2 protocol ports. */
#define IMX_USB3_USBSS_PORTSC1USB2_CAS_SHIFT 24
#define IMX_USB3_USBSS_PORTSC1USB2_CAS_MASK 0x1000000
#define IMX_USB3_USBSS_PORTSC1USB2_CAS(v) (((v) << 0x18) & 0x1000000)
/* Field WCE - Wake on Connect Enable (WCE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to device connects as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
#define IMX_USB3_USBSS_PORTSC1USB2_WCE_SHIFT 25
#define IMX_USB3_USBSS_PORTSC1USB2_WCE_MASK 0x2000000
#define IMX_USB3_USBSS_PORTSC1USB2_WCE(v) (((v) << 0x19) & 0x2000000)
/* Field WDE - Wake on Disconnect Enable (WDE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to device disconnects as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
#define IMX_USB3_USBSS_PORTSC1USB2_WDE_SHIFT 26
#define IMX_USB3_USBSS_PORTSC1USB2_WDE_MASK 0x4000000
#define IMX_USB3_USBSS_PORTSC1USB2_WDE(v) (((v) << 0x1A) & 0x4000000)
/* Field WOE - Wake on Over-current Enable (WOE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to over-current conditions as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
#define IMX_USB3_USBSS_PORTSC1USB2_WOE_SHIFT 27
#define IMX_USB3_USBSS_PORTSC1USB2_WOE_MASK 0x8000000
#define IMX_USB3_USBSS_PORTSC1USB2_WOE(v) (((v) << 0x1B) & 0x8000000)
/* Field DR - Device Removable (DR), RO. This flag indicates if this port has a removable device attached. '0' = Device is removable; '1' = Device is non-removable. */
#define IMX_USB3_USBSS_PORTSC1USB2_DR_SHIFT 30
#define IMX_USB3_USBSS_PORTSC1USB2_DR_MASK 0x40000000
#define IMX_USB3_USBSS_PORTSC1USB2_DR(v) (((v) << 0x1E) & 0x40000000)

/* IMX_USB3_USBSS_PORTPMSC1USB2 - The USB2 Port Power Management Status and Control register. */
typedef union IMX_USB3_USBSS_PORTPMSC1USB2_union_t {
    uint32_t R;
    struct {
        uint32_t L1S         :3;                 /* L1 Status (L1S), RO. Default = 0. This field is used by software to determine whether an L1-based suspend request (LPM transaction) was successful, specifically: 0: Invalid - This field shall be ignored by software. 1: Success - Port successfully transitioned to L1 (ACK) 2: Not Yet - Device is unable to enter L1 at this time (NYET) 3: Not Supported - Device does not support L1 transitions (STALL) 4: Timeout/Error - Device failed to respond to the LPM Transaction or an error occurred 5-7: Reserved The value of this field is only valid when the port resides in the L0 or L1 state (PLS = 0 or 2). Refer to section 4.23.5.1.1 of xHCI specification for more information. */
        uint32_t RWE         :1;                 /* Remote Wake Enable (RWE), RW. Default = '0'. System software sets this flag to enable or disable the device for remote wake from L1. The value of this flag shall temporarily (while in L1) override the current setting of the Remote Wake feature set by the standard Set/ClearFeature() commands defined in Universal Serial Bus Specification, revision 2.0, Chapter 9. */
        uint32_t BESL        :4;                 /* Best Effort Service Latency (BESL), RW. Default = 0. System software sets this field to indicate to the recipient device how long the xHC will drive resume if it (the xHC) initiates an exit from L1. The BESL value encoding is defined in Table 13. Note that the BESL field is used by both software and hardware controlled LPM. Refer to section 4.23.5.1.1 of xHCI specification for more information on BESL use. Refer to section 5.2.5 of xHCI specification for information on how DBESL may be used to establish an initial value for BESL. */
        uint32_t L1DS        :8;                 /* L1 Device Slot, RW. Default = 0. System software sets this field to indicate the ID of the Device Slot associated with the device directly attached to the Root Hub port. A value of '0' indicates no device is present. The xHC uses this field to lookup information necessary to generate the LPM Token packet. */
        uint32_t HLE         :1;                 /* Hardware LPM Enable (HLE), RW. Default = '0'. If this bit is set to '1', then hardware controlled LPM shall be enabled for this port. Refer to section 4.23.5.1.1.1 of xHCI specification. If the USB2 Hardware LPM Capability is not supported (HLC = '0') this field shall be RsvdZ. */
        uint32_t _unused17   :11;                /* Reserved */
        uint32_t PTC         :4;                 /* Port Test Control, RW. Default = '0'. When this field is '0', the port is NOT operating in a test mode. A non-zero value indicates that it is operating in test mode and the specific test mode is indicated by the specific value. A non-zero Port Test Control value is only valid to a port that is in the Powered-Off state (PLS = Disabled). If the port is not in this state, the xHC shall respond with the Port Test Control field set to Port Test Control Error. Refer to section 4.19.6 for the operational model for using these test modes. The encoding of the Test Mode bits for a USB2 protocol port are: 0: Test mode not enabled 1: Test J_STATE 2: Test K_STATE 3: Test SE0_NAK 4: Test Packet 5: Test FORCE_ENABLE 6-14: Reserved. 15: Port Test Control Error. Refer to the sections 7.1.20 and 11.24.2.13 of the USB2 spec for more information on Test Modes. */
    } B;
} IMX_USB3_USBSS_PORTPMSC1USB2_t;

/* Register PORTPMSC1USB2 - The USB2 Port Power Management Status and Control register. */
#define IMX_USB3_USBSS_PORTPMSC1USB2_OFFSET 0x10484
/* Field L1S - L1 Status (L1S), RO. Default = 0. This field is used by software to determine whether an L1-based suspend request (LPM transaction) was successful, specifically: 0: Invalid - This field shall be ignored by software. 1: Success - Port successfully transitioned to L1 (ACK) 2: Not Yet - Device is unable to enter L1 at this time (NYET) 3: Not Supported - Device does not support L1 transitions (STALL) 4: Timeout/Error - Device failed to respond to the LPM Transaction or an error occurred 5-7: Reserved The value of this field is only valid when the port resides in the L0 or L1 state (PLS = 0 or 2). Refer to section 4.23.5.1.1 of xHCI specification for more information. */
#define IMX_USB3_USBSS_PORTPMSC1USB2_L1S_SHIFT 0
#define IMX_USB3_USBSS_PORTPMSC1USB2_L1S_MASK 0x7
#define IMX_USB3_USBSS_PORTPMSC1USB2_L1S(v) (((v) << 0) & 0x7)
/* Field RWE - Remote Wake Enable (RWE), RW. Default = '0'. System software sets this flag to enable or disable the device for remote wake from L1. The value of this flag shall temporarily (while in L1) override the current setting of the Remote Wake feature set by the standard Set/ClearFeature() commands defined in Universal Serial Bus Specification, revision 2.0, Chapter 9. */
#define IMX_USB3_USBSS_PORTPMSC1USB2_RWE_SHIFT 3
#define IMX_USB3_USBSS_PORTPMSC1USB2_RWE_MASK 0x8
#define IMX_USB3_USBSS_PORTPMSC1USB2_RWE(v) (((v) << 0x3) & 0x8)
/* Field BESL - Best Effort Service Latency (BESL), RW. Default = 0. System software sets this field to indicate to the recipient device how long the xHC will drive resume if it (the xHC) initiates an exit from L1. The BESL value encoding is defined in Table 13. Note that the BESL field is used by both software and hardware controlled LPM. Refer to section 4.23.5.1.1 of xHCI specification for more information on BESL use. Refer to section 5.2.5 of xHCI specification for information on how DBESL may be used to establish an initial value for BESL. */
#define IMX_USB3_USBSS_PORTPMSC1USB2_BESL_SHIFT 4
#define IMX_USB3_USBSS_PORTPMSC1USB2_BESL_MASK 0xF0
#define IMX_USB3_USBSS_PORTPMSC1USB2_BESL(v) (((v) << 0x4) & 0xF0)
/* Field L1DS - L1 Device Slot, RW. Default = 0. System software sets this field to indicate the ID of the Device Slot associated with the device directly attached to the Root Hub port. A value of '0' indicates no device is present. The xHC uses this field to lookup information necessary to generate the LPM Token packet. */
#define IMX_USB3_USBSS_PORTPMSC1USB2_L1DS_SHIFT 8
#define IMX_USB3_USBSS_PORTPMSC1USB2_L1DS_MASK 0xFF00
#define IMX_USB3_USBSS_PORTPMSC1USB2_L1DS(v) (((v) << 0x8) & 0xFF00)
/* Field HLE - Hardware LPM Enable (HLE), RW. Default = '0'. If this bit is set to '1', then hardware controlled LPM shall be enabled for this port. Refer to section 4.23.5.1.1.1 of xHCI specification. If the USB2 Hardware LPM Capability is not supported (HLC = '0') this field shall be RsvdZ. */
#define IMX_USB3_USBSS_PORTPMSC1USB2_HLE_SHIFT 16
#define IMX_USB3_USBSS_PORTPMSC1USB2_HLE_MASK 0x10000
#define IMX_USB3_USBSS_PORTPMSC1USB2_HLE(v) (((v) << 0x10) & 0x10000)
/* Field PTC - Port Test Control, RW. Default = '0'. When this field is '0', the port is NOT operating in a test mode. A non-zero value indicates that it is operating in test mode and the specific test mode is indicated by the specific value. A non-zero Port Test Control value is only valid to a port that is in the Powered-Off state (PLS = Disabled). If the port is not in this state, the xHC shall respond with the Port Test Control field set to Port Test Control Error. Refer to section 4.19.6 for the operational model for using these test modes. The encoding of the Test Mode bits for a USB2 protocol port are: 0: Test mode not enabled 1: Test J_STATE 2: Test K_STATE 3: Test SE0_NAK 4: Test Packet 5: Test FORCE_ENABLE 6-14: Reserved. 15: Port Test Control Error. Refer to the sections 7.1.20 and 11.24.2.13 of the USB2 spec for more information on Test Modes. */
#define IMX_USB3_USBSS_PORTPMSC1USB2_PTC_SHIFT 28
#define IMX_USB3_USBSS_PORTPMSC1USB2_PTC_MASK 0xF0000000
#define IMX_USB3_USBSS_PORTPMSC1USB2_PTC(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_PORT1HLPMC - The optional normative USB2 Port Hardware LPM Control register provides the USB2 LPM parameters necessary for the xHC to automatically generate a LPM Token to the downstream device. */
typedef union IMX_USB3_USBSS_PORT1HLPMC_union_t {
    uint32_t R;
    struct {
        uint32_t HIRDM       :2;                 /* Host Initiated Resume Duration Mode (HIRDM), RWS. Default = 0h. Indicates which HIRD value should be used. The following are permissible values: 0: Initiate L1 using BESL only on timeout. (default) 1: Initiate L1 using BESLD on timeout. If rejected by device, initiate L1 using BESL. 3-2: Reserved. */
        uint32_t L1_TIMEOUT  :8;                 /* L1 Timeout, RWS. Default = 00h. Timeout value for the L1 inactivity timer (LPM Timer). This field shall be set to 00h by the assertion of PR to '1'. Refer to section 4.23.5.1.1.1 of xHci specification for more information on L1 Timeout operation. The following are permissible values: 00h 128 us. (default) 01h 256 us. 02h 512 us. 03h 768 us. ... FFh 65,280 us. */
        uint32_t BESLD       :4;                 /* Best Effort Service Latency Deep (BESLD), RWS. Default = '0'. System software sets this field to indicate to the recipient device how long the xHC will drive resume on an exit from U2. Refer to section 4.23.5.1.1.1 of xHCI specification for more information on BESLD use. The BESLD value encoding is defined in Table 13. Refer to section 5.2.6 of xHCI specification for information on how DBESLD may be used to establish an initial value for BESLD. */
        uint32_t _unused14   :18;                /* Reserved */
    } B;
} IMX_USB3_USBSS_PORT1HLPMC_t;

/* Register PORT1HLPMC - The optional normative USB2 Port Hardware LPM Control register provides the USB2 LPM parameters necessary for the xHC to automatically generate a LPM Token to the downstream device. */
#define IMX_USB3_USBSS_PORT1HLPMC_OFFSET 0x1048C
/* Field HIRDM - Host Initiated Resume Duration Mode (HIRDM), RWS. Default = 0h. Indicates which HIRD value should be used. The following are permissible values: 0: Initiate L1 using BESL only on timeout. (default) 1: Initiate L1 using BESLD on timeout. If rejected by device, initiate L1 using BESL. 3-2: Reserved. */
#define IMX_USB3_USBSS_PORT1HLPMC_HIRDM_SHIFT 0
#define IMX_USB3_USBSS_PORT1HLPMC_HIRDM_MASK 0x3
#define IMX_USB3_USBSS_PORT1HLPMC_HIRDM(v) (((v) << 0) & 0x3)
/* Field L1_TIMEOUT - L1 Timeout, RWS. Default = 00h. Timeout value for the L1 inactivity timer (LPM Timer). This field shall be set to 00h by the assertion of PR to '1'. Refer to section 4.23.5.1.1.1 of xHci specification for more information on L1 Timeout operation. The following are permissible values: 00h 128 us. (default) 01h 256 us. 02h 512 us. 03h 768 us. ... FFh 65,280 us. */
#define IMX_USB3_USBSS_PORT1HLPMC_L1_TIMEOUT_SHIFT 2
#define IMX_USB3_USBSS_PORT1HLPMC_L1_TIMEOUT_MASK 0x3FC
#define IMX_USB3_USBSS_PORT1HLPMC_L1_TIMEOUT(v) (((v) << 0x2) & 0x3FC)
/* Field BESLD - Best Effort Service Latency Deep (BESLD), RWS. Default = '0'. System software sets this field to indicate to the recipient device how long the xHC will drive resume on an exit from U2. Refer to section 4.23.5.1.1.1 of xHCI specification for more information on BESLD use. The BESLD value encoding is defined in Table 13. Refer to section 5.2.6 of xHCI specification for information on how DBESLD may be used to establish an initial value for BESLD. */
#define IMX_USB3_USBSS_PORT1HLPMC_BESLD_SHIFT 10
#define IMX_USB3_USBSS_PORT1HLPMC_BESLD_MASK 0x3C00
#define IMX_USB3_USBSS_PORT1HLPMC_BESLD(v) (((v) << 0xA) & 0x3C00)

/* IMX_USB3_USBSS_PORTSC1USB3 - Port Status and Control Register for USB3 protocol port. */
typedef union IMX_USB3_USBSS_PORTSC1USB3_union_t {
    uint32_t R;
    struct {
        uint32_t CCS         :1;                 /* Current Connect Status (CCS), ROS. Default = '0'. '1' = A device is connected to the port. '0' = A device is not connected. This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change (CSC) bit to be set to '1'. Refer to sections 4.19.3 and 4.19.4 of xHCI specification for more details on the Connect Status Change (CSC) assertion conditions. This flag is '0' if PP is '0'. */
        uint32_t PED         :1;                 /* Port Enabled/Disabled (PED), RW1CS. Default = '0'. '1' = Enabled. '0' = Disabled. Ports may only be enabled by the xHC. Software cannot enable a port by writing a '1' to this flag. A port may be disabled by software writing a '1' to this flag. This flag shall automatically be cleared to '0' by a disconnect event or other fault condition. Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller or bus events. When the port is disabled (PED = '0') downstream propagation of data is blocked on this port, except for reset. When the port is in the Polling state (after detecting an attach), the port shall automatically transition to the Enabled state and set PED to '1' upon the completion of successful link training. When the port is in the Disabled state, software shall write a 5 (RxDetect) to the PLS field to transition the port to the Disconnected state. Refer to section 4.19.1.2 of xHCI specification. PED shall automatically be cleared to '0' when PR is set to '1', and set to '1' when PR transitions from '1' to '0' after a successful reset. Refer to Port Reset (PR) bit for more information on how the PED bit is managed. Note that when software writes this bit to a '1', it shall also write a '0' to the PR bit. This flag is '0' if PP is '0'. */
        uint32_t _unused2    :1;                 /* Reserved */
        uint32_t OCA         :1;                 /* Over-current Active (OCA), RO. Default = '0'. '1' = This port currently has an over-current condition. '0' = This port does not have an over-current condition. This bit shall automatically transition from a '1' to a '0' when the over-current condition is removed. */
        uint32_t PR          :1;                 /* Port Reset (PR), RW1S. Default = '0'. '1' = Port Reset signaling is asserted. '0' = Port is not in Reset. When software writes a '1' to this bit generating a '0' to '1' transition, the bus reset sequence is initiated; USB3 protocol ports shall execute the Hot Reset sequence as defined in the USB3 Spec. PR remains set until reset signaling is completed by the root hub. This flag is '0' if PP is '0'. */
        uint32_t PLS         :4;                 /* Port Link State (PLS), RWS. Default = RxDetect ('5'). This field is used to power manage the port and reflects its current link state. When the port is in the Enabled state, system software may set the link U state by writing this field. System software may also write this field to force a Disabled to Disconnected state transition of the port. Write Values: 0: The link shall transition to a U0 state from any of the U states. 3: The link shall transition to a U3 state from the U0 state. This action selectively suspends the device connected to this port. While the Port Link State = U3, the hub does not propagate downstream-directed traffic to this port, but the hub shall respond to resume signaling from the port. 5: If the port is in the Disabled state (PLS = Disabled, PP = '1'), then the link shall transition to a RxDetect state and the port shall transition to the Disconnected state, else ignored. 1-2,4,6-15: Ignored. State Encoding: 0: Link is in the U0 State, 1: Link is in the U1 State, 2: Link is in the U2 State, 3: Link is in the U3 State (Device Suspended), 4: Link is in the Disabled State, 5: Link is in the RxDetect State, 6: Link is in the Inactive State, 7: Link is in the Polling State, 8: Link is in the Recovery State, 9: Link is in the Hot Reset State, 10 Link is in the Compliance Mode State, 11: Link is in the Test Mode State, 12-14: Reserved, 15: Link is in the Resume State. Note: The Port Link State Write Strobe (LWS) shall also be set to '1' to write this field. This field is undefined if PP = '0'. Note: Transitions between different states are not reflected until the transition is complete. Refer to section 4.19 of xHCI specification for PLS transition conditions. Refer to sections 4.15.2 and 4.23.5 for more information on the use of this field. */
        uint32_t PP          :1;                 /* Port Power (PP), RWS. Default = '1'. This flag reflects a port's logical, power control state. Because host controllers can implement different methods of port power switching, this flag may or may not represent whether (VBus) power is actually applied to the port. When PP equals a '0' the port is nonfunctional and shall not report attaches, detaches, or Port Link State (PLS) changes. However, the port shall report over-current conditions when PP = '0' if PPC = '0'. After modifying PP, software shall read PP and confirm that it has reached its target state before modifying it again, undefined behavior may occur if this procedure is not followed. '0' = This port is in the Powered-off state. '1' = This port is not in the Powered-off state. If the Port Power Control (PPC) flag in the HCCPARAMS register is '1', then xHC has port power control switches and this bit represents the current setting of the switch ('0' = off, '1'=on). If the Port Power Control (PPC) flag in the HCCPARAMS register is '0', then xHC does not have port power control switches and each port is hard wired to power, and not affected by this bit. When an over-current condition is detected on a powered port, the xHC shall transition the PP bit in each affected port from a '1' to '0' (removing power from the port). Refer to section 4.19.4 for more information. */
        uint32_t PORTSPEED   :4;                 /* Port Speed (Port Speed), ROS. Default = '0'. This field identifies the speed of the connected USB Device. This field is only relevant if a device is connected (CCS = '1') in all other cases this field shall indicate Undefined Speed. Possible values: 0: Undefined Speed 1-15: Protocol Speed ID (PSI), refer to section 7.2.1 of xHCI specification for the definition of PSIV field in the PSI Dword. */
        uint32_t PIC         :2;                 /* Port Indicator Control (PIC), RWS. Default = '0'. Writing to these bits has no effect if the Port Indicators (PIND) bit in the HCCPARAMS register is a '0'. If PIND bit is a '1', then the bit encodings are: 0: Port indicators are off, 1: Amber, 2: Green, 3: Undefined. This field is '0' if PP is '0'. */
        uint32_t LWS         :1;                 /* Port Link State Write Strobe (LWS), RW. Default = '0'. When this bit is set to '1' on a write reference to this register, this flag enables writes to the PLS field. When '0', write data in PLS field is ignored. Reads to this bit return '0'. */
        uint32_t CSC         :1;                 /* Connect Status Change (CSC), RW1CS. Default = '0'. '1' = Change in CCS. '0' = No change. This flag indicates a change has occurred in the ports Current Connect Status (CCS) or Cold Attach Status (CAS) bits. Note that this flag shall not be set if the CCS transition was due to software setting PP to '0', or the CAS transition was due to software setting WPR to '1'. The xHC sets this bit to '1' for all changes to the port device connect status, even if system software has not cleared an existing Connect Status Change. For example, the insertion status changes twice before system software has cleared the changed condition, root hub hardware will be setting an already-set bit (i.e., the bit will remain 1). Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t PEC         :1;                 /* Port Enabled/Disabled Change (PEC), RW1CS. Default = '0'. '1' = change in PED. '0' = No change. Note that this flag shall not be set if the PED transition was due to software setting PP to '0'. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. This bit shall never be set to '1'. */
        uint32_t WRC         :1;                 /* Warm Port Reset Change (WRC), RW1CS. Default = '0'. This bit is set when Warm Reset processing on this port completes. '0' = No change. '1' = Warm Reset complete. Note that this flag shall not be set to '1' if the Warm Reset processing was forced to terminate due to software clearing PP or PED to '0'. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.5.1 of xHCI specification. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t OCC         :1;                 /* Over-current Change (OCC), RW1CS. Default = '0'. This bit shall be set to a '1' when there is a '0' to '1' or '1' to '0' transition of Over-current Active (OCA). Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t PRC         :1;                 /* Port Reset Change (PRC), RW1CS. Default = '0'. This flag is set to '1' due to a '1' to '0' transition of Port Reset (PR), e.g. when any reset processing (Warm or Hot) on this port is complete. Note that this flag shall not be set to '1' if the reset processing was forced to terminate due to software clearing PP or PED to '0'. '0' = No change. '1' = Reset complete. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.5 of xHCI specification. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t PLC         :1;                 /* Port Link State Change (PLC), RW1CS. Default = '0'. This flag is set to '1' due to the following PLS transitions: U3 -> Resume (Wakeup signaling from a device), Resume -> Recovery -> U0 (Device Resume complete (USB3 protocol ports only)), Resume -> U0 (Device Resume complete (USB2 protocol ports only)), U3 -> Recovery -> U0 (Software Resume complete (USB3 protocol ports only)), U3 -> U0 (Software Resume complete (USB2 protocol ports only)), U2 -> U0 (L1 Resume complete (USB2 protocol ports only)), U0 -> U0 (L1 Entry Reject (USB2 protocol ports only)), Any state -> Inactive (Error (USB3 protocol ports only)). Note that this flag shall not be set if the PLS transition was due to software setting PP to 0. Refer to section 4.23.5 of xHCI specification for more information. '0' = No change. '1' = Link Status Changed. Software shall clear this bit by writing a '1' to it. Refer to PLC Condition: references in section 4.19.1 for the specific port state transitions that set this flag. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t CEC         :1;                 /* Port Config Error Change (CEC), RW1CS. Default = '0'. This flag indicates that the port failed to configure its link partner. '0' = No change. '1' = Port Config Error detected. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
        uint32_t CAS         :1;                 /* Cold Attach Status (CAS), RO. Default = '0'. '1' = Far-end Receiver Terminations were detected in the Disconnected state and the Root Hub Port State Machine was unable to advance to the Enabled state. Refer to sections 4.19.8 of xHCI specification for more details on the Cold Attach Status (CAS) assertion conditions. Software shall clear this bit by writing a '1' to WPR or the xHC shall clear this bit if CCS transitions to '1'. This flag is 0 if PP is 0 or for USB2 protocol ports. Note: Additionally to the xHCI spec the CAS may be set in D1/D2 state. If customer's PLL lock time ensures finishing LFPS in tPollingLFPSTimeout (360ms) the SW driver may ignore the CAS and wait for PORTSC.CCS. It prevents additional reset on USB port. However, handling CAS in normal way should not have any negative impact on the device. */
        uint32_t WCE         :1;                 /* Wake on Connect Enable (WCE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to device connects as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
        uint32_t WDE         :1;                 /* Wake on Disconnect Enable (WDE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to device disconnects as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
        uint32_t WOE         :1;                 /* Wake on Over-current Enable (WOE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to over-current conditions as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
        uint32_t _unused28   :2;                 /* Reserved */
        uint32_t DR          :1;                 /* Device Removable (DR), RO. This flag indicates if this port has a removable device attached. '0' = Device is removable; '1' = Device is non-removable. */
        uint32_t WPR         :1;                 /* Warm Port Reset (WPR), RW1S. Default = '0'. When software writes a '1' to this bit, the Warm Reset sequence as defined in the USB3 Specification is initiated and the PR flag is set to '1'. Once initiated, the PR, PRC, and WRC flags shall reflect the progress of the Warm Reset sequence. This flag shall always return 0 when read. Refer to section 4.19.5.1 of xHCI specification. */
    } B;
} IMX_USB3_USBSS_PORTSC1USB3_t;

/* Register PORTSC1USB3 - Port Status and Control Register for USB3 protocol port. */
#define IMX_USB3_USBSS_PORTSC1USB3_OFFSET 0x10490
/* Field CCS - Current Connect Status (CCS), ROS. Default = '0'. '1' = A device is connected to the port. '0' = A device is not connected. This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change (CSC) bit to be set to '1'. Refer to sections 4.19.3 and 4.19.4 of xHCI specification for more details on the Connect Status Change (CSC) assertion conditions. This flag is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTSC1USB3_CCS_SHIFT 0
#define IMX_USB3_USBSS_PORTSC1USB3_CCS_MASK 0x1
#define IMX_USB3_USBSS_PORTSC1USB3_CCS(v) (((v) << 0) & 0x1)
/* Field PED - Port Enabled/Disabled (PED), RW1CS. Default = '0'. '1' = Enabled. '0' = Disabled. Ports may only be enabled by the xHC. Software cannot enable a port by writing a '1' to this flag. A port may be disabled by software writing a '1' to this flag. This flag shall automatically be cleared to '0' by a disconnect event or other fault condition. Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller or bus events. When the port is disabled (PED = '0') downstream propagation of data is blocked on this port, except for reset. When the port is in the Polling state (after detecting an attach), the port shall automatically transition to the Enabled state and set PED to '1' upon the completion of successful link training. When the port is in the Disabled state, software shall write a 5 (RxDetect) to the PLS field to transition the port to the Disconnected state. Refer to section 4.19.1.2 of xHCI specification. PED shall automatically be cleared to '0' when PR is set to '1', and set to '1' when PR transitions from '1' to '0' after a successful reset. Refer to Port Reset (PR) bit for more information on how the PED bit is managed. Note that when software writes this bit to a '1', it shall also write a '0' to the PR bit. This flag is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTSC1USB3_PED_SHIFT 1
#define IMX_USB3_USBSS_PORTSC1USB3_PED_MASK 0x2
#define IMX_USB3_USBSS_PORTSC1USB3_PED(v) (((v) << 0x1) & 0x2)
/* Field OCA - Over-current Active (OCA), RO. Default = '0'. '1' = This port currently has an over-current condition. '0' = This port does not have an over-current condition. This bit shall automatically transition from a '1' to a '0' when the over-current condition is removed. */
#define IMX_USB3_USBSS_PORTSC1USB3_OCA_SHIFT 3
#define IMX_USB3_USBSS_PORTSC1USB3_OCA_MASK 0x8
#define IMX_USB3_USBSS_PORTSC1USB3_OCA(v) (((v) << 0x3) & 0x8)
/* Field PR - Port Reset (PR), RW1S. Default = '0'. '1' = Port Reset signaling is asserted. '0' = Port is not in Reset. When software writes a '1' to this bit generating a '0' to '1' transition, the bus reset sequence is initiated; USB3 protocol ports shall execute the Hot Reset sequence as defined in the USB3 Spec. PR remains set until reset signaling is completed by the root hub. This flag is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTSC1USB3_PR_SHIFT 4
#define IMX_USB3_USBSS_PORTSC1USB3_PR_MASK 0x10
#define IMX_USB3_USBSS_PORTSC1USB3_PR(v) (((v) << 0x4) & 0x10)
/* Field PLS - Port Link State (PLS), RWS. Default = RxDetect ('5'). This field is used to power manage the port and reflects its current link state. When the port is in the Enabled state, system software may set the link U state by writing this field. System software may also write this field to force a Disabled to Disconnected state transition of the port. Write Values: 0: The link shall transition to a U0 state from any of the U states. 3: The link shall transition to a U3 state from the U0 state. This action selectively suspends the device connected to this port. While the Port Link State = U3, the hub does not propagate downstream-directed traffic to this port, but the hub shall respond to resume signaling from the port. 5: If the port is in the Disabled state (PLS = Disabled, PP = '1'), then the link shall transition to a RxDetect state and the port shall transition to the Disconnected state, else ignored. 1-2,4,6-15: Ignored. State Encoding: 0: Link is in the U0 State, 1: Link is in the U1 State, 2: Link is in the U2 State, 3: Link is in the U3 State (Device Suspended), 4: Link is in the Disabled State, 5: Link is in the RxDetect State, 6: Link is in the Inactive State, 7: Link is in the Polling State, 8: Link is in the Recovery State, 9: Link is in the Hot Reset State, 10 Link is in the Compliance Mode State, 11: Link is in the Test Mode State, 12-14: Reserved, 15: Link is in the Resume State. Note: The Port Link State Write Strobe (LWS) shall also be set to '1' to write this field. This field is undefined if PP = '0'. Note: Transitions between different states are not reflected until the transition is complete. Refer to section 4.19 of xHCI specification for PLS transition conditions. Refer to sections 4.15.2 and 4.23.5 for more information on the use of this field. */
#define IMX_USB3_USBSS_PORTSC1USB3_PLS_SHIFT 5
#define IMX_USB3_USBSS_PORTSC1USB3_PLS_MASK 0x1E0
#define IMX_USB3_USBSS_PORTSC1USB3_PLS(v) (((v) << 0x5) & 0x1E0)
/* Field PP - Port Power (PP), RWS. Default = '1'. This flag reflects a port's logical, power control state. Because host controllers can implement different methods of port power switching, this flag may or may not represent whether (VBus) power is actually applied to the port. When PP equals a '0' the port is nonfunctional and shall not report attaches, detaches, or Port Link State (PLS) changes. However, the port shall report over-current conditions when PP = '0' if PPC = '0'. After modifying PP, software shall read PP and confirm that it has reached its target state before modifying it again, undefined behavior may occur if this procedure is not followed. '0' = This port is in the Powered-off state. '1' = This port is not in the Powered-off state. If the Port Power Control (PPC) flag in the HCCPARAMS register is '1', then xHC has port power control switches and this bit represents the current setting of the switch ('0' = off, '1'=on). If the Port Power Control (PPC) flag in the HCCPARAMS register is '0', then xHC does not have port power control switches and each port is hard wired to power, and not affected by this bit. When an over-current condition is detected on a powered port, the xHC shall transition the PP bit in each affected port from a '1' to '0' (removing power from the port). Refer to section 4.19.4 for more information. */
#define IMX_USB3_USBSS_PORTSC1USB3_PP_SHIFT 9
#define IMX_USB3_USBSS_PORTSC1USB3_PP_MASK 0x200
#define IMX_USB3_USBSS_PORTSC1USB3_PP(v) (((v) << 0x9) & 0x200)
/* Field PORTSPEED - Port Speed (Port Speed), ROS. Default = '0'. This field identifies the speed of the connected USB Device. This field is only relevant if a device is connected (CCS = '1') in all other cases this field shall indicate Undefined Speed. Possible values: 0: Undefined Speed 1-15: Protocol Speed ID (PSI), refer to section 7.2.1 of xHCI specification for the definition of PSIV field in the PSI Dword. */
#define IMX_USB3_USBSS_PORTSC1USB3_PORTSPEED_SHIFT 10
#define IMX_USB3_USBSS_PORTSC1USB3_PORTSPEED_MASK 0x3C00
#define IMX_USB3_USBSS_PORTSC1USB3_PORTSPEED(v) (((v) << 0xA) & 0x3C00)
/* Field PIC - Port Indicator Control (PIC), RWS. Default = '0'. Writing to these bits has no effect if the Port Indicators (PIND) bit in the HCCPARAMS register is a '0'. If PIND bit is a '1', then the bit encodings are: 0: Port indicators are off, 1: Amber, 2: Green, 3: Undefined. This field is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTSC1USB3_PIC_SHIFT 14
#define IMX_USB3_USBSS_PORTSC1USB3_PIC_MASK 0xC000
#define IMX_USB3_USBSS_PORTSC1USB3_PIC(v) (((v) << 0xE) & 0xC000)
/* Field LWS - Port Link State Write Strobe (LWS), RW. Default = '0'. When this bit is set to '1' on a write reference to this register, this flag enables writes to the PLS field. When '0', write data in PLS field is ignored. Reads to this bit return '0'. */
#define IMX_USB3_USBSS_PORTSC1USB3_LWS_SHIFT 16
#define IMX_USB3_USBSS_PORTSC1USB3_LWS_MASK 0x10000
#define IMX_USB3_USBSS_PORTSC1USB3_LWS(v) (((v) << 0x10) & 0x10000)
/* Field CSC - Connect Status Change (CSC), RW1CS. Default = '0'. '1' = Change in CCS. '0' = No change. This flag indicates a change has occurred in the ports Current Connect Status (CCS) or Cold Attach Status (CAS) bits. Note that this flag shall not be set if the CCS transition was due to software setting PP to '0', or the CAS transition was due to software setting WPR to '1'. The xHC sets this bit to '1' for all changes to the port device connect status, even if system software has not cleared an existing Connect Status Change. For example, the insertion status changes twice before system software has cleared the changed condition, root hub hardware will be setting an already-set bit (i.e., the bit will remain 1). Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB3_CSC_SHIFT 17
#define IMX_USB3_USBSS_PORTSC1USB3_CSC_MASK 0x20000
#define IMX_USB3_USBSS_PORTSC1USB3_CSC(v) (((v) << 0x11) & 0x20000)
/* Field PEC - Port Enabled/Disabled Change (PEC), RW1CS. Default = '0'. '1' = change in PED. '0' = No change. Note that this flag shall not be set if the PED transition was due to software setting PP to '0'. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. This bit shall never be set to '1'. */
#define IMX_USB3_USBSS_PORTSC1USB3_PEC_SHIFT 18
#define IMX_USB3_USBSS_PORTSC1USB3_PEC_MASK 0x40000
#define IMX_USB3_USBSS_PORTSC1USB3_PEC(v) (((v) << 0x12) & 0x40000)
/* Field WRC - Warm Port Reset Change (WRC), RW1CS. Default = '0'. This bit is set when Warm Reset processing on this port completes. '0' = No change. '1' = Warm Reset complete. Note that this flag shall not be set to '1' if the Warm Reset processing was forced to terminate due to software clearing PP or PED to '0'. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.5.1 of xHCI specification. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB3_WRC_SHIFT 19
#define IMX_USB3_USBSS_PORTSC1USB3_WRC_MASK 0x80000
#define IMX_USB3_USBSS_PORTSC1USB3_WRC(v) (((v) << 0x13) & 0x80000)
/* Field OCC - Over-current Change (OCC), RW1CS. Default = '0'. This bit shall be set to a '1' when there is a '0' to '1' or '1' to '0' transition of Over-current Active (OCA). Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB3_OCC_SHIFT 20
#define IMX_USB3_USBSS_PORTSC1USB3_OCC_MASK 0x100000
#define IMX_USB3_USBSS_PORTSC1USB3_OCC(v) (((v) << 0x14) & 0x100000)
/* Field PRC - Port Reset Change (PRC), RW1CS. Default = '0'. This flag is set to '1' due to a '1' to '0' transition of Port Reset (PR), e.g. when any reset processing (Warm or Hot) on this port is complete. Note that this flag shall not be set to '1' if the reset processing was forced to terminate due to software clearing PP or PED to '0'. '0' = No change. '1' = Reset complete. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.5 of xHCI specification. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB3_PRC_SHIFT 21
#define IMX_USB3_USBSS_PORTSC1USB3_PRC_MASK 0x200000
#define IMX_USB3_USBSS_PORTSC1USB3_PRC(v) (((v) << 0x15) & 0x200000)
/* Field PLC - Port Link State Change (PLC), RW1CS. Default = '0'. This flag is set to '1' due to the following PLS transitions: U3 -> Resume (Wakeup signaling from a device), Resume -> Recovery -> U0 (Device Resume complete (USB3 protocol ports only)), Resume -> U0 (Device Resume complete (USB2 protocol ports only)), U3 -> Recovery -> U0 (Software Resume complete (USB3 protocol ports only)), U3 -> U0 (Software Resume complete (USB2 protocol ports only)), U2 -> U0 (L1 Resume complete (USB2 protocol ports only)), U0 -> U0 (L1 Entry Reject (USB2 protocol ports only)), Any state -> Inactive (Error (USB3 protocol ports only)). Note that this flag shall not be set if the PLS transition was due to software setting PP to 0. Refer to section 4.23.5 of xHCI specification for more information. '0' = No change. '1' = Link Status Changed. Software shall clear this bit by writing a '1' to it. Refer to PLC Condition: references in section 4.19.1 for the specific port state transitions that set this flag. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB3_PLC_SHIFT 22
#define IMX_USB3_USBSS_PORTSC1USB3_PLC_MASK 0x400000
#define IMX_USB3_USBSS_PORTSC1USB3_PLC(v) (((v) << 0x16) & 0x400000)
/* Field CEC - Port Config Error Change (CEC), RW1CS. Default = '0'. This flag indicates that the port failed to configure its link partner. '0' = No change. '1' = Port Config Error detected. Software shall clear this bit by writing a '1' to it. Refer to section 4.19.2 of xHCI specification for more information on change bit usage. */
#define IMX_USB3_USBSS_PORTSC1USB3_CEC_SHIFT 23
#define IMX_USB3_USBSS_PORTSC1USB3_CEC_MASK 0x800000
#define IMX_USB3_USBSS_PORTSC1USB3_CEC(v) (((v) << 0x17) & 0x800000)
/* Field CAS - Cold Attach Status (CAS), RO. Default = '0'. '1' = Far-end Receiver Terminations were detected in the Disconnected state and the Root Hub Port State Machine was unable to advance to the Enabled state. Refer to sections 4.19.8 of xHCI specification for more details on the Cold Attach Status (CAS) assertion conditions. Software shall clear this bit by writing a '1' to WPR or the xHC shall clear this bit if CCS transitions to '1'. This flag is 0 if PP is 0 or for USB2 protocol ports. Note: Additionally to the xHCI spec the CAS may be set in D1/D2 state. If customer's PLL lock time ensures finishing LFPS in tPollingLFPSTimeout (360ms) the SW driver may ignore the CAS and wait for PORTSC.CCS. It prevents additional reset on USB port. However, handling CAS in normal way should not have any negative impact on the device. */
#define IMX_USB3_USBSS_PORTSC1USB3_CAS_SHIFT 24
#define IMX_USB3_USBSS_PORTSC1USB3_CAS_MASK 0x1000000
#define IMX_USB3_USBSS_PORTSC1USB3_CAS(v) (((v) << 0x18) & 0x1000000)
/* Field WCE - Wake on Connect Enable (WCE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to device connects as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
#define IMX_USB3_USBSS_PORTSC1USB3_WCE_SHIFT 25
#define IMX_USB3_USBSS_PORTSC1USB3_WCE_MASK 0x2000000
#define IMX_USB3_USBSS_PORTSC1USB3_WCE(v) (((v) << 0x19) & 0x2000000)
/* Field WDE - Wake on Disconnect Enable (WDE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to device disconnects as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
#define IMX_USB3_USBSS_PORTSC1USB3_WDE_SHIFT 26
#define IMX_USB3_USBSS_PORTSC1USB3_WDE_MASK 0x4000000
#define IMX_USB3_USBSS_PORTSC1USB3_WDE(v) (((v) << 0x1A) & 0x4000000)
/* Field WOE - Wake on Over-current Enable (WOE), RWS. Default = '0'. Writing this bit to a '1' enables the port to be sensitive to over-current conditions as system wake-up events. Refer to section 4.15 of xHCI specification for operational model. */
#define IMX_USB3_USBSS_PORTSC1USB3_WOE_SHIFT 27
#define IMX_USB3_USBSS_PORTSC1USB3_WOE_MASK 0x8000000
#define IMX_USB3_USBSS_PORTSC1USB3_WOE(v) (((v) << 0x1B) & 0x8000000)
/* Field DR - Device Removable (DR), RO. This flag indicates if this port has a removable device attached. '0' = Device is removable; '1' = Device is non-removable. */
#define IMX_USB3_USBSS_PORTSC1USB3_DR_SHIFT 30
#define IMX_USB3_USBSS_PORTSC1USB3_DR_MASK 0x40000000
#define IMX_USB3_USBSS_PORTSC1USB3_DR(v) (((v) << 0x1E) & 0x40000000)
/* Field WPR - Warm Port Reset (WPR), RW1S. Default = '0'. When software writes a '1' to this bit, the Warm Reset sequence as defined in the USB3 Specification is initiated and the PR flag is set to '1'. Once initiated, the PR, PRC, and WRC flags shall reflect the progress of the Warm Reset sequence. This flag shall always return 0 when read. Refer to section 4.19.5.1 of xHCI specification. */
#define IMX_USB3_USBSS_PORTSC1USB3_WPR_SHIFT 31
#define IMX_USB3_USBSS_PORTSC1USB3_WPR_MASK 0x80000000
#define IMX_USB3_USBSS_PORTSC1USB3_WPR(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_PORTPMSC1USB3 - USB3 Port Power Management Status and Control register. */
typedef union IMX_USB3_USBSS_PORTPMSC1USB3_union_t {
    uint32_t R;
    struct {
        uint32_t U1_TIMEOUT  :8;                 /* U1 Timeout, RWS. Default = 0. Timeout value for U1 inactivity timer. If equal to FFh, the port is disabled from initiating U1 entry. This field shall be set to '0' by the assertion of PR to '1'. Refer to section 4.19.4.1 of xHCI specification for more information on U1 Timeout operation. The following are permissible values: 00h Zero (default) 01h 1 us. 02h 2 us. ... 7Fh 127 us. 80h - FEh Reserved FFh Infinite */
        uint32_t U2_TIMEOUT  :8;                 /* U2 Timeout, RWS. Default = 0. Timeout value for U2 inactivity timer. If equal to FFh, the port is disabled from initiating U2 entry. This field shall be set to '0' by the assertion of PR to '1'. Refer to section 4.19.4.1 of xHCI specification for more information on U2 Timeout operation. The following are permissible values: 00h Zero (default) 01h 256 us 02h 512 us ... FEh 65,.024 ms FFh Infinite A U2 Inactivity Timeout LMP shall be sent by the xHC to the device connected on this port when this field is written. Refer to Sections 8.4.3 and 10.4.2.10 of the USB3 specification for more details. */
        uint32_t FLA         :1;                 /* Force Link PM Accept (FLA), RW. Default = '0'. When this bit is set to '1', the port shall generate a Set Link Function LMP with the Force_LinkPM_Accept bit asserted ('1'). When this bit is cleared to '0', the port shall generate a Set Link Function LMP with the Force_LinkPM_Accept bit de-asserted ('0'). This flag shall be set to '0' by the assertion of PR to '1' or when CCS = transitions from '0' to '1'. Writes to this flag have no effect if PP = '0'. The Set Link Function LMP is sent by the xHC to the device connected on this port when this bit transitions from '0' to '1' or '1' to '0'. Refer to Sections 8.4.2 and 10.14.2.2 of the USB3 specification for more details. Improper use of the SS Force_LinkPM_Accept functionality can impact the performance of the link significantly. This bit shall only be used for compliance and testing purposes. Software shall ensure that there are no pending packets at the link level before setting this bit. This flag is '0' if PP is '0'. */
        uint32_t _unused17   :15;                /* Reserved */
    } B;
} IMX_USB3_USBSS_PORTPMSC1USB3_t;

/* Register PORTPMSC1USB3 - USB3 Port Power Management Status and Control register. */
#define IMX_USB3_USBSS_PORTPMSC1USB3_OFFSET 0x10494
/* Field U1_TIMEOUT - U1 Timeout, RWS. Default = 0. Timeout value for U1 inactivity timer. If equal to FFh, the port is disabled from initiating U1 entry. This field shall be set to '0' by the assertion of PR to '1'. Refer to section 4.19.4.1 of xHCI specification for more information on U1 Timeout operation. The following are permissible values: 00h Zero (default) 01h 1 us. 02h 2 us. ... 7Fh 127 us. 80h - FEh Reserved FFh Infinite */
#define IMX_USB3_USBSS_PORTPMSC1USB3_U1_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_PORTPMSC1USB3_U1_TIMEOUT_MASK 0xFF
#define IMX_USB3_USBSS_PORTPMSC1USB3_U1_TIMEOUT(v) (((v) << 0) & 0xFF)
/* Field U2_TIMEOUT - U2 Timeout, RWS. Default = 0. Timeout value for U2 inactivity timer. If equal to FFh, the port is disabled from initiating U2 entry. This field shall be set to '0' by the assertion of PR to '1'. Refer to section 4.19.4.1 of xHCI specification for more information on U2 Timeout operation. The following are permissible values: 00h Zero (default) 01h 256 us 02h 512 us ... FEh 65,.024 ms FFh Infinite A U2 Inactivity Timeout LMP shall be sent by the xHC to the device connected on this port when this field is written. Refer to Sections 8.4.3 and 10.4.2.10 of the USB3 specification for more details. */
#define IMX_USB3_USBSS_PORTPMSC1USB3_U2_TIMEOUT_SHIFT 8
#define IMX_USB3_USBSS_PORTPMSC1USB3_U2_TIMEOUT_MASK 0xFF00
#define IMX_USB3_USBSS_PORTPMSC1USB3_U2_TIMEOUT(v) (((v) << 0x8) & 0xFF00)
/* Field FLA - Force Link PM Accept (FLA), RW. Default = '0'. When this bit is set to '1', the port shall generate a Set Link Function LMP with the Force_LinkPM_Accept bit asserted ('1'). When this bit is cleared to '0', the port shall generate a Set Link Function LMP with the Force_LinkPM_Accept bit de-asserted ('0'). This flag shall be set to '0' by the assertion of PR to '1' or when CCS = transitions from '0' to '1'. Writes to this flag have no effect if PP = '0'. The Set Link Function LMP is sent by the xHC to the device connected on this port when this bit transitions from '0' to '1' or '1' to '0'. Refer to Sections 8.4.2 and 10.14.2.2 of the USB3 specification for more details. Improper use of the SS Force_LinkPM_Accept functionality can impact the performance of the link significantly. This bit shall only be used for compliance and testing purposes. Software shall ensure that there are no pending packets at the link level before setting this bit. This flag is '0' if PP is '0'. */
#define IMX_USB3_USBSS_PORTPMSC1USB3_FLA_SHIFT 16
#define IMX_USB3_USBSS_PORTPMSC1USB3_FLA_MASK 0x10000
#define IMX_USB3_USBSS_PORTPMSC1USB3_FLA(v) (((v) << 0x10) & 0x10000)

/* IMX_USB3_USBSS_PORTLI1 - The USB3 Port Link Info register reports the Link Error Count. */
typedef union IMX_USB3_USBSS_PORTLI1_union_t {
    uint32_t R;
    struct {
        uint32_t LEC         :16;                /* Link Error Count, RO. Default = '0'. This field returns the number of link errors detected by the port. This value shall be reset to '0' by the assertion of a Chip Hardware Reset, HCRST, when PR transitions from 1 to 0, or when CCS = transitions from '0' to '1'. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_PORTLI1_t;

/* Register PORTLI1 - The USB3 Port Link Info register reports the Link Error Count. */
#define IMX_USB3_USBSS_PORTLI1_OFFSET 0x10498
/* Field LEC - Link Error Count, RO. Default = '0'. This field returns the number of link errors detected by the port. This value shall be reset to '0' by the assertion of a Chip Hardware Reset, HCRST, when PR transitions from 1 to 0, or when CCS = transitions from '0' to '1'. */
#define IMX_USB3_USBSS_PORTLI1_LEC_SHIFT 0
#define IMX_USB3_USBSS_PORTLI1_LEC_MASK 0xFFFF
#define IMX_USB3_USBSS_PORTLI1_LEC(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_MFINDEX - This register is used by the system software to determine the current periodic frame. */
typedef union IMX_USB3_USBSS_MFINDEX_union_t {
    uint32_t R;
    struct {
        uint32_t MFINDEX     :14;                /* Microframe Index, RO. The value in this register increments at the end of each microframe (e.g. 125us.). Bits [13:3] may be used to determine the current 1ms Frame Index. Note: Setting frindex_wr_en to '1' (bit 31 of XECP_CMDM_CTRL_REG3) enables software writes to this field. */
        uint32_t _unused14   :18;                /* Reserved */
    } B;
} IMX_USB3_USBSS_MFINDEX_t;

/* Register MFINDEX - This register is used by the system software to determine the current periodic frame. */
#define IMX_USB3_USBSS_MFINDEX_OFFSET 0x12000
/* Field MFINDEX - Microframe Index, RO. The value in this register increments at the end of each microframe (e.g. 125us.). Bits [13:3] may be used to determine the current 1ms Frame Index. Note: Setting frindex_wr_en to '1' (bit 31 of XECP_CMDM_CTRL_REG3) enables software writes to this field. */
#define IMX_USB3_USBSS_MFINDEX_MFINDEX_SHIFT 0
#define IMX_USB3_USBSS_MFINDEX_MFINDEX_MASK 0x3FFF
#define IMX_USB3_USBSS_MFINDEX_MFINDEX(v) (((v) << 0) & 0x3FFF)

/* IMX_USB3_USBSS_IMAN0 - Interrupter Management Register (IMAN). */
typedef union IMX_USB3_USBSS_IMAN0_union_t {
    uint32_t R;
    struct {
        uint32_t IP          :1;                 /* Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
        uint32_t IE          :1;                 /* Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
        uint32_t _unused2    :30;                /* Reserved */
    } B;
} IMX_USB3_USBSS_IMAN0_t;

/* Register IMAN0 - Interrupter Management Register (IMAN). */
#define IMX_USB3_USBSS_IMAN0_OFFSET 0x12020
/* Field IP - Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
#define IMX_USB3_USBSS_IMAN0_IP_SHIFT 0
#define IMX_USB3_USBSS_IMAN0_IP_MASK 0x1
#define IMX_USB3_USBSS_IMAN0_IP(v) (((v) << 0) & 0x1)
/* Field IE - Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
#define IMX_USB3_USBSS_IMAN0_IE_SHIFT 1
#define IMX_USB3_USBSS_IMAN0_IE_MASK 0x2
#define IMX_USB3_USBSS_IMAN0_IE(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_IMOD0 - Interrupter Moderation Register (IMOD). */
typedef union IMX_USB3_USBSS_IMOD0_union_t {
    uint32_t R;
    struct {
        uint32_t IMODI       :16;                /* Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
        uint32_t IMODC       :16;                /* Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
    } B;
} IMX_USB3_USBSS_IMOD0_t;

/* Register IMOD0 - Interrupter Moderation Register (IMOD). */
#define IMX_USB3_USBSS_IMOD0_OFFSET 0x12024
/* Field IMODI - Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
#define IMX_USB3_USBSS_IMOD0_IMODI_SHIFT 0
#define IMX_USB3_USBSS_IMOD0_IMODI_MASK 0xFFFF
#define IMX_USB3_USBSS_IMOD0_IMODI(v) (((v) << 0) & 0xFFFF)
/* Field IMODC - Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
#define IMX_USB3_USBSS_IMOD0_IMODC_SHIFT 16
#define IMX_USB3_USBSS_IMOD0_IMODC_MASK 0xFFFF0000
#define IMX_USB3_USBSS_IMOD0_IMODC(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_ERSTSZ0 - Event Ring Segment Table Size Register (ERSTSZ). */
typedef union IMX_USB3_USBSS_ERSTSZ0_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTS       :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_ERSTSZ0_t;

/* Register ERSTSZ0 - Event Ring Segment Table Size Register (ERSTSZ). */
#define IMX_USB3_USBSS_ERSTSZ0_OFFSET 0x12028
/* Field ERSTS - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
#define IMX_USB3_USBSS_ERSTSZ0_ERSTS_SHIFT 0
#define IMX_USB3_USBSS_ERSTSZ0_ERSTS_MASK 0xFFFF
#define IMX_USB3_USBSS_ERSTSZ0_ERSTS(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_RESERVED0 -  */
typedef union IMX_USB3_USBSS_RESERVED0_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_RESERVED0_t;

/* Register RESERVED0 -  */
#define IMX_USB3_USBSS_RESERVED0_OFFSET 0x1202C

/* IMX_USB3_USBSS_ERSTBA0_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA0_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t ERSTBADDR_LO :26;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA0_LO_t;

/* Register ERSTBA0_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA0_LO_OFFSET 0x12030
/* Field ERSTBADDR_LO - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA0_LO_ERSTBADDR_LO_SHIFT 6
#define IMX_USB3_USBSS_ERSTBA0_LO_ERSTBADDR_LO_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_ERSTBA0_LO_ERSTBADDR_LO(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_ERSTBA0_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA0_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBADDR_HI :32;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA0_HI_t;

/* Register ERSTBA0_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA0_HI_OFFSET 0x12034
/* Field ERSTBADDR_HI - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA0_HI_ERSTBADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERSTBA0_HI_ERSTBADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERSTBA0_HI_ERSTBADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_ERDP0_LO - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP0_LO_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t EHB         :1;                 /* Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
        uint32_t ERDPTR      :28;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP0_LO_t;

/* Register ERDP0_LO - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP0_LO_OFFSET 0x12038
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_ERDP0_LO_DESI_SHIFT 0
#define IMX_USB3_USBSS_ERDP0_LO_DESI_MASK 0x7
#define IMX_USB3_USBSS_ERDP0_LO_DESI(v) (((v) << 0) & 0x7)
/* Field EHB - Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
#define IMX_USB3_USBSS_ERDP0_LO_EHB_SHIFT 3
#define IMX_USB3_USBSS_ERDP0_LO_EHB_MASK 0x8
#define IMX_USB3_USBSS_ERDP0_LO_EHB(v) (((v) << 0x3) & 0x8)
/* Field ERDPTR - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP0_LO_ERDPTR_SHIFT 4
#define IMX_USB3_USBSS_ERDP0_LO_ERDPTR_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_ERDP0_LO_ERDPTR(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_ERDP0_HI - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP0_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERDPTR_HI   :32;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP0_HI_t;

/* Register ERDP0_HI - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP0_HI_OFFSET 0x1203C
/* Field ERDPTR_HI - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP0_HI_ERDPTR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERDP0_HI_ERDPTR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERDP0_HI_ERDPTR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_IMAN1 - Interrupter Management Register (IMAN). */
typedef union IMX_USB3_USBSS_IMAN1_union_t {
    uint32_t R;
    struct {
        uint32_t IP          :1;                 /* Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
        uint32_t IE          :1;                 /* Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
        uint32_t _unused2    :30;                /* Reserved */
    } B;
} IMX_USB3_USBSS_IMAN1_t;

/* Register IMAN1 - Interrupter Management Register (IMAN). */
#define IMX_USB3_USBSS_IMAN1_OFFSET 0x12040
/* Field IP - Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
#define IMX_USB3_USBSS_IMAN1_IP_SHIFT 0
#define IMX_USB3_USBSS_IMAN1_IP_MASK 0x1
#define IMX_USB3_USBSS_IMAN1_IP(v) (((v) << 0) & 0x1)
/* Field IE - Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
#define IMX_USB3_USBSS_IMAN1_IE_SHIFT 1
#define IMX_USB3_USBSS_IMAN1_IE_MASK 0x2
#define IMX_USB3_USBSS_IMAN1_IE(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_IMOD1 - Interrupter Moderation Register (IMOD). */
typedef union IMX_USB3_USBSS_IMOD1_union_t {
    uint32_t R;
    struct {
        uint32_t IMODI       :16;                /* Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
        uint32_t IMODC       :16;                /* Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
    } B;
} IMX_USB3_USBSS_IMOD1_t;

/* Register IMOD1 - Interrupter Moderation Register (IMOD). */
#define IMX_USB3_USBSS_IMOD1_OFFSET 0x12044
/* Field IMODI - Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
#define IMX_USB3_USBSS_IMOD1_IMODI_SHIFT 0
#define IMX_USB3_USBSS_IMOD1_IMODI_MASK 0xFFFF
#define IMX_USB3_USBSS_IMOD1_IMODI(v) (((v) << 0) & 0xFFFF)
/* Field IMODC - Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
#define IMX_USB3_USBSS_IMOD1_IMODC_SHIFT 16
#define IMX_USB3_USBSS_IMOD1_IMODC_MASK 0xFFFF0000
#define IMX_USB3_USBSS_IMOD1_IMODC(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_ERSTSZ1 - Event Ring Segment Table Size Register (ERSTSZ). */
typedef union IMX_USB3_USBSS_ERSTSZ1_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTS       :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_ERSTSZ1_t;

/* Register ERSTSZ1 - Event Ring Segment Table Size Register (ERSTSZ). */
#define IMX_USB3_USBSS_ERSTSZ1_OFFSET 0x12048
/* Field ERSTS - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
#define IMX_USB3_USBSS_ERSTSZ1_ERSTS_SHIFT 0
#define IMX_USB3_USBSS_ERSTSZ1_ERSTS_MASK 0xFFFF
#define IMX_USB3_USBSS_ERSTSZ1_ERSTS(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_RESERVED1 -  */
typedef union IMX_USB3_USBSS_RESERVED1_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_RESERVED1_t;

/* Register RESERVED1 -  */
#define IMX_USB3_USBSS_RESERVED1_OFFSET 0x1204C

/* IMX_USB3_USBSS_ERSTBA1_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA1_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t ERSTBADDR_LO :26;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA1_LO_t;

/* Register ERSTBA1_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA1_LO_OFFSET 0x12050
/* Field ERSTBADDR_LO - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA1_LO_ERSTBADDR_LO_SHIFT 6
#define IMX_USB3_USBSS_ERSTBA1_LO_ERSTBADDR_LO_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_ERSTBA1_LO_ERSTBADDR_LO(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_ERSTBA1_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA1_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBADDR_HI :32;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA1_HI_t;

/* Register ERSTBA1_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA1_HI_OFFSET 0x12054
/* Field ERSTBADDR_HI - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA1_HI_ERSTBADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERSTBA1_HI_ERSTBADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERSTBA1_HI_ERSTBADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_ERDP1_LO - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP1_LO_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t EHB         :1;                 /* Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
        uint32_t ERDPTR      :28;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP1_LO_t;

/* Register ERDP1_LO - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP1_LO_OFFSET 0x12058
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_ERDP1_LO_DESI_SHIFT 0
#define IMX_USB3_USBSS_ERDP1_LO_DESI_MASK 0x7
#define IMX_USB3_USBSS_ERDP1_LO_DESI(v) (((v) << 0) & 0x7)
/* Field EHB - Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
#define IMX_USB3_USBSS_ERDP1_LO_EHB_SHIFT 3
#define IMX_USB3_USBSS_ERDP1_LO_EHB_MASK 0x8
#define IMX_USB3_USBSS_ERDP1_LO_EHB(v) (((v) << 0x3) & 0x8)
/* Field ERDPTR - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP1_LO_ERDPTR_SHIFT 4
#define IMX_USB3_USBSS_ERDP1_LO_ERDPTR_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_ERDP1_LO_ERDPTR(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_ERDP1_HI - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP1_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERDPTR_HI   :32;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP1_HI_t;

/* Register ERDP1_HI - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP1_HI_OFFSET 0x1205C
/* Field ERDPTR_HI - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP1_HI_ERDPTR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERDP1_HI_ERDPTR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERDP1_HI_ERDPTR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_IMAN2 - Interrupter Management Register (IMAN). */
typedef union IMX_USB3_USBSS_IMAN2_union_t {
    uint32_t R;
    struct {
        uint32_t IP          :1;                 /* Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
        uint32_t IE          :1;                 /* Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
        uint32_t _unused2    :30;                /* Reserved */
    } B;
} IMX_USB3_USBSS_IMAN2_t;

/* Register IMAN2 - Interrupter Management Register (IMAN). */
#define IMX_USB3_USBSS_IMAN2_OFFSET 0x12060
/* Field IP - Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
#define IMX_USB3_USBSS_IMAN2_IP_SHIFT 0
#define IMX_USB3_USBSS_IMAN2_IP_MASK 0x1
#define IMX_USB3_USBSS_IMAN2_IP(v) (((v) << 0) & 0x1)
/* Field IE - Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
#define IMX_USB3_USBSS_IMAN2_IE_SHIFT 1
#define IMX_USB3_USBSS_IMAN2_IE_MASK 0x2
#define IMX_USB3_USBSS_IMAN2_IE(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_IMOD2 - Interrupter Moderation Register (IMOD). */
typedef union IMX_USB3_USBSS_IMOD2_union_t {
    uint32_t R;
    struct {
        uint32_t IMODI       :16;                /* Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
        uint32_t IMODC       :16;                /* Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
    } B;
} IMX_USB3_USBSS_IMOD2_t;

/* Register IMOD2 - Interrupter Moderation Register (IMOD). */
#define IMX_USB3_USBSS_IMOD2_OFFSET 0x12064
/* Field IMODI - Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
#define IMX_USB3_USBSS_IMOD2_IMODI_SHIFT 0
#define IMX_USB3_USBSS_IMOD2_IMODI_MASK 0xFFFF
#define IMX_USB3_USBSS_IMOD2_IMODI(v) (((v) << 0) & 0xFFFF)
/* Field IMODC - Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
#define IMX_USB3_USBSS_IMOD2_IMODC_SHIFT 16
#define IMX_USB3_USBSS_IMOD2_IMODC_MASK 0xFFFF0000
#define IMX_USB3_USBSS_IMOD2_IMODC(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_ERSTSZ2 - Event Ring Segment Table Size Register (ERSTSZ). */
typedef union IMX_USB3_USBSS_ERSTSZ2_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTS       :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_ERSTSZ2_t;

/* Register ERSTSZ2 - Event Ring Segment Table Size Register (ERSTSZ). */
#define IMX_USB3_USBSS_ERSTSZ2_OFFSET 0x12068
/* Field ERSTS - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
#define IMX_USB3_USBSS_ERSTSZ2_ERSTS_SHIFT 0
#define IMX_USB3_USBSS_ERSTSZ2_ERSTS_MASK 0xFFFF
#define IMX_USB3_USBSS_ERSTSZ2_ERSTS(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_RESERVED2 -  */
typedef union IMX_USB3_USBSS_RESERVED2_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_RESERVED2_t;

/* Register RESERVED2 -  */
#define IMX_USB3_USBSS_RESERVED2_OFFSET 0x1206C

/* IMX_USB3_USBSS_ERSTBA2_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA2_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t ERSTBADDR_LO :26;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA2_LO_t;

/* Register ERSTBA2_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA2_LO_OFFSET 0x12070
/* Field ERSTBADDR_LO - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA2_LO_ERSTBADDR_LO_SHIFT 6
#define IMX_USB3_USBSS_ERSTBA2_LO_ERSTBADDR_LO_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_ERSTBA2_LO_ERSTBADDR_LO(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_ERSTBA2_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA2_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBADDR_HI :32;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA2_HI_t;

/* Register ERSTBA2_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA2_HI_OFFSET 0x12074
/* Field ERSTBADDR_HI - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA2_HI_ERSTBADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERSTBA2_HI_ERSTBADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERSTBA2_HI_ERSTBADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_ERDP2_LO - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP2_LO_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t EHB         :1;                 /* Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
        uint32_t ERDPTR      :28;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP2_LO_t;

/* Register ERDP2_LO - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP2_LO_OFFSET 0x12078
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_ERDP2_LO_DESI_SHIFT 0
#define IMX_USB3_USBSS_ERDP2_LO_DESI_MASK 0x7
#define IMX_USB3_USBSS_ERDP2_LO_DESI(v) (((v) << 0) & 0x7)
/* Field EHB - Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
#define IMX_USB3_USBSS_ERDP2_LO_EHB_SHIFT 3
#define IMX_USB3_USBSS_ERDP2_LO_EHB_MASK 0x8
#define IMX_USB3_USBSS_ERDP2_LO_EHB(v) (((v) << 0x3) & 0x8)
/* Field ERDPTR - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP2_LO_ERDPTR_SHIFT 4
#define IMX_USB3_USBSS_ERDP2_LO_ERDPTR_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_ERDP2_LO_ERDPTR(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_ERDP2_HI - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP2_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERDPTR_HI   :32;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP2_HI_t;

/* Register ERDP2_HI - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP2_HI_OFFSET 0x1207C
/* Field ERDPTR_HI - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP2_HI_ERDPTR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERDP2_HI_ERDPTR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERDP2_HI_ERDPTR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_IMAN3 - Interrupter Management Register (IMAN). */
typedef union IMX_USB3_USBSS_IMAN3_union_t {
    uint32_t R;
    struct {
        uint32_t IP          :1;                 /* Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
        uint32_t IE          :1;                 /* Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
        uint32_t _unused2    :30;                /* Reserved */
    } B;
} IMX_USB3_USBSS_IMAN3_t;

/* Register IMAN3 - Interrupter Management Register (IMAN). */
#define IMX_USB3_USBSS_IMAN3_OFFSET 0x12080
/* Field IP - Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
#define IMX_USB3_USBSS_IMAN3_IP_SHIFT 0
#define IMX_USB3_USBSS_IMAN3_IP_MASK 0x1
#define IMX_USB3_USBSS_IMAN3_IP(v) (((v) << 0) & 0x1)
/* Field IE - Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
#define IMX_USB3_USBSS_IMAN3_IE_SHIFT 1
#define IMX_USB3_USBSS_IMAN3_IE_MASK 0x2
#define IMX_USB3_USBSS_IMAN3_IE(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_IMOD3 - Interrupter Moderation Register (IMOD). */
typedef union IMX_USB3_USBSS_IMOD3_union_t {
    uint32_t R;
    struct {
        uint32_t IMODI       :16;                /* Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
        uint32_t IMODC       :16;                /* Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
    } B;
} IMX_USB3_USBSS_IMOD3_t;

/* Register IMOD3 - Interrupter Moderation Register (IMOD). */
#define IMX_USB3_USBSS_IMOD3_OFFSET 0x12084
/* Field IMODI - Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
#define IMX_USB3_USBSS_IMOD3_IMODI_SHIFT 0
#define IMX_USB3_USBSS_IMOD3_IMODI_MASK 0xFFFF
#define IMX_USB3_USBSS_IMOD3_IMODI(v) (((v) << 0) & 0xFFFF)
/* Field IMODC - Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
#define IMX_USB3_USBSS_IMOD3_IMODC_SHIFT 16
#define IMX_USB3_USBSS_IMOD3_IMODC_MASK 0xFFFF0000
#define IMX_USB3_USBSS_IMOD3_IMODC(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_ERSTSZ3 - Event Ring Segment Table Size Register (ERSTSZ). */
typedef union IMX_USB3_USBSS_ERSTSZ3_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTS       :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_ERSTSZ3_t;

/* Register ERSTSZ3 - Event Ring Segment Table Size Register (ERSTSZ). */
#define IMX_USB3_USBSS_ERSTSZ3_OFFSET 0x12088
/* Field ERSTS - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
#define IMX_USB3_USBSS_ERSTSZ3_ERSTS_SHIFT 0
#define IMX_USB3_USBSS_ERSTSZ3_ERSTS_MASK 0xFFFF
#define IMX_USB3_USBSS_ERSTSZ3_ERSTS(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_RESERVED3 -  */
typedef union IMX_USB3_USBSS_RESERVED3_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_RESERVED3_t;

/* Register RESERVED3 -  */
#define IMX_USB3_USBSS_RESERVED3_OFFSET 0x1208C

/* IMX_USB3_USBSS_ERSTBA3_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA3_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t ERSTBADDR_LO :26;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA3_LO_t;

/* Register ERSTBA3_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA3_LO_OFFSET 0x12090
/* Field ERSTBADDR_LO - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA3_LO_ERSTBADDR_LO_SHIFT 6
#define IMX_USB3_USBSS_ERSTBA3_LO_ERSTBADDR_LO_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_ERSTBA3_LO_ERSTBADDR_LO(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_ERSTBA3_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA3_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBADDR_HI :32;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA3_HI_t;

/* Register ERSTBA3_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA3_HI_OFFSET 0x12094
/* Field ERSTBADDR_HI - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA3_HI_ERSTBADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERSTBA3_HI_ERSTBADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERSTBA3_HI_ERSTBADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_ERDP3_LO - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP3_LO_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t EHB         :1;                 /* Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
        uint32_t ERDPTR      :28;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP3_LO_t;

/* Register ERDP3_LO - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP3_LO_OFFSET 0x12098
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_ERDP3_LO_DESI_SHIFT 0
#define IMX_USB3_USBSS_ERDP3_LO_DESI_MASK 0x7
#define IMX_USB3_USBSS_ERDP3_LO_DESI(v) (((v) << 0) & 0x7)
/* Field EHB - Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
#define IMX_USB3_USBSS_ERDP3_LO_EHB_SHIFT 3
#define IMX_USB3_USBSS_ERDP3_LO_EHB_MASK 0x8
#define IMX_USB3_USBSS_ERDP3_LO_EHB(v) (((v) << 0x3) & 0x8)
/* Field ERDPTR - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP3_LO_ERDPTR_SHIFT 4
#define IMX_USB3_USBSS_ERDP3_LO_ERDPTR_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_ERDP3_LO_ERDPTR(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_ERDP3_HI - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP3_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERDPTR_HI   :32;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP3_HI_t;

/* Register ERDP3_HI - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP3_HI_OFFSET 0x1209C
/* Field ERDPTR_HI - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP3_HI_ERDPTR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERDP3_HI_ERDPTR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERDP3_HI_ERDPTR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_IMAN4 - Interrupter Management Register (IMAN). */
typedef union IMX_USB3_USBSS_IMAN4_union_t {
    uint32_t R;
    struct {
        uint32_t IP          :1;                 /* Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
        uint32_t IE          :1;                 /* Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
        uint32_t _unused2    :30;                /* Reserved */
    } B;
} IMX_USB3_USBSS_IMAN4_t;

/* Register IMAN4 - Interrupter Management Register (IMAN). */
#define IMX_USB3_USBSS_IMAN4_OFFSET 0x120A0
/* Field IP - Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
#define IMX_USB3_USBSS_IMAN4_IP_SHIFT 0
#define IMX_USB3_USBSS_IMAN4_IP_MASK 0x1
#define IMX_USB3_USBSS_IMAN4_IP(v) (((v) << 0) & 0x1)
/* Field IE - Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
#define IMX_USB3_USBSS_IMAN4_IE_SHIFT 1
#define IMX_USB3_USBSS_IMAN4_IE_MASK 0x2
#define IMX_USB3_USBSS_IMAN4_IE(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_IMOD4 - Interrupter Moderation Register (IMOD). */
typedef union IMX_USB3_USBSS_IMOD4_union_t {
    uint32_t R;
    struct {
        uint32_t IMODI       :16;                /* Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
        uint32_t IMODC       :16;                /* Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
    } B;
} IMX_USB3_USBSS_IMOD4_t;

/* Register IMOD4 - Interrupter Moderation Register (IMOD). */
#define IMX_USB3_USBSS_IMOD4_OFFSET 0x120A4
/* Field IMODI - Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
#define IMX_USB3_USBSS_IMOD4_IMODI_SHIFT 0
#define IMX_USB3_USBSS_IMOD4_IMODI_MASK 0xFFFF
#define IMX_USB3_USBSS_IMOD4_IMODI(v) (((v) << 0) & 0xFFFF)
/* Field IMODC - Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
#define IMX_USB3_USBSS_IMOD4_IMODC_SHIFT 16
#define IMX_USB3_USBSS_IMOD4_IMODC_MASK 0xFFFF0000
#define IMX_USB3_USBSS_IMOD4_IMODC(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_ERSTSZ4 - Event Ring Segment Table Size Register (ERSTSZ). */
typedef union IMX_USB3_USBSS_ERSTSZ4_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTS       :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_ERSTSZ4_t;

/* Register ERSTSZ4 - Event Ring Segment Table Size Register (ERSTSZ). */
#define IMX_USB3_USBSS_ERSTSZ4_OFFSET 0x120A8
/* Field ERSTS - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
#define IMX_USB3_USBSS_ERSTSZ4_ERSTS_SHIFT 0
#define IMX_USB3_USBSS_ERSTSZ4_ERSTS_MASK 0xFFFF
#define IMX_USB3_USBSS_ERSTSZ4_ERSTS(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_RESERVED4 -  */
typedef union IMX_USB3_USBSS_RESERVED4_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_RESERVED4_t;

/* Register RESERVED4 -  */
#define IMX_USB3_USBSS_RESERVED4_OFFSET 0x120AC

/* IMX_USB3_USBSS_ERSTBA4_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA4_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t ERSTBADDR_LO :26;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA4_LO_t;

/* Register ERSTBA4_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA4_LO_OFFSET 0x120B0
/* Field ERSTBADDR_LO - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA4_LO_ERSTBADDR_LO_SHIFT 6
#define IMX_USB3_USBSS_ERSTBA4_LO_ERSTBADDR_LO_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_ERSTBA4_LO_ERSTBADDR_LO(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_ERSTBA4_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA4_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBADDR_HI :32;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA4_HI_t;

/* Register ERSTBA4_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA4_HI_OFFSET 0x120B4
/* Field ERSTBADDR_HI - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA4_HI_ERSTBADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERSTBA4_HI_ERSTBADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERSTBA4_HI_ERSTBADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_ERDP4_LO - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP4_LO_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t EHB         :1;                 /* Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
        uint32_t ERDPTR      :28;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP4_LO_t;

/* Register ERDP4_LO - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP4_LO_OFFSET 0x120B8
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_ERDP4_LO_DESI_SHIFT 0
#define IMX_USB3_USBSS_ERDP4_LO_DESI_MASK 0x7
#define IMX_USB3_USBSS_ERDP4_LO_DESI(v) (((v) << 0) & 0x7)
/* Field EHB - Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
#define IMX_USB3_USBSS_ERDP4_LO_EHB_SHIFT 3
#define IMX_USB3_USBSS_ERDP4_LO_EHB_MASK 0x8
#define IMX_USB3_USBSS_ERDP4_LO_EHB(v) (((v) << 0x3) & 0x8)
/* Field ERDPTR - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP4_LO_ERDPTR_SHIFT 4
#define IMX_USB3_USBSS_ERDP4_LO_ERDPTR_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_ERDP4_LO_ERDPTR(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_ERDP4_HI - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP4_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERDPTR_HI   :32;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP4_HI_t;

/* Register ERDP4_HI - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP4_HI_OFFSET 0x120BC
/* Field ERDPTR_HI - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP4_HI_ERDPTR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERDP4_HI_ERDPTR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERDP4_HI_ERDPTR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_IMAN5 - Interrupter Management Register (IMAN). */
typedef union IMX_USB3_USBSS_IMAN5_union_t {
    uint32_t R;
    struct {
        uint32_t IP          :1;                 /* Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
        uint32_t IE          :1;                 /* Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
        uint32_t _unused2    :30;                /* Reserved */
    } B;
} IMX_USB3_USBSS_IMAN5_t;

/* Register IMAN5 - Interrupter Management Register (IMAN). */
#define IMX_USB3_USBSS_IMAN5_OFFSET 0x120C0
/* Field IP - Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
#define IMX_USB3_USBSS_IMAN5_IP_SHIFT 0
#define IMX_USB3_USBSS_IMAN5_IP_MASK 0x1
#define IMX_USB3_USBSS_IMAN5_IP(v) (((v) << 0) & 0x1)
/* Field IE - Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
#define IMX_USB3_USBSS_IMAN5_IE_SHIFT 1
#define IMX_USB3_USBSS_IMAN5_IE_MASK 0x2
#define IMX_USB3_USBSS_IMAN5_IE(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_IMOD5 - Interrupter Moderation Register (IMOD). */
typedef union IMX_USB3_USBSS_IMOD5_union_t {
    uint32_t R;
    struct {
        uint32_t IMODI       :16;                /* Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
        uint32_t IMODC       :16;                /* Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
    } B;
} IMX_USB3_USBSS_IMOD5_t;

/* Register IMOD5 - Interrupter Moderation Register (IMOD). */
#define IMX_USB3_USBSS_IMOD5_OFFSET 0x120C4
/* Field IMODI - Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
#define IMX_USB3_USBSS_IMOD5_IMODI_SHIFT 0
#define IMX_USB3_USBSS_IMOD5_IMODI_MASK 0xFFFF
#define IMX_USB3_USBSS_IMOD5_IMODI(v) (((v) << 0) & 0xFFFF)
/* Field IMODC - Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
#define IMX_USB3_USBSS_IMOD5_IMODC_SHIFT 16
#define IMX_USB3_USBSS_IMOD5_IMODC_MASK 0xFFFF0000
#define IMX_USB3_USBSS_IMOD5_IMODC(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_ERSTSZ5 - Event Ring Segment Table Size Register (ERSTSZ). */
typedef union IMX_USB3_USBSS_ERSTSZ5_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTS       :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_ERSTSZ5_t;

/* Register ERSTSZ5 - Event Ring Segment Table Size Register (ERSTSZ). */
#define IMX_USB3_USBSS_ERSTSZ5_OFFSET 0x120C8
/* Field ERSTS - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
#define IMX_USB3_USBSS_ERSTSZ5_ERSTS_SHIFT 0
#define IMX_USB3_USBSS_ERSTSZ5_ERSTS_MASK 0xFFFF
#define IMX_USB3_USBSS_ERSTSZ5_ERSTS(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_RESERVED5 -  */
typedef union IMX_USB3_USBSS_RESERVED5_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_RESERVED5_t;

/* Register RESERVED5 -  */
#define IMX_USB3_USBSS_RESERVED5_OFFSET 0x120CC

/* IMX_USB3_USBSS_ERSTBA5_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA5_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t ERSTBADDR_LO :26;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA5_LO_t;

/* Register ERSTBA5_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA5_LO_OFFSET 0x120D0
/* Field ERSTBADDR_LO - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA5_LO_ERSTBADDR_LO_SHIFT 6
#define IMX_USB3_USBSS_ERSTBA5_LO_ERSTBADDR_LO_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_ERSTBA5_LO_ERSTBADDR_LO(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_ERSTBA5_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA5_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBADDR_HI :32;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA5_HI_t;

/* Register ERSTBA5_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA5_HI_OFFSET 0x120D4
/* Field ERSTBADDR_HI - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA5_HI_ERSTBADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERSTBA5_HI_ERSTBADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERSTBA5_HI_ERSTBADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_ERDP5_LO - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP5_LO_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t EHB         :1;                 /* Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
        uint32_t ERDPTR      :28;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP5_LO_t;

/* Register ERDP5_LO - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP5_LO_OFFSET 0x120D8
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_ERDP5_LO_DESI_SHIFT 0
#define IMX_USB3_USBSS_ERDP5_LO_DESI_MASK 0x7
#define IMX_USB3_USBSS_ERDP5_LO_DESI(v) (((v) << 0) & 0x7)
/* Field EHB - Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
#define IMX_USB3_USBSS_ERDP5_LO_EHB_SHIFT 3
#define IMX_USB3_USBSS_ERDP5_LO_EHB_MASK 0x8
#define IMX_USB3_USBSS_ERDP5_LO_EHB(v) (((v) << 0x3) & 0x8)
/* Field ERDPTR - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP5_LO_ERDPTR_SHIFT 4
#define IMX_USB3_USBSS_ERDP5_LO_ERDPTR_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_ERDP5_LO_ERDPTR(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_ERDP5_HI - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP5_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERDPTR_HI   :32;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP5_HI_t;

/* Register ERDP5_HI - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP5_HI_OFFSET 0x120DC
/* Field ERDPTR_HI - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP5_HI_ERDPTR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERDP5_HI_ERDPTR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERDP5_HI_ERDPTR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_IMAN6 - Interrupter Management Register (IMAN). */
typedef union IMX_USB3_USBSS_IMAN6_union_t {
    uint32_t R;
    struct {
        uint32_t IP          :1;                 /* Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
        uint32_t IE          :1;                 /* Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
        uint32_t _unused2    :30;                /* Reserved */
    } B;
} IMX_USB3_USBSS_IMAN6_t;

/* Register IMAN6 - Interrupter Management Register (IMAN). */
#define IMX_USB3_USBSS_IMAN6_OFFSET 0x120E0
/* Field IP - Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
#define IMX_USB3_USBSS_IMAN6_IP_SHIFT 0
#define IMX_USB3_USBSS_IMAN6_IP_MASK 0x1
#define IMX_USB3_USBSS_IMAN6_IP(v) (((v) << 0) & 0x1)
/* Field IE - Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
#define IMX_USB3_USBSS_IMAN6_IE_SHIFT 1
#define IMX_USB3_USBSS_IMAN6_IE_MASK 0x2
#define IMX_USB3_USBSS_IMAN6_IE(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_IMOD6 - Interrupter Moderation Register (IMOD). */
typedef union IMX_USB3_USBSS_IMOD6_union_t {
    uint32_t R;
    struct {
        uint32_t IMODI       :16;                /* Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
        uint32_t IMODC       :16;                /* Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
    } B;
} IMX_USB3_USBSS_IMOD6_t;

/* Register IMOD6 - Interrupter Moderation Register (IMOD). */
#define IMX_USB3_USBSS_IMOD6_OFFSET 0x120E4
/* Field IMODI - Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
#define IMX_USB3_USBSS_IMOD6_IMODI_SHIFT 0
#define IMX_USB3_USBSS_IMOD6_IMODI_MASK 0xFFFF
#define IMX_USB3_USBSS_IMOD6_IMODI(v) (((v) << 0) & 0xFFFF)
/* Field IMODC - Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
#define IMX_USB3_USBSS_IMOD6_IMODC_SHIFT 16
#define IMX_USB3_USBSS_IMOD6_IMODC_MASK 0xFFFF0000
#define IMX_USB3_USBSS_IMOD6_IMODC(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_ERSTSZ6 - Event Ring Segment Table Size Register (ERSTSZ). */
typedef union IMX_USB3_USBSS_ERSTSZ6_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTS       :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_ERSTSZ6_t;

/* Register ERSTSZ6 - Event Ring Segment Table Size Register (ERSTSZ). */
#define IMX_USB3_USBSS_ERSTSZ6_OFFSET 0x120E8
/* Field ERSTS - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
#define IMX_USB3_USBSS_ERSTSZ6_ERSTS_SHIFT 0
#define IMX_USB3_USBSS_ERSTSZ6_ERSTS_MASK 0xFFFF
#define IMX_USB3_USBSS_ERSTSZ6_ERSTS(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_RESERVED6 -  */
typedef union IMX_USB3_USBSS_RESERVED6_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_RESERVED6_t;

/* Register RESERVED6 -  */
#define IMX_USB3_USBSS_RESERVED6_OFFSET 0x120EC

/* IMX_USB3_USBSS_ERSTBA6_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA6_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t ERSTBADDR_LO :26;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA6_LO_t;

/* Register ERSTBA6_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA6_LO_OFFSET 0x120F0
/* Field ERSTBADDR_LO - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA6_LO_ERSTBADDR_LO_SHIFT 6
#define IMX_USB3_USBSS_ERSTBA6_LO_ERSTBADDR_LO_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_ERSTBA6_LO_ERSTBADDR_LO(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_ERSTBA6_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA6_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBADDR_HI :32;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA6_HI_t;

/* Register ERSTBA6_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA6_HI_OFFSET 0x120F4
/* Field ERSTBADDR_HI - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA6_HI_ERSTBADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERSTBA6_HI_ERSTBADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERSTBA6_HI_ERSTBADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_ERDP6_LO - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP6_LO_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t EHB         :1;                 /* Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
        uint32_t ERDPTR      :28;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP6_LO_t;

/* Register ERDP6_LO - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP6_LO_OFFSET 0x120F8
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_ERDP6_LO_DESI_SHIFT 0
#define IMX_USB3_USBSS_ERDP6_LO_DESI_MASK 0x7
#define IMX_USB3_USBSS_ERDP6_LO_DESI(v) (((v) << 0) & 0x7)
/* Field EHB - Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
#define IMX_USB3_USBSS_ERDP6_LO_EHB_SHIFT 3
#define IMX_USB3_USBSS_ERDP6_LO_EHB_MASK 0x8
#define IMX_USB3_USBSS_ERDP6_LO_EHB(v) (((v) << 0x3) & 0x8)
/* Field ERDPTR - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP6_LO_ERDPTR_SHIFT 4
#define IMX_USB3_USBSS_ERDP6_LO_ERDPTR_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_ERDP6_LO_ERDPTR(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_ERDP6_HI - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP6_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERDPTR_HI   :32;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP6_HI_t;

/* Register ERDP6_HI - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP6_HI_OFFSET 0x120FC
/* Field ERDPTR_HI - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP6_HI_ERDPTR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERDP6_HI_ERDPTR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERDP6_HI_ERDPTR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_IMAN7 - Interrupter Management Register (IMAN). */
typedef union IMX_USB3_USBSS_IMAN7_union_t {
    uint32_t R;
    struct {
        uint32_t IP          :1;                 /* Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
        uint32_t IE          :1;                 /* Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
        uint32_t _unused2    :30;                /* Reserved */
    } B;
} IMX_USB3_USBSS_IMAN7_t;

/* Register IMAN7 - Interrupter Management Register (IMAN). */
#define IMX_USB3_USBSS_IMAN7_OFFSET 0x12100
/* Field IP - Interrupt Pending (IP), RW1C. Default = '0'. This flag represents the current state of the Interrupter. If IP = '1', an interrupt is pending for this Interrupter. A '0' value indicates that no interrupt is pending for the Interrupter. Refer to section 4.17.5 of the xHCI specification for the conditions that modify the state of this flag. */
#define IMX_USB3_USBSS_IMAN7_IP_SHIFT 0
#define IMX_USB3_USBSS_IMAN7_IP_MASK 0x1
#define IMX_USB3_USBSS_IMAN7_IP(v) (((v) << 0) & 0x1)
/* Field IE - Interrupt Enable (IE), RW. Default = '0'. This flag specifies whether the Interrupter is capable of generating an interrupt. When this bit and the IP bit are set ('1'), the Interrupter shall generate an interrupt when the Interrupter Moderation Counter reaches 0. If this bit is '0', then the Interrupter is prohibited from generating interrupts. */
#define IMX_USB3_USBSS_IMAN7_IE_SHIFT 1
#define IMX_USB3_USBSS_IMAN7_IE_MASK 0x2
#define IMX_USB3_USBSS_IMAN7_IE(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_IMOD7 - Interrupter Moderation Register (IMOD). */
typedef union IMX_USB3_USBSS_IMOD7_union_t {
    uint32_t R;
    struct {
        uint32_t IMODI       :16;                /* Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
        uint32_t IMODC       :16;                /* Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
    } B;
} IMX_USB3_USBSS_IMOD7_t;

/* Register IMOD7 - Interrupter Moderation Register (IMOD). */
#define IMX_USB3_USBSS_IMOD7_OFFSET 0x12104
/* Field IMODI - Interrupt Moderation Interval (IMODI), RW. Default = 'hFA0' (~1ms). Minimum inter-interrupt interval. The interval is specified in 250ns increments. A value of zero disables interrupt throttling logic and interrupts shall be generated immediately if IP = '0', EHB = '0', and the Event Ring is not empty. The IMODI field shall default to 'hFA0' (1 ms) upon initialization and reset. It may be loaded with an alternative value by software when the Interrupter is initialized. */
#define IMX_USB3_USBSS_IMOD7_IMODI_SHIFT 0
#define IMX_USB3_USBSS_IMOD7_IMODI_MASK 0xFFFF
#define IMX_USB3_USBSS_IMOD7_IMODI(v) (((v) << 0) & 0xFFFF)
/* Field IMODC - Interrupt Moderation Counter (IMODC), RW. Default = undefined. Down counter. Loaded with the IMODI value whenever IP is cleared to '0', counts down to 0, and stops. The associated interrupt shall be signaled whenever this counter is zero, the Event Ring is not empty, the IE and IP flags = '1', and EHB = '0'. This counter may be directly written by software at any time to alter the interrupt rate. */
#define IMX_USB3_USBSS_IMOD7_IMODC_SHIFT 16
#define IMX_USB3_USBSS_IMOD7_IMODC_MASK 0xFFFF0000
#define IMX_USB3_USBSS_IMOD7_IMODC(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_ERSTSZ7 - Event Ring Segment Table Size Register (ERSTSZ). */
typedef union IMX_USB3_USBSS_ERSTSZ7_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTS       :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_ERSTSZ7_t;

/* Register ERSTSZ7 - Event Ring Segment Table Size Register (ERSTSZ). */
#define IMX_USB3_USBSS_ERSTSZ7_OFFSET 0x12108
/* Field ERSTS - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the ERST Max field in the HCSPARAMS2 register. For Secondary Interrupters: Writing a value of 0 to this field disables the Event Ring. Any events targeted at this Event Ring when it is disabled shall result in undefined behavior of the Event Ring. For the Primary Interrupter: Writing a value of 0 to this field shall result in undefined behavior of the Event Ring. The Primary Event Ring cannot be disabled. */
#define IMX_USB3_USBSS_ERSTSZ7_ERSTS_SHIFT 0
#define IMX_USB3_USBSS_ERSTSZ7_ERSTS_MASK 0xFFFF
#define IMX_USB3_USBSS_ERSTSZ7_ERSTS(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_RESERVED7 -  */
typedef union IMX_USB3_USBSS_RESERVED7_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_RESERVED7_t;

/* Register RESERVED7 -  */
#define IMX_USB3_USBSS_RESERVED7_OFFSET 0x1210C

/* IMX_USB3_USBSS_ERSTBA7_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA7_LO_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :6;                 /* Reserved */
        uint32_t ERSTBADDR_LO :26;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA7_LO_t;

/* Register ERSTBA7_LO - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA7_LO_OFFSET 0x12110
/* Field ERSTBADDR_LO - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the low order bit [25:0] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine: EREP Advancement to the Start state. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA7_LO_ERSTBADDR_LO_SHIFT 6
#define IMX_USB3_USBSS_ERSTBA7_LO_ERSTBADDR_LO_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_ERSTBA7_LO_ERSTBADDR_LO(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_ERSTBA7_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_ERSTBA7_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBADDR_HI :32;               /* Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
    } B;
} IMX_USB3_USBSS_ERSTBA7_HI_t;

/* Register ERSTBA7_HI - The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
#define IMX_USB3_USBSS_ERSTBA7_HI_OFFSET 0x12114
/* Field ERSTBADDR_HI - Event Ring Segment Table Base Address Register, RW. Default = 0. This field defines the high order bits [57:26] of the start address of the Event Ring Segment Table (the address is 58 bits wide) . Writing this register sets the Event Ring State Machine:EREP Advancement to the Start state. Refer to Figure 20 in xHCI specificationfor more information. This field shall not be modified if HCHalted (HCH) = '0'. */
#define IMX_USB3_USBSS_ERSTBA7_HI_ERSTBADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERSTBA7_HI_ERSTBADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERSTBA7_HI_ERSTBADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_ERDP7_LO - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP7_LO_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t EHB         :1;                 /* Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
        uint32_t ERDPTR      :28;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP7_LO_t;

/* Register ERDP7_LO - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP7_LO_OFFSET 0x12118
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_ERDP7_LO_DESI_SHIFT 0
#define IMX_USB3_USBSS_ERDP7_LO_DESI_MASK 0x7
#define IMX_USB3_USBSS_ERDP7_LO_DESI(v) (((v) << 0) & 0x7)
/* Field EHB - Event Handler Busy (EHB), RW1C. Default = '0'. This flag shall be set to '1' when the IP bit is set to '1' and cleared to '0' by software when the Dequeue Pointer register is written. Refer to section 4.17.2 of xHCI specification for more information */
#define IMX_USB3_USBSS_ERDP7_LO_EHB_SHIFT 3
#define IMX_USB3_USBSS_ERDP7_LO_EHB_MASK 0x8
#define IMX_USB3_USBSS_ERDP7_LO_EHB(v) (((v) << 0x3) & 0x8)
/* Field ERDPTR - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 28 low order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP7_LO_ERDPTR_SHIFT 4
#define IMX_USB3_USBSS_ERDP7_LO_ERDPTR_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_ERDP7_LO_ERDPTR(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_ERDP7_HI - Event Ring Dequeue Pointer Register (ERDP). */
typedef union IMX_USB3_USBSS_ERDP7_HI_union_t {
    uint32_t R;
    struct {
        uint32_t ERDPTR_HI   :32;                /* Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
    } B;
} IMX_USB3_USBSS_ERDP7_HI_t;

/* Register ERDP7_HI - Event Ring Dequeue Pointer Register (ERDP). */
#define IMX_USB3_USBSS_ERDP7_HI_OFFSET 0x1211C
/* Field ERDPTR_HI - Event Ring Dequeue Pointer, RW. Default = 0. This field defines the 32 high order bits of the 64-bit address of the current Event Ring Dequeue Pointer. */
#define IMX_USB3_USBSS_ERDP7_HI_ERDPTR_HI_SHIFT 0
#define IMX_USB3_USBSS_ERDP7_HI_ERDPTR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_ERDP7_HI_ERDPTR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_DB0 - Host Controller Doorbell. */
typedef union IMX_USB3_USBSS_DB0_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Note that Doorbell Register 0 is dedicated to Command Ring and decodes this field differently than the other Doorbell Registers. Possible values ( For this register, there is only one valid value for the DB Target field, 0 (Host Controller Command). The remaining values (1-255) are reserved.): 0: Command Doorbell 1:247 Reserved 248:255 Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB0_t;

/* Register DB0 - Host Controller Doorbell. */
#define IMX_USB3_USBSS_DB0_OFFSET 0x13000
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Note that Doorbell Register 0 is dedicated to Command Ring and decodes this field differently than the other Doorbell Registers. Possible values ( For this register, there is only one valid value for the DB Target field, 0 (Host Controller Command). The remaining values (1-255) are reserved.): 0: Command Doorbell 1:247 Reserved 248:255 Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB0_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB0_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB0_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB0_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB0_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB0_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB1 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB1_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB1_t;

/* Register DB1 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB1_OFFSET 0x13004
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB1_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB1_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB1_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB1_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB1_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB1_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB2 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB2_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB2_t;

/* Register DB2 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB2_OFFSET 0x13008
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB2_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB2_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB2_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB2_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB2_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB2_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB3 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB3_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB3_t;

/* Register DB3 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB3_OFFSET 0x1300C
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB3_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB3_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB3_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB3_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB3_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB3_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB4 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB4_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB4_t;

/* Register DB4 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB4_OFFSET 0x13010
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB4_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB4_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB4_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB4_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB4_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB4_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB5 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB5_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB5_t;

/* Register DB5 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB5_OFFSET 0x13014
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB5_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB5_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB5_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB5_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB5_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB5_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB6 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB6_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB6_t;

/* Register DB6 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB6_OFFSET 0x13018
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB6_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB6_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB6_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB6_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB6_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB6_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB7 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB7_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB7_t;

/* Register DB7 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB7_OFFSET 0x1301C
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB7_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB7_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB7_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB7_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB7_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB7_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB8 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB8_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB8_t;

/* Register DB8 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB8_OFFSET 0x13020
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB8_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB8_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB8_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB8_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB8_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB8_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB9 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB9_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB9_t;

/* Register DB9 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB9_OFFSET 0x13024
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB9_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB9_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB9_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB9_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB9_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB9_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB10 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB10_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB10_t;

/* Register DB10 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB10_OFFSET 0x13028
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB10_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB10_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB10_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB10_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB10_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB10_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB11 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB11_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB11_t;

/* Register DB11 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB11_OFFSET 0x1302C
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB11_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB11_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB11_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB11_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB11_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB11_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB12 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB12_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB12_t;

/* Register DB12 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB12_OFFSET 0x13030
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB12_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB12_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB12_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB12_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB12_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB12_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB13 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB13_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB13_t;

/* Register DB13 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB13_OFFSET 0x13034
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB13_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB13_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB13_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB13_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB13_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB13_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB14 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB14_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB14_t;

/* Register DB14 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB14_OFFSET 0x13038
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB14_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB14_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB14_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB14_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB14_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB14_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB15 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB15_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB15_t;

/* Register DB15 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB15_OFFSET 0x1303C
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB15_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB15_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB15_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB15_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB15_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB15_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB16 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB16_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB16_t;

/* Register DB16 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB16_OFFSET 0x13040
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB16_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB16_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB16_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB16_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB16_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB16_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB17 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB17_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB17_t;

/* Register DB17 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB17_OFFSET 0x13044
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB17_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB17_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB17_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB17_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB17_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB17_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB18 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB18_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB18_t;

/* Register DB18 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB18_OFFSET 0x13048
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB18_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB18_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB18_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB18_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB18_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB18_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB19 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB19_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB19_t;

/* Register DB19 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB19_OFFSET 0x1304C
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB19_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB19_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB19_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB19_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB19_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB19_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB20 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB20_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB20_t;

/* Register DB20 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB20_OFFSET 0x13050
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB20_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB20_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB20_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB20_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB20_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB20_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB21 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB21_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB21_t;

/* Register DB21 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB21_OFFSET 0x13054
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB21_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB21_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB21_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB21_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB21_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB21_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB22 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB22_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB22_t;

/* Register DB22 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB22_OFFSET 0x13058
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB22_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB22_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB22_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB22_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB22_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB22_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB23 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB23_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB23_t;

/* Register DB23 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB23_OFFSET 0x1305C
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB23_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB23_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB23_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB23_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB23_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB23_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB24 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB24_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB24_t;

/* Register DB24 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB24_OFFSET 0x13060
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB24_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB24_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB24_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB24_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB24_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB24_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB25 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB25_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB25_t;

/* Register DB25 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB25_OFFSET 0x13064
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB25_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB25_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB25_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB25_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB25_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB25_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB26 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB26_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB26_t;

/* Register DB26 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB26_OFFSET 0x13068
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB26_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB26_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB26_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB26_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB26_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB26_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB27 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB27_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB27_t;

/* Register DB27 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB27_OFFSET 0x1306C
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB27_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB27_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB27_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB27_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB27_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB27_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB28 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB28_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB28_t;

/* Register DB28 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB28_OFFSET 0x13070
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB28_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB28_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB28_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB28_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB28_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB28_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB29 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB29_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB29_t;

/* Register DB29 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB29_OFFSET 0x13074
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB29_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB29_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB29_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB29_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB29_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB29_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB30 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB30_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB30_t;

/* Register DB30 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB30_OFFSET 0x13078
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB30_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB30_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB30_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB30_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB30_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB30_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB31 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB31_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB31_t;

/* Register DB31 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB31_OFFSET 0x1307C
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB31_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB31_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB31_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB31_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB31_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB31_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_DB32 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
typedef union IMX_USB3_USBSS_DB32_union_t {
    uint32_t R;
    struct {
        uint32_t DB_TARGET   :8;                 /* DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t DB_STREAM_ID :16;               /* DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
    } B;
} IMX_USB3_USBSS_DB32_t;

/* Register DB32 - The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
#define IMX_USB3_USBSS_DB32_OFFSET 0x13080
/* Field DB_TARGET - DB Target, RW. Doorbell Target. This field defines the target of the doorbell reference. The table below defines the xHC notification that is generated by ringing the doorbell. Possible values: 0: Reserved 1: Control EP 0 Enqueue Pointer Update 2: EP 1 OUT Enqueue Pointer Update 3: EP 1 IN Enqueue Pointer Update 4: EP 2 OUT Enqueue Pointer Update 5: EP 2 IN Enqueue Pointer Update ... 30: EP 15 OUT Enqueue Pointer Update 31: EP 15 IN Enqueue Pointer Update 32:247: Reserved 248:255: Vendor Defined This field returns zero when read and should be treated as undefined by software. When the Command Doorbell is written, the DB Stream ID field shall be cleared to zero. */
#define IMX_USB3_USBSS_DB32_DB_TARGET_SHIFT 0
#define IMX_USB3_USBSS_DB32_DB_TARGET_MASK 0xFF
#define IMX_USB3_USBSS_DB32_DB_TARGET(v) (((v) << 0) & 0xFF)
/* Field DB_STREAM_ID - DB Stream ID, RW. Doorbell Stream ID. If the endpoint of a Device Context Doorbell defines Streams, then this field shall be used to identify which Stream of the endpoint the doorbell reference is targeting. System software is responsible for ensuring that the value written to this field is valid. If the endpoint defines Streams (MaxPStreams > 0), then 0, 65535 (No Stream) and 65534 (Prime) are reserved Stream ID values and shall not be written to this field. If the endpoint does not define Streams (MaxPStreams = 0) and a non-'0' value is written to this field, the doorbell reference shall be ignored. This field only applies to Device Context Doorbells and shall be cleared to zero for Host Controller Command Doorbells. This field returns zero when read. */
#define IMX_USB3_USBSS_DB32_DB_STREAM_ID_SHIFT 16
#define IMX_USB3_USBSS_DB32_DB_STREAM_ID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_DB32_DB_STREAM_ID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_XECP_PORT_CAP_REG - Extended capability for USB 3. */
typedef union IMX_USB3_USBSS_XECP_PORT_CAP_REG_union_t {
    uint32_t R;
    struct {
        uint32_t XHCI_PORT_CAP_ID :8;            /* XHCI_PORT_CAP_ID. Port capability ID. */
        uint32_t XHCI_PORT_CAPABILITY_DW :8;     /* XHCI_PORT_CAPABILITY_DW. Next Item Pointer. This field provides an offset pointing to the location of next item in the functions capability list. */
        uint32_t XHCI_PORT_CAP_REV :8;           /* XHCI_PORT_CAP_REV : revision of the Port Capability structure . */
        uint32_t LPM_2_STB_SWITCH_CAPABLE :1;    /* xHC is capable of switching to stb_clk. */
        uint32_t LPM_2_STB_SWITCH_EN :1;         /* Enable switching to stb_clk. */
        uint32_t _unused26   :6;                 /* Reserved, RO */
    } B;
} IMX_USB3_USBSS_XECP_PORT_CAP_REG_t;

/* Register XECP_PORT_CAP_REG - Extended capability for USB 3. */
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_OFFSET 0x18000
/* Field XHCI_PORT_CAP_ID - XHCI_PORT_CAP_ID. Port capability ID. */
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAP_ID_SHIFT 0
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAP_ID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAP_ID(v) (((v) << 0) & 0xFF)
/* Field XHCI_PORT_CAPABILITY_DW - XHCI_PORT_CAPABILITY_DW. Next Item Pointer. This field provides an offset pointing to the location of next item in the functions capability list. */
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAPABILITY_DW_SHIFT 8
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAPABILITY_DW_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAPABILITY_DW(v) (((v) << 0x8) & 0xFF00)
/* Field XHCI_PORT_CAP_REV - XHCI_PORT_CAP_REV : revision of the Port Capability structure . */
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAP_REV_SHIFT 16
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAP_REV_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_XHCI_PORT_CAP_REV(v) (((v) << 0x10) & 0xFF0000)
/* Field LPM_2_STB_SWITCH_CAPABLE - xHC is capable of switching to stb_clk. */
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_LPM_2_STB_SWITCH_CAPABLE_SHIFT 24
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_LPM_2_STB_SWITCH_CAPABLE_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_LPM_2_STB_SWITCH_CAPABLE(v) (((v) << 0x18) & 0x1000000)
/* Field LPM_2_STB_SWITCH_EN - Enable switching to stb_clk. */
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_LPM_2_STB_SWITCH_EN_SHIFT 25
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_LPM_2_STB_SWITCH_EN_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_PORT_CAP_REG_LPM_2_STB_SWITCH_EN(v) (((v) << 0x19) & 0x2000000)

/* IMX_USB3_USBSS_XECP_PORT_1_REG - Extended capability for USB 3. */
typedef union IMX_USB3_USBSS_XECP_PORT_1_REG_union_t {
    uint32_t R;
    struct {
        uint32_t TRAINING_FAIL :1;               /* When reading: Link Polling training error flag status, When writing '1': clear the Link Polling training error flag, When writing '0': no effect */
        uint32_t TERM_DEB_MAX :2;                /* Number of the consecutive lack of Far-end Rx Termination detected that causes transition from SS.Inactive to RxDetect state */
        uint32_t U3_SPUR_LFPS_FIX :1;            /* Enable filtering out spurious LFPS when entering U3 state */
        uint32_t SKP_OS_FIX  :1;                 /* Change counting number of symbols for SKP OS insertion (only for the 1st SKP OS) */
        uint32_t TTIME_FOR_RESET_EN :1;          /* Enable tTimeForResetError timer */
        uint32_t _unused6    :2;                 /* Reserved, RO */
        uint32_t U1_LFPS_MINGEN_TIME :7;         /* Minimum U1 LFPS generation time. Written only if U1_LFPS_TIME_WR_STROBE is 1. */
        uint32_t U1_LFPS_TIME_WR_STROBE :1;      /* Minimum U1 LFPS generation time write stobe. Returns '0' when read. */
        uint32_t _unused16   :16;                /* Reserved, RO */
    } B;
} IMX_USB3_USBSS_XECP_PORT_1_REG_t;

/* Register XECP_PORT_1_REG - Extended capability for USB 3. */
#define IMX_USB3_USBSS_XECP_PORT_1_REG_OFFSET 0x18004
/* Field TRAINING_FAIL - When reading: Link Polling training error flag status, When writing '1': clear the Link Polling training error flag, When writing '0': no effect */
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TRAINING_FAIL_SHIFT 0
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TRAINING_FAIL_MASK 0x1
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TRAINING_FAIL(v) (((v) << 0) & 0x1)
/* Field TERM_DEB_MAX - Number of the consecutive lack of Far-end Rx Termination detected that causes transition from SS.Inactive to RxDetect state */
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TERM_DEB_MAX_SHIFT 1
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TERM_DEB_MAX_MASK 0x6
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TERM_DEB_MAX(v) (((v) << 0x1) & 0x6)
/* Field U3_SPUR_LFPS_FIX - Enable filtering out spurious LFPS when entering U3 state */
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U3_SPUR_LFPS_FIX_SHIFT 3
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U3_SPUR_LFPS_FIX_MASK 0x8
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U3_SPUR_LFPS_FIX(v) (((v) << 0x3) & 0x8)
/* Field SKP_OS_FIX - Change counting number of symbols for SKP OS insertion (only for the 1st SKP OS) */
#define IMX_USB3_USBSS_XECP_PORT_1_REG_SKP_OS_FIX_SHIFT 4
#define IMX_USB3_USBSS_XECP_PORT_1_REG_SKP_OS_FIX_MASK 0x10
#define IMX_USB3_USBSS_XECP_PORT_1_REG_SKP_OS_FIX(v) (((v) << 0x4) & 0x10)
/* Field TTIME_FOR_RESET_EN - Enable tTimeForResetError timer */
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TTIME_FOR_RESET_EN_SHIFT 5
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TTIME_FOR_RESET_EN_MASK 0x20
#define IMX_USB3_USBSS_XECP_PORT_1_REG_TTIME_FOR_RESET_EN(v) (((v) << 0x5) & 0x20)
/* Field U1_LFPS_MINGEN_TIME - Minimum U1 LFPS generation time. Written only if U1_LFPS_TIME_WR_STROBE is 1. */
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U1_LFPS_MINGEN_TIME_SHIFT 8
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U1_LFPS_MINGEN_TIME_MASK 0x7F00
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U1_LFPS_MINGEN_TIME(v) (((v) << 0x8) & 0x7F00)
/* Field U1_LFPS_TIME_WR_STROBE - Minimum U1 LFPS generation time write stobe. Returns '0' when read. */
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U1_LFPS_TIME_WR_STROBE_SHIFT 15
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U1_LFPS_TIME_WR_STROBE_MASK 0x8000
#define IMX_USB3_USBSS_XECP_PORT_1_REG_U1_LFPS_TIME_WR_STROBE(v) (((v) << 0xF) & 0x8000)

/* IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP - xHCI Debug Bus Capability. */
typedef union IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_union_t {
    uint32_t R;
    struct {
        uint32_t XHCI_DEBUG_BUS_CAP_ID :8;       /* Capability ID, RO. This field identifies the extended capability. For xHCI Debug Bus its' value is 196. */
        uint32_t XHCI_DEBUG_BUS_DW :8;           /* Next Capability Pointer, RO. This field indicates the location of the next capability with respect to the effective address of this capability. */
        uint32_t _unused16   :15;                /* Reserved */
        uint32_t CPU_DEBUG_EN :1;                /* Debug Bus Enable, RW. When 0, allows the xhci_debug_sel primary input to control selection of Debug Bus sources. When 1, allows the cpu_debug_bus_sel field in the XECP_CDNS_DEBUG_BUS_CTRL register to control selection of Debug Bus sources. Default value after reset is '0'. */
    } B;
} IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_t;

/* Register XECP_CDNS_DEBUG_BUS_CAP - xHCI Debug Bus Capability. */
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_OFFSET 0x18008
/* Field XHCI_DEBUG_BUS_CAP_ID - Capability ID, RO. This field identifies the extended capability. For xHCI Debug Bus its' value is 196. */
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_XHCI_DEBUG_BUS_CAP_ID_SHIFT 0
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_XHCI_DEBUG_BUS_CAP_ID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_XHCI_DEBUG_BUS_CAP_ID(v) (((v) << 0) & 0xFF)
/* Field XHCI_DEBUG_BUS_DW - Next Capability Pointer, RO. This field indicates the location of the next capability with respect to the effective address of this capability. */
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_XHCI_DEBUG_BUS_DW_SHIFT 8
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_XHCI_DEBUG_BUS_DW_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_XHCI_DEBUG_BUS_DW(v) (((v) << 0x8) & 0xFF00)
/* Field CPU_DEBUG_EN - Debug Bus Enable, RW. When 0, allows the xhci_debug_sel primary input to control selection of Debug Bus sources. When 1, allows the cpu_debug_bus_sel field in the XECP_CDNS_DEBUG_BUS_CTRL register to control selection of Debug Bus sources. Default value after reset is '0'. */
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_CPU_DEBUG_EN_SHIFT 31
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_CPU_DEBUG_EN_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_CPU_DEBUG_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CTRL - xHCI Debug Bus Control. */
typedef union IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CTRL_union_t {
    uint32_t R;
    struct {
        uint32_t CPU_DEBUG_BUS_SEL :5;           /* Debug Bus Select, RW. Value of this field determines a source of Debug Bus. Default value after reset is 0. */
        uint32_t _unused5    :27;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CTRL_t;

/* Register XECP_CDNS_DEBUG_BUS_CTRL - xHCI Debug Bus Control. */
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CTRL_OFFSET 0x1800C
/* Field CPU_DEBUG_BUS_SEL - Debug Bus Select, RW. Value of this field determines a source of Debug Bus. Default value after reset is 0. */
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CTRL_CPU_DEBUG_BUS_SEL_SHIFT 0
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CTRL_CPU_DEBUG_BUS_SEL_MASK 0x1F
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CTRL_CPU_DEBUG_BUS_SEL(v) (((v) << 0) & 0x1F)

/* IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_STATUS - xHCI Debug Bus Status. */
typedef union IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_STATUS_union_t {
    uint32_t R;
    struct {
        uint32_t XHCI_DEBUG_BUS :32;             /* Debug Bus, RO. Debug Bus current value. Note for multi-bit probes, this register is only suitable for analysing a static value due to simplified clock domain synchronisation */
    } B;
} IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_STATUS_t;

/* Register XECP_CDNS_DEBUG_BUS_STATUS - xHCI Debug Bus Status. */
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_STATUS_OFFSET 0x18010
/* Field XHCI_DEBUG_BUS - Debug Bus, RO. Debug Bus current value. Note for multi-bit probes, this register is only suitable for analysing a static value due to simplified clock domain synchronisation */
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_STATUS_XHCI_DEBUG_BUS_SHIFT 0
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_STATUS_XHCI_DEBUG_BUS_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_STATUS_XHCI_DEBUG_BUS(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_PM_CAP - Extended Power Management capability register. */
typedef union IMX_USB3_USBSS_XECP_PM_CAP_union_t {
    uint32_t R;
    struct {
        uint32_t XHCI_PM_CAP_ID :8;              /* XHCI_PM_CAP_ID. Power Management capability ID. */
        uint32_t XHCI_PM_CAPABILITY_DW :8;       /* XHCI_PM_CAPABILITY_DW. Next Item Pointer. This field provides an offset pointing to the location of next item in the functions capability list. */
        uint32_t VERSION     :3;                 /* Power Management Capabilities: Version. Default = '011'. A value of '011' indicates that this function complies with revision 1.2 of the PCI Power Management Interface Specification. */
        uint32_t PME_CLOCK   :1;                 /* Power Management Capabilities: PME Clock. Default = '0'. When this bit is a '1', it indicates that the function relies on the presence of the PCI clock for PME# operation. When this bit is a '0', it indicates that no PCI clock is required for the function to generate PME#. Functions that do not support PME# generation in any state must return '0' for this field. */
        uint32_t RESERVED    :1;                 /* reserved */
        uint32_t DSI         :1;                 /* Power Management Capabilities: DSI. Default = device specific. The Device Specific Initialization bit indicates whether special initialization of this function is required (beyond the standard PCI configuration header) before the generic class device driver is able to use it. Note that this bit is not used by some operating systems. Microsoft Windows and Windows NT, for instance, do not use this bit to determine whether to use D3. Instead, they use the drivers capabilities to determine this. A '1' indicates that the function requires a device specific initialization sequence following transition to the D0 uninitialized state. For more information refer to Section 8.3. of PCI bus Power Management specification. */
        uint32_t AUX_CURRENT :3;                 /* Power Management Capabilities: Aux_Current. Default = device specific. This 3 bit field reports the 3.3Vaux auxiliary current requirements for the PCI function. If the Data Register field of XECP_PM_PMCSR has been implemented by this function: - reads of this field must return a value of '000', - the Data Register takes precedence over this field for 3.3Vaux current requirement reporting. If PME# generation from D3cold is not supported by the function (XECP_PM_CAP[15]='0'), this field must return a value of '000' when read. For functions that support PME# from D3cold, and do not implement the Data Register, the following bit encoding for maximum current required apply : '111': 375 mA, '110': 320 mA, '101': 270 mA, '100': 220 mA, '011': 160 mA, '010': 100 mA, '001': 55 mA, '000': 0 (self powered). */
        uint32_t D1_SUPPORT  :1;                 /* Power Management Capabilities: D1_Support. Default = device specific. If this bit is a '1', this function supports the D1 Power Management State. Functions that do not support D1 must always return a value of '0' for this bit. */
        uint32_t D2_SUPPORT  :1;                 /* Power Management Capabilities: D2_Support. Default = device specific. If this bit is a '1', this function supports the D2 Power Management State. Functions that do not support D2 must always return a value of '0' for this bit. */
        uint32_t PME_SUPPORT :5;                 /* Power Management Capabilities: PME_Support. Default = device specific. This 5-bit field indicates the power states in which the function may assert PME#. A value of '0' for any bit indicates that the function is not capable of asserting the PME# signal while in that power state. Encodings: bit 0 set: X XXX1b - PME# can be asserted from D0, bit 1 set: X XX1Xb - PME# can be asserted from D1, bit 2 set: X X1XXb - PME# can be asserted from D2, bit 3 set: X 1XXXb - PME# can be asserted from D3hot, bit 4 set: 1 XXXXb - PME# can be asserted from D3cold */
    } B;
} IMX_USB3_USBSS_XECP_PM_CAP_t;

/* Register XECP_PM_CAP - Extended Power Management capability register. */
#define IMX_USB3_USBSS_XECP_PM_CAP_OFFSET 0x18014
/* Field XHCI_PM_CAP_ID - XHCI_PM_CAP_ID. Power Management capability ID. */
#define IMX_USB3_USBSS_XECP_PM_CAP_XHCI_PM_CAP_ID_SHIFT 0
#define IMX_USB3_USBSS_XECP_PM_CAP_XHCI_PM_CAP_ID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_PM_CAP_XHCI_PM_CAP_ID(v) (((v) << 0) & 0xFF)
/* Field XHCI_PM_CAPABILITY_DW - XHCI_PM_CAPABILITY_DW. Next Item Pointer. This field provides an offset pointing to the location of next item in the functions capability list. */
#define IMX_USB3_USBSS_XECP_PM_CAP_XHCI_PM_CAPABILITY_DW_SHIFT 8
#define IMX_USB3_USBSS_XECP_PM_CAP_XHCI_PM_CAPABILITY_DW_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_PM_CAP_XHCI_PM_CAPABILITY_DW(v) (((v) << 0x8) & 0xFF00)
/* Field VERSION - Power Management Capabilities: Version. Default = '011'. A value of '011' indicates that this function complies with revision 1.2 of the PCI Power Management Interface Specification. */
#define IMX_USB3_USBSS_XECP_PM_CAP_VERSION_SHIFT 16
#define IMX_USB3_USBSS_XECP_PM_CAP_VERSION_MASK 0x70000
#define IMX_USB3_USBSS_XECP_PM_CAP_VERSION(v) (((v) << 0x10) & 0x70000)
/* Field PME_CLOCK - Power Management Capabilities: PME Clock. Default = '0'. When this bit is a '1', it indicates that the function relies on the presence of the PCI clock for PME# operation. When this bit is a '0', it indicates that no PCI clock is required for the function to generate PME#. Functions that do not support PME# generation in any state must return '0' for this field. */
#define IMX_USB3_USBSS_XECP_PM_CAP_PME_CLOCK_SHIFT 19
#define IMX_USB3_USBSS_XECP_PM_CAP_PME_CLOCK_MASK 0x80000
#define IMX_USB3_USBSS_XECP_PM_CAP_PME_CLOCK(v) (((v) << 0x13) & 0x80000)
/* Field RESERVED - reserved */
#define IMX_USB3_USBSS_XECP_PM_CAP_RESERVED_SHIFT 20
#define IMX_USB3_USBSS_XECP_PM_CAP_RESERVED_MASK 0x100000
#define IMX_USB3_USBSS_XECP_PM_CAP_RESERVED(v) (((v) << 0x14) & 0x100000)
/* Field DSI - Power Management Capabilities: DSI. Default = device specific. The Device Specific Initialization bit indicates whether special initialization of this function is required (beyond the standard PCI configuration header) before the generic class device driver is able to use it. Note that this bit is not used by some operating systems. Microsoft Windows and Windows NT, for instance, do not use this bit to determine whether to use D3. Instead, they use the drivers capabilities to determine this. A '1' indicates that the function requires a device specific initialization sequence following transition to the D0 uninitialized state. For more information refer to Section 8.3. of PCI bus Power Management specification. */
#define IMX_USB3_USBSS_XECP_PM_CAP_DSI_SHIFT 21
#define IMX_USB3_USBSS_XECP_PM_CAP_DSI_MASK 0x200000
#define IMX_USB3_USBSS_XECP_PM_CAP_DSI(v) (((v) << 0x15) & 0x200000)
/* Field AUX_CURRENT - Power Management Capabilities: Aux_Current. Default = device specific. This 3 bit field reports the 3.3Vaux auxiliary current requirements for the PCI function. If the Data Register field of XECP_PM_PMCSR has been implemented by this function: - reads of this field must return a value of '000', - the Data Register takes precedence over this field for 3.3Vaux current requirement reporting. If PME# generation from D3cold is not supported by the function (XECP_PM_CAP[15]='0'), this field must return a value of '000' when read. For functions that support PME# from D3cold, and do not implement the Data Register, the following bit encoding for maximum current required apply : '111': 375 mA, '110': 320 mA, '101': 270 mA, '100': 220 mA, '011': 160 mA, '010': 100 mA, '001': 55 mA, '000': 0 (self powered). */
#define IMX_USB3_USBSS_XECP_PM_CAP_AUX_CURRENT_SHIFT 22
#define IMX_USB3_USBSS_XECP_PM_CAP_AUX_CURRENT_MASK 0x1C00000
#define IMX_USB3_USBSS_XECP_PM_CAP_AUX_CURRENT(v) (((v) << 0x16) & 0x1C00000)
/* Field D1_SUPPORT - Power Management Capabilities: D1_Support. Default = device specific. If this bit is a '1', this function supports the D1 Power Management State. Functions that do not support D1 must always return a value of '0' for this bit. */
#define IMX_USB3_USBSS_XECP_PM_CAP_D1_SUPPORT_SHIFT 25
#define IMX_USB3_USBSS_XECP_PM_CAP_D1_SUPPORT_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_PM_CAP_D1_SUPPORT(v) (((v) << 0x19) & 0x2000000)
/* Field D2_SUPPORT - Power Management Capabilities: D2_Support. Default = device specific. If this bit is a '1', this function supports the D2 Power Management State. Functions that do not support D2 must always return a value of '0' for this bit. */
#define IMX_USB3_USBSS_XECP_PM_CAP_D2_SUPPORT_SHIFT 26
#define IMX_USB3_USBSS_XECP_PM_CAP_D2_SUPPORT_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_PM_CAP_D2_SUPPORT(v) (((v) << 0x1A) & 0x4000000)
/* Field PME_SUPPORT - Power Management Capabilities: PME_Support. Default = device specific. This 5-bit field indicates the power states in which the function may assert PME#. A value of '0' for any bit indicates that the function is not capable of asserting the PME# signal while in that power state. Encodings: bit 0 set: X XXX1b - PME# can be asserted from D0, bit 1 set: X XX1Xb - PME# can be asserted from D1, bit 2 set: X X1XXb - PME# can be asserted from D2, bit 3 set: X 1XXXb - PME# can be asserted from D3hot, bit 4 set: 1 XXXXb - PME# can be asserted from D3cold */
#define IMX_USB3_USBSS_XECP_PM_CAP_PME_SUPPORT_SHIFT 27
#define IMX_USB3_USBSS_XECP_PM_CAP_PME_SUPPORT_MASK 0xF8000000
#define IMX_USB3_USBSS_XECP_PM_CAP_PME_SUPPORT(v) (((v) << 0x1B) & 0xF8000000)

/* IMX_USB3_USBSS_XECP_PM_PMCSR - Extended Power Management Control/Status register. */
typedef union IMX_USB3_USBSS_XECP_PM_PMCSR_union_t {
    uint32_t R;
    struct {
        uint32_t POWERSTATE  :2;                 /* Power Management Control/Status Register: PowerState. Default = zero. This 2-bit field is used both to determine the current power state of a function and to set the function into a new power state. Possible values: '00': D0, '01': D1, '10': D2, '11': D3hot. If software attempts to write an unsupported, optional state to this field, the write operation must complete normally on the bus; however, the data is discarded and no state change occurs. */
        uint32_t RESERVED1   :1;                 /* Power Management Control/Status Register: reserved */
        uint32_t NO_SOFT_RESET :1;               /* Power Management Control/Status Register: No_Soft_Reset. Default = device specific. When set to '1', this bit indicates that devices transitioning from D3hot to D0 because of PowerState commands do not perform an internal reset. Configuration Context is preserved. Upon transition from the D3hot to the D0 Initialized state, no additional operating system intervention is required to preserve Configuration Context beyond writing the PowerState bits. When cleared to '0', devices do perform an internal reset upon transitioning from D3hot to D0 via software control of the PowerState bits. Configuration Context is lost when performing the soft reset. Upon transition from the D3hot to the D0 state, full reinitialization sequence is needed to return the device to D0 Initialized. Regardless of this bit, devices that transition from D3hot to D0 by a system or bus segment reset will return to the device state D0 Uninitialized with only PME context preserved if PME is supported and enabled. */
        uint32_t RESERVED2   :4;                 /* Power Management Control/Status Register: reserved */
        uint32_t PME_EN      :1;                 /* Power Management Control/Status Register: PME_En. A '1' in this field enables the function to assert PME#. When '0', PME# assertion is disabled. This bit defaults to '0' if the function does not support PME# generation from D3cold. If the function supports PME# from D3cold, then this bit is sticky and must be explicitly cleared by the operating system each time it is initially loaded. Functions that do not support PME# generation from any D-state (i.e., XECP_PM_CAP[15:11] = '00000'), may hardwire this bit to be read-only always returning a '0' when read by system software. */
        uint32_t DATA_SELECT :4;                 /* Power Management Control/Status Register: Data_Select. Default = zero. This 4-bit field is used to select, which data is to be reported through the Data register and Data_Scale fields of XECP_PM_PMCSR register. This field is a required component of the Data register and must be implemented if the Data register is implemented. If the Data register field of XECP_PM_PMCSR is not implemented, this field should be read only and return zero when read. Refer to Section 3.2.6 of PCI bus Power Management for more details. */
        uint32_t DATA_SCALE  :2;                 /* Power Management Control/Status Register: Data_Scale. Default = device specific. This 2-bit read-only field indicates the scaling factor to be used when interpreting the value of the Data register field of XECP_PM_PMCSR register. The value and meaning of this field will vary depending on which data value has been selected by the Data_Select field of this register. This field is a required component of the Data register and must be implemented if the Data register is implemented. If the Data register has not been implemented, this field must return zero when read. Refer to Section 3.2.6 of PCI bus Power Management specification for more details. */
        uint32_t PME_STATUS  :1;                 /* Power Management Control/Status Register: PME_Status. This bit is set when the function would normally assert the PME# signal independent of the state of the PME_En bit. Writing a '1' to this bit will clear it and cause the function to stop asserting a PME# (if enabled). Writing a '0' has no effect. This bit defaults to '0' if the function does not support PME# generation from D3cold. If the function supports PME# from D3cold, then this bit is sticky and must be explicitly cleared by the operating system each time the operating system is initially loaded. */
        uint32_t RESERVED3   :6;                 /* PMCSR Bridge Support Extensions: reserved */
        uint32_t B2_B3       :1;                 /* PMCSR Bridge Support Extensions: B2_B3# (B2/B3 support for D3hot). External strap or internally hardwired. The state of this bit determines the action that is to occur as a direct result of programming the function to D3hot. A '1' indicates that when the bridge function is programmed to D3hot, its secondary buss PCI clock will be stopped (B2). A '0' indicates that when the bridge function is programmed to D3hot, its secondary bus will have its power removed (B3). This bit is only meaningful if bit BPCC_En of XECP_PM_PMCSR register is a '1'. Refer to Section 4.7.1 of PCI bus Power Management specification for details. */
        uint32_t BPCC_EN     :1;                 /* PMCSR Bridge Support Extensions: BPCC_En (Bus Power/Clock Control Enable). External strap or internally hardwired. A '1' indicates that the bus power/clock control mechanism as defined in Section 4.7.1 PCI bus Power Management specification is enabled. A '0' indicates that the bus power/clock control policies defined in Section 4.7.1 PCI bus Power Management specification have been disabled. When the Bus Power/Clock Control mechanism is disabled, the bridges Power Management Control/Status Register PowerState field cannot be used by the system software to control the power or clock of the bridges secondary bus. */
        uint32_t DATA_REGISTER :8;               /* Data register. This register is used to report the state dependent data requested by the Data_Select field of XECP_PM_PMCSR register. The value of Data register is scaled by the value reported by the Data_Scale field of XECP_PM_PMCSR register. */
    } B;
} IMX_USB3_USBSS_XECP_PM_PMCSR_t;

/* Register XECP_PM_PMCSR - Extended Power Management Control/Status register. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_OFFSET 0x18018
/* Field POWERSTATE - Power Management Control/Status Register: PowerState. Default = zero. This 2-bit field is used both to determine the current power state of a function and to set the function into a new power state. Possible values: '00': D0, '01': D1, '10': D2, '11': D3hot. If software attempts to write an unsupported, optional state to this field, the write operation must complete normally on the bus; however, the data is discarded and no state change occurs. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_POWERSTATE_SHIFT 0
#define IMX_USB3_USBSS_XECP_PM_PMCSR_POWERSTATE_MASK 0x3
#define IMX_USB3_USBSS_XECP_PM_PMCSR_POWERSTATE(v) (((v) << 0) & 0x3)
/* Field RESERVED1 - Power Management Control/Status Register: reserved */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED1_SHIFT 2
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED1_MASK 0x4
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED1(v) (((v) << 0x2) & 0x4)
/* Field NO_SOFT_RESET - Power Management Control/Status Register: No_Soft_Reset. Default = device specific. When set to '1', this bit indicates that devices transitioning from D3hot to D0 because of PowerState commands do not perform an internal reset. Configuration Context is preserved. Upon transition from the D3hot to the D0 Initialized state, no additional operating system intervention is required to preserve Configuration Context beyond writing the PowerState bits. When cleared to '0', devices do perform an internal reset upon transitioning from D3hot to D0 via software control of the PowerState bits. Configuration Context is lost when performing the soft reset. Upon transition from the D3hot to the D0 state, full reinitialization sequence is needed to return the device to D0 Initialized. Regardless of this bit, devices that transition from D3hot to D0 by a system or bus segment reset will return to the device state D0 Uninitialized with only PME context preserved if PME is supported and enabled. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_NO_SOFT_RESET_SHIFT 3
#define IMX_USB3_USBSS_XECP_PM_PMCSR_NO_SOFT_RESET_MASK 0x8
#define IMX_USB3_USBSS_XECP_PM_PMCSR_NO_SOFT_RESET(v) (((v) << 0x3) & 0x8)
/* Field RESERVED2 - Power Management Control/Status Register: reserved */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED2_SHIFT 4
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED2_MASK 0xF0
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED2(v) (((v) << 0x4) & 0xF0)
/* Field PME_EN - Power Management Control/Status Register: PME_En. A '1' in this field enables the function to assert PME#. When '0', PME# assertion is disabled. This bit defaults to '0' if the function does not support PME# generation from D3cold. If the function supports PME# from D3cold, then this bit is sticky and must be explicitly cleared by the operating system each time it is initially loaded. Functions that do not support PME# generation from any D-state (i.e., XECP_PM_CAP[15:11] = '00000'), may hardwire this bit to be read-only always returning a '0' when read by system software. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_PME_EN_SHIFT 8
#define IMX_USB3_USBSS_XECP_PM_PMCSR_PME_EN_MASK 0x100
#define IMX_USB3_USBSS_XECP_PM_PMCSR_PME_EN(v) (((v) << 0x8) & 0x100)
/* Field DATA_SELECT - Power Management Control/Status Register: Data_Select. Default = zero. This 4-bit field is used to select, which data is to be reported through the Data register and Data_Scale fields of XECP_PM_PMCSR register. This field is a required component of the Data register and must be implemented if the Data register is implemented. If the Data register field of XECP_PM_PMCSR is not implemented, this field should be read only and return zero when read. Refer to Section 3.2.6 of PCI bus Power Management for more details. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_SELECT_SHIFT 9
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_SELECT_MASK 0x1E00
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_SELECT(v) (((v) << 0x9) & 0x1E00)
/* Field DATA_SCALE - Power Management Control/Status Register: Data_Scale. Default = device specific. This 2-bit read-only field indicates the scaling factor to be used when interpreting the value of the Data register field of XECP_PM_PMCSR register. The value and meaning of this field will vary depending on which data value has been selected by the Data_Select field of this register. This field is a required component of the Data register and must be implemented if the Data register is implemented. If the Data register has not been implemented, this field must return zero when read. Refer to Section 3.2.6 of PCI bus Power Management specification for more details. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_SCALE_SHIFT 13
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_SCALE_MASK 0x6000
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_SCALE(v) (((v) << 0xD) & 0x6000)
/* Field PME_STATUS - Power Management Control/Status Register: PME_Status. This bit is set when the function would normally assert the PME# signal independent of the state of the PME_En bit. Writing a '1' to this bit will clear it and cause the function to stop asserting a PME# (if enabled). Writing a '0' has no effect. This bit defaults to '0' if the function does not support PME# generation from D3cold. If the function supports PME# from D3cold, then this bit is sticky and must be explicitly cleared by the operating system each time the operating system is initially loaded. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_PME_STATUS_SHIFT 15
#define IMX_USB3_USBSS_XECP_PM_PMCSR_PME_STATUS_MASK 0x8000
#define IMX_USB3_USBSS_XECP_PM_PMCSR_PME_STATUS(v) (((v) << 0xF) & 0x8000)
/* Field RESERVED3 - PMCSR Bridge Support Extensions: reserved */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED3_SHIFT 16
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED3_MASK 0x3F0000
#define IMX_USB3_USBSS_XECP_PM_PMCSR_RESERVED3(v) (((v) << 0x10) & 0x3F0000)
/* Field B2_B3 - PMCSR Bridge Support Extensions: B2_B3# (B2/B3 support for D3hot). External strap or internally hardwired. The state of this bit determines the action that is to occur as a direct result of programming the function to D3hot. A '1' indicates that when the bridge function is programmed to D3hot, its secondary buss PCI clock will be stopped (B2). A '0' indicates that when the bridge function is programmed to D3hot, its secondary bus will have its power removed (B3). This bit is only meaningful if bit BPCC_En of XECP_PM_PMCSR register is a '1'. Refer to Section 4.7.1 of PCI bus Power Management specification for details. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_B2_B3_SHIFT 22
#define IMX_USB3_USBSS_XECP_PM_PMCSR_B2_B3_MASK 0x400000
#define IMX_USB3_USBSS_XECP_PM_PMCSR_B2_B3(v) (((v) << 0x16) & 0x400000)
/* Field BPCC_EN - PMCSR Bridge Support Extensions: BPCC_En (Bus Power/Clock Control Enable). External strap or internally hardwired. A '1' indicates that the bus power/clock control mechanism as defined in Section 4.7.1 PCI bus Power Management specification is enabled. A '0' indicates that the bus power/clock control policies defined in Section 4.7.1 PCI bus Power Management specification have been disabled. When the Bus Power/Clock Control mechanism is disabled, the bridges Power Management Control/Status Register PowerState field cannot be used by the system software to control the power or clock of the bridges secondary bus. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_BPCC_EN_SHIFT 23
#define IMX_USB3_USBSS_XECP_PM_PMCSR_BPCC_EN_MASK 0x800000
#define IMX_USB3_USBSS_XECP_PM_PMCSR_BPCC_EN(v) (((v) << 0x17) & 0x800000)
/* Field DATA_REGISTER - Data register. This register is used to report the state dependent data requested by the Data_Select field of XECP_PM_PMCSR register. The value of Data register is scaled by the value reported by the Data_Scale field of XECP_PM_PMCSR register. */
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_REGISTER_SHIFT 24
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_REGISTER_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_PM_PMCSR_DATA_REGISTER(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_MSI_CAP - Message Signaled Interrupts (MSI) configuration register. */
typedef union IMX_USB3_USBSS_XECP_MSI_CAP_union_t {
    uint32_t R;
    struct {
        uint32_t MSI_ID      :8;                 /* Capability ID for Message Signaled Interrupts. The value of 05h in this field identifies the function as being MSI capable. */
        uint32_t XECP_MSI_CAP_OFFSET :8;         /* Pointer to the next item in the capabilities list. A non-zero value in this field indicates a relative offset, in 32-bit words, from this 32-bit word to the beginning of the next extended capability. */
        uint32_t MSI_EN      :1;                 /* MSI Message Control: MSI enable. System configuration software sets this bit to enable MSI. A device driver is prohibited from writing this bit to mask a functions service request. If '0', the function is prohibited from using MSI to request service. This bits state after reset is '0' (MSI is disabled). */
        uint32_t MSI_MMC     :3;                 /* MSI Message Control: Multiple Message Capable. System software reads this field to determine the number of requested vectors. The number of requested vectors must be aligned to a power of two (if a function requires three vectors, it requests four by initializing this field to '010'). The encoding is defined as: '000': 1, '001': 2, '010': 4, '011': 8, '100': 16, '101': 32, '110': Reserved, '111': Reserved. This field is read only. */
        uint32_t MSI_MME     :3;                 /* MSI Message Control: Multiple Message Enable. Software writes to this field to indicate the number of allocated vectors (equal to or less than the number of requested vectors). The number of allocated vectors is aligned to a power of two. If a function requests four vectors (indicated by a Multiple Message Capable encoding of 010), system software can allocate either four, two, or one vector by writing a '010', '001', or '000' to this field, respectively. When MSI is enabled, a function will be allocated at least one vector. The encoding is defined as: '000': 1, '001': 2, '010': 4, '011': 8, '100': 16, '101': 32, '110': Reserved, '111': Reserved. This fields state after reset is '000'. */
        uint32_t AC64        :1;                 /* MSI Message Control: 64 bit address capable. If '1', the function is capable of generating sending a 64-bit message address. If '0', the function is not capable of generating sending a 64-bit message address. This bit is read only. */
        uint32_t PER_VECTOR_MASKING :1;          /* MSI Message Control: Per-vector masking capable. If '1', the function supports MSI per-vector masking. If '0', the function does not support MSI per-vector masking. This bit is read only. Not Supported in this configuration */
        uint32_t _unused25   :7;                 /* MSI Message Control: Reserved. Always returns 0 on a read and a write operation has no effect. */
    } B;
} IMX_USB3_USBSS_XECP_MSI_CAP_t;

/* Register XECP_MSI_CAP - Message Signaled Interrupts (MSI) configuration register. */
#define IMX_USB3_USBSS_XECP_MSI_CAP_OFFSET 0x1801C
/* Field MSI_ID - Capability ID for Message Signaled Interrupts. The value of 05h in this field identifies the function as being MSI capable. */
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_ID_SHIFT 0
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_ID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_ID(v) (((v) << 0) & 0xFF)
/* Field XECP_MSI_CAP_OFFSET - Pointer to the next item in the capabilities list. A non-zero value in this field indicates a relative offset, in 32-bit words, from this 32-bit word to the beginning of the next extended capability. */
#define IMX_USB3_USBSS_XECP_MSI_CAP_XECP_MSI_CAP_OFFSET_SHIFT 8
#define IMX_USB3_USBSS_XECP_MSI_CAP_XECP_MSI_CAP_OFFSET_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_MSI_CAP_XECP_MSI_CAP_OFFSET(v) (((v) << 0x8) & 0xFF00)
/* Field MSI_EN - MSI Message Control: MSI enable. System configuration software sets this bit to enable MSI. A device driver is prohibited from writing this bit to mask a functions service request. If '0', the function is prohibited from using MSI to request service. This bits state after reset is '0' (MSI is disabled). */
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_EN_SHIFT 16
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_EN_MASK 0x10000
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_EN(v) (((v) << 0x10) & 0x10000)
/* Field MSI_MMC - MSI Message Control: Multiple Message Capable. System software reads this field to determine the number of requested vectors. The number of requested vectors must be aligned to a power of two (if a function requires three vectors, it requests four by initializing this field to '010'). The encoding is defined as: '000': 1, '001': 2, '010': 4, '011': 8, '100': 16, '101': 32, '110': Reserved, '111': Reserved. This field is read only. */
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_MMC_SHIFT 17
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_MMC_MASK 0xE0000
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_MMC(v) (((v) << 0x11) & 0xE0000)
/* Field MSI_MME - MSI Message Control: Multiple Message Enable. Software writes to this field to indicate the number of allocated vectors (equal to or less than the number of requested vectors). The number of allocated vectors is aligned to a power of two. If a function requests four vectors (indicated by a Multiple Message Capable encoding of 010), system software can allocate either four, two, or one vector by writing a '010', '001', or '000' to this field, respectively. When MSI is enabled, a function will be allocated at least one vector. The encoding is defined as: '000': 1, '001': 2, '010': 4, '011': 8, '100': 16, '101': 32, '110': Reserved, '111': Reserved. This fields state after reset is '000'. */
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_MME_SHIFT 20
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_MME_MASK 0x700000
#define IMX_USB3_USBSS_XECP_MSI_CAP_MSI_MME(v) (((v) << 0x14) & 0x700000)
/* Field AC64 - MSI Message Control: 64 bit address capable. If '1', the function is capable of generating sending a 64-bit message address. If '0', the function is not capable of generating sending a 64-bit message address. This bit is read only. */
#define IMX_USB3_USBSS_XECP_MSI_CAP_AC64_SHIFT 23
#define IMX_USB3_USBSS_XECP_MSI_CAP_AC64_MASK 0x800000
#define IMX_USB3_USBSS_XECP_MSI_CAP_AC64(v) (((v) << 0x17) & 0x800000)
/* Field PER_VECTOR_MASKING - MSI Message Control: Per-vector masking capable. If '1', the function supports MSI per-vector masking. If '0', the function does not support MSI per-vector masking. This bit is read only. Not Supported in this configuration */
#define IMX_USB3_USBSS_XECP_MSI_CAP_PER_VECTOR_MASKING_SHIFT 24
#define IMX_USB3_USBSS_XECP_MSI_CAP_PER_VECTOR_MASKING_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_MSI_CAP_PER_VECTOR_MASKING(v) (((v) << 0x18) & 0x1000000)

/* IMX_USB3_USBSS_XECP_MSI_ADDR_L - Message Lower Address for MSI. */
typedef union IMX_USB3_USBSS_XECP_MSI_ADDR_L_union_t {
    uint32_t R;
    struct {
        uint32_t RESERVED    :2;                 /* Reserved. Always returns zero on read. Write operations have no effect. Those bits are driven to zero during the address phase. */
        uint32_t MSI_ADDR_LOW :30;               /* Message Lower Address for MSI. System-specified message address. If the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is set, the contents of this register specify the DWORD-aligned address for the MSI memory write transaction. Note: This field should not be written unless the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is cleared. This field is read/write. */
    } B;
} IMX_USB3_USBSS_XECP_MSI_ADDR_L_t;

/* Register XECP_MSI_ADDR_L - Message Lower Address for MSI. */
#define IMX_USB3_USBSS_XECP_MSI_ADDR_L_OFFSET 0x18020
/* Field RESERVED - Reserved. Always returns zero on read. Write operations have no effect. Those bits are driven to zero during the address phase. */
#define IMX_USB3_USBSS_XECP_MSI_ADDR_L_RESERVED_SHIFT 0
#define IMX_USB3_USBSS_XECP_MSI_ADDR_L_RESERVED_MASK 0x3
#define IMX_USB3_USBSS_XECP_MSI_ADDR_L_RESERVED(v) (((v) << 0) & 0x3)
/* Field MSI_ADDR_LOW - Message Lower Address for MSI. System-specified message address. If the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is set, the contents of this register specify the DWORD-aligned address for the MSI memory write transaction. Note: This field should not be written unless the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is cleared. This field is read/write. */
#define IMX_USB3_USBSS_XECP_MSI_ADDR_L_MSI_ADDR_LOW_SHIFT 2
#define IMX_USB3_USBSS_XECP_MSI_ADDR_L_MSI_ADDR_LOW_MASK 0xFFFFFFFC
#define IMX_USB3_USBSS_XECP_MSI_ADDR_L_MSI_ADDR_LOW(v) (((v) << 0x2) & 0xFFFFFFFC)

/* IMX_USB3_USBSS_XECP_MSI_ADDR_H - Message Upper Address for MSI. */
typedef union IMX_USB3_USBSS_XECP_MSI_ADDR_H_union_t {
    uint32_t R;
    struct {
        uint32_t MSI_ADDR_HI :32;                /* Message Upper Address for MSI. System-specified message upper address. Note: This field should not be written unless the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is cleared. This field is read/write. */
    } B;
} IMX_USB3_USBSS_XECP_MSI_ADDR_H_t;

/* Register XECP_MSI_ADDR_H - Message Upper Address for MSI. */
#define IMX_USB3_USBSS_XECP_MSI_ADDR_H_OFFSET 0x18024
/* Field MSI_ADDR_HI - Message Upper Address for MSI. System-specified message upper address. Note: This field should not be written unless the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is cleared. This field is read/write. */
#define IMX_USB3_USBSS_XECP_MSI_ADDR_H_MSI_ADDR_HI_SHIFT 0
#define IMX_USB3_USBSS_XECP_MSI_ADDR_H_MSI_ADDR_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_MSI_ADDR_H_MSI_ADDR_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_MSI_DATA - Message data for MSI. */
typedef union IMX_USB3_USBSS_XECP_MSI_DATA_union_t {
    uint32_t R;
    struct {
        uint32_t MSI_DATA    :16;                /* System-specified message data. If the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is set, the message data is driven onto the lower word (bits [15:0]) of the memory write transactions data phase. Bits [31:16] are driven to zero during the memory write transactions data phase. C/BE[3::0]# are asserted during the data phase of the memory write transaction. The Multiple Message Enable field of MSI Message Control (see MSI_MME field of XCEP_MSI_CAP register) defines the number of low order message data bits the function is permitted to modify to generate its system software allocated vectors. For example, a Multiple Message Enable encoding of '010' indicates the function has been allocated four vectors and is permitted to modify message data bits 1 and 0 (a function modifies the lower message data bits to generate the allocated number of vectors). If the Multiple Message Enable field is '000', the function is not permitted to modify the message data. Note: This field should not be written unless the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is cleared. This field is read/write. */
        uint32_t _unused16   :16;
    } B;
} IMX_USB3_USBSS_XECP_MSI_DATA_t;

/* Register XECP_MSI_DATA - Message data for MSI. */
#define IMX_USB3_USBSS_XECP_MSI_DATA_OFFSET 0x18028
/* Field MSI_DATA - System-specified message data. If the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is set, the message data is driven onto the lower word (bits [15:0]) of the memory write transactions data phase. Bits [31:16] are driven to zero during the memory write transactions data phase. C/BE[3::0]# are asserted during the data phase of the memory write transaction. The Multiple Message Enable field of MSI Message Control (see MSI_MME field of XCEP_MSI_CAP register) defines the number of low order message data bits the function is permitted to modify to generate its system software allocated vectors. For example, a Multiple Message Enable encoding of '010' indicates the function has been allocated four vectors and is permitted to modify message data bits 1 and 0 (a function modifies the lower message data bits to generate the allocated number of vectors). If the Multiple Message Enable field is '000', the function is not permitted to modify the message data. Note: This field should not be written unless the Message Enable bit of MSI Message Control (bit 16 of the XCEP_MSI_CAP register) is cleared. This field is read/write. */
#define IMX_USB3_USBSS_XECP_MSI_DATA_MSI_DATA_SHIFT 0
#define IMX_USB3_USBSS_XECP_MSI_DATA_MSI_DATA_MASK 0xFFFF
#define IMX_USB3_USBSS_XECP_MSI_DATA_MSI_DATA(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_XECP_AXI_CAP - AXI Master Wrapper Extended Capability. */
typedef union IMX_USB3_USBSS_XECP_AXI_CAP_union_t {
    uint32_t R;
    struct {
        uint32_t AXI_CAP_ID  :8;                 /* VEND_DEF_AXI_MASTER_WRAPPER_CAP_ID, RO. Vendor defined xHCI Extended Capability: 0xC2. This field identifies the AXI wrapper xHCI Extended capability. */
        uint32_t XECP_AXI_CAP_OFFSET :8;         /* Next capability Offset, RO. This field points to the xHC MMIO space offset of the next xHCI extended capability pointer. A value of 00h indicates the end of the extended capability list. A non-zero value in this register indicates a relative offset, in Dwords, from this Dword to the beginning of the next extended capability. */
        uint32_t AXI_ADDRESS_WIDTH_64 :1;        /* AXI address bus width capability, RO. '0': 32-bit address bus width, '1': 64-bit address bus width. */
        uint32_t _unused17   :5;                 /* Reserved */
        uint32_t AXI_MASTER_WRAPPER_SPLIT_BYTE_BURSTS :1; /* AXI_MASTER_WRAPPER_SPLIT_BYTE_BURSTS, RO. Presents information about AXI byte burst capability: '0': no byte bursts, '1': byte bursts enabled. */
        uint32_t AXI_DISABLE_OOO :1;             /* Disable Out-Of-Order R channel responses (AXI_MASTER_WRAPPER_DISABLE_OOO), RO. This relates to number of IDs used at AXI IF. If Out-Of-Order R channel responses are not disabled this count may be greater than one and in such a case the R channel responses may come Out-Of-Order. The flag gives information about number of used AXI IDs: '0': single ID, '1': multiple IDs. */
        uint32_t AXI_DATA_BUS_SIZE :3;           /* AXI_DATA_WORD_SIZE, RO. AXI data buses size capability. It uses AXI AxSIZE Encoding. Values of 64-bit ('011') or 128-bit ('100') are supported through compile time configuration. */
        uint32_t _unused27   :2;                 /* Reserved */
        uint32_t AXI_ERROR   :1;                 /* AXI ERROR, RW1C. Provides an information about AXI ERROR response on B or R channel. This flag is cleared by writing '1' to it. Once set it is held until cleared. The condition setting this register will also assert HSE. This flag may be read by software while handling HSE assertion to determine if the case was AXI ERROR reponse. */
        uint32_t AXI_IDLE    :1;                 /* AXI IDLE, RO. Information about the AXI Master wrapper state: '0': no pending action required by the AXI Master wrapper, '1': the AXI Master wrapper has outstanding transactions. Note: HCH halted bit will not be asserted if the AXI Master wrapper is not idle. */
        uint32_t AXI_HALT    :1;                 /* AXI HALT, RW. The AXI Master wrapper's control bit. When set, the AXI Master wrapper will complete current CORE REQ (or IRQ) and stop acknowledging next ones. If the xHC is stopped the AXI Master wrapper is halted automatically. If the xHC is started the AXI Master wrapper is resumed automatically. Software should set this bit to stop the AXI Master issuing new AXI transactions. It may then use the IDLE bit to determine when all previous transactions were completed. Note: The AXI Master wrapper will execute halted only if xHC stopped its internal operation. */
    } B;
} IMX_USB3_USBSS_XECP_AXI_CAP_t;

/* Register XECP_AXI_CAP - AXI Master Wrapper Extended Capability. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_OFFSET 0x1802C
/* Field AXI_CAP_ID - VEND_DEF_AXI_MASTER_WRAPPER_CAP_ID, RO. Vendor defined xHCI Extended Capability: 0xC2. This field identifies the AXI wrapper xHCI Extended capability. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_CAP_ID_SHIFT 0
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_CAP_ID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_CAP_ID(v) (((v) << 0) & 0xFF)
/* Field XECP_AXI_CAP_OFFSET - Next capability Offset, RO. This field points to the xHC MMIO space offset of the next xHCI extended capability pointer. A value of 00h indicates the end of the extended capability list. A non-zero value in this register indicates a relative offset, in Dwords, from this Dword to the beginning of the next extended capability. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_XECP_AXI_CAP_OFFSET_SHIFT 8
#define IMX_USB3_USBSS_XECP_AXI_CAP_XECP_AXI_CAP_OFFSET_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_AXI_CAP_XECP_AXI_CAP_OFFSET(v) (((v) << 0x8) & 0xFF00)
/* Field AXI_ADDRESS_WIDTH_64 - AXI address bus width capability, RO. '0': 32-bit address bus width, '1': 64-bit address bus width. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_ADDRESS_WIDTH_64_SHIFT 16
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_ADDRESS_WIDTH_64_MASK 0x10000
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_ADDRESS_WIDTH_64(v) (((v) << 0x10) & 0x10000)
/* Field AXI_MASTER_WRAPPER_SPLIT_BYTE_BURSTS - AXI_MASTER_WRAPPER_SPLIT_BYTE_BURSTS, RO. Presents information about AXI byte burst capability: '0': no byte bursts, '1': byte bursts enabled. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_MASTER_WRAPPER_SPLIT_BYTE_BURSTS_SHIFT 22
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_MASTER_WRAPPER_SPLIT_BYTE_BURSTS_MASK 0x400000
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_MASTER_WRAPPER_SPLIT_BYTE_BURSTS(v) (((v) << 0x16) & 0x400000)
/* Field AXI_DISABLE_OOO - Disable Out-Of-Order R channel responses (AXI_MASTER_WRAPPER_DISABLE_OOO), RO. This relates to number of IDs used at AXI IF. If Out-Of-Order R channel responses are not disabled this count may be greater than one and in such a case the R channel responses may come Out-Of-Order. The flag gives information about number of used AXI IDs: '0': single ID, '1': multiple IDs. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_DISABLE_OOO_SHIFT 23
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_DISABLE_OOO_MASK 0x800000
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_DISABLE_OOO(v) (((v) << 0x17) & 0x800000)
/* Field AXI_DATA_BUS_SIZE - AXI_DATA_WORD_SIZE, RO. AXI data buses size capability. It uses AXI AxSIZE Encoding. Values of 64-bit ('011') or 128-bit ('100') are supported through compile time configuration. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_DATA_BUS_SIZE_SHIFT 24
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_DATA_BUS_SIZE_MASK 0x7000000
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_DATA_BUS_SIZE(v) (((v) << 0x18) & 0x7000000)
/* Field AXI_ERROR - AXI ERROR, RW1C. Provides an information about AXI ERROR response on B or R channel. This flag is cleared by writing '1' to it. Once set it is held until cleared. The condition setting this register will also assert HSE. This flag may be read by software while handling HSE assertion to determine if the case was AXI ERROR reponse. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_ERROR_SHIFT 29
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_ERROR_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_ERROR(v) (((v) << 0x1D) & 0x20000000)
/* Field AXI_IDLE - AXI IDLE, RO. Information about the AXI Master wrapper state: '0': no pending action required by the AXI Master wrapper, '1': the AXI Master wrapper has outstanding transactions. Note: HCH halted bit will not be asserted if the AXI Master wrapper is not idle. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_IDLE_SHIFT 30
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_IDLE_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_IDLE(v) (((v) << 0x1E) & 0x40000000)
/* Field AXI_HALT - AXI HALT, RW. The AXI Master wrapper's control bit. When set, the AXI Master wrapper will complete current CORE REQ (or IRQ) and stop acknowledging next ones. If the xHC is stopped the AXI Master wrapper is halted automatically. If the xHC is started the AXI Master wrapper is resumed automatically. Software should set this bit to stop the AXI Master issuing new AXI transactions. It may then use the IDLE bit to determine when all previous transactions were completed. Note: The AXI Master wrapper will execute halted only if xHC stopped its internal operation. */
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_HALT_SHIFT 31
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_HALT_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_AXI_CAP_AXI_HALT(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_AXI_CFG0 - AXI Master Wrapper Extended Capability Configuration Register. */
typedef union IMX_USB3_USBSS_XECP_AXI_CFG0_union_t {
    uint32_t R;
    struct {
        uint32_t AXI_MAX_WR_OT :6;               /* AXI MAX_WRITE_OUTSTANDING, RO. Maximum number of Outstanding Write Transactions initiated by the AXI Master wrapper in AW channel. The value written to this field should be the Maximum number of Outstanding Write Transactions initiated by the AXI Master wrapper minus 1, thus the Maximum number of Outstanding Write Transactions is 1 more than the programmed value. */
        uint32_t _unused6    :2;                 /* Reserved */
        uint32_t AXI_WR_DEPTH :8;                /* AXI WRITE_BUFFER_DEPTH, RO. Number of AXI Write beats that can be buffered by the AXI Master wrapper. The value written to this field should be the number of AXI Write beats that can be buffered by the AXI Master wrapper minus 1. */
        uint32_t AXI_MAX_RD_OT :6;               /* AXI MAX_READ_OUTSTANDING, RO. Maximum number of Outstanding Read Transactions initiated by the AXI Master wrapper in AR channel. The value written to this field should be the Maximum number of Outstanding Read Transactions initiated by the AXI Master wrapper minus 1, thus the Maximum number of Outstanding Read Transactions is 1 more than the programmed value. */
        uint32_t _unused22   :2;                 /* Reserved */
        uint32_t AXI_RD_DEPTH :8;                /* AXI READ_BUFFER_DEPTH, RO. Number of AXI Read beats that can be buffered by the AXI Master wrapper. The value written to this field should be the Number of AXI Read beats that can be buffered by the AXI Master wrapper minus 1. */
    } B;
} IMX_USB3_USBSS_XECP_AXI_CFG0_t;

/* Register XECP_AXI_CFG0 - AXI Master Wrapper Extended Capability Configuration Register. */
#define IMX_USB3_USBSS_XECP_AXI_CFG0_OFFSET 0x18030
/* Field AXI_MAX_WR_OT - AXI MAX_WRITE_OUTSTANDING, RO. Maximum number of Outstanding Write Transactions initiated by the AXI Master wrapper in AW channel. The value written to this field should be the Maximum number of Outstanding Write Transactions initiated by the AXI Master wrapper minus 1, thus the Maximum number of Outstanding Write Transactions is 1 more than the programmed value. */
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_MAX_WR_OT_SHIFT 0
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_MAX_WR_OT_MASK 0x3F
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_MAX_WR_OT(v) (((v) << 0) & 0x3F)
/* Field AXI_WR_DEPTH - AXI WRITE_BUFFER_DEPTH, RO. Number of AXI Write beats that can be buffered by the AXI Master wrapper. The value written to this field should be the number of AXI Write beats that can be buffered by the AXI Master wrapper minus 1. */
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_WR_DEPTH_SHIFT 8
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_WR_DEPTH_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_WR_DEPTH(v) (((v) << 0x8) & 0xFF00)
/* Field AXI_MAX_RD_OT - AXI MAX_READ_OUTSTANDING, RO. Maximum number of Outstanding Read Transactions initiated by the AXI Master wrapper in AR channel. The value written to this field should be the Maximum number of Outstanding Read Transactions initiated by the AXI Master wrapper minus 1, thus the Maximum number of Outstanding Read Transactions is 1 more than the programmed value. */
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_MAX_RD_OT_SHIFT 16
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_MAX_RD_OT_MASK 0x3F0000
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_MAX_RD_OT(v) (((v) << 0x10) & 0x3F0000)
/* Field AXI_RD_DEPTH - AXI READ_BUFFER_DEPTH, RO. Number of AXI Read beats that can be buffered by the AXI Master wrapper. The value written to this field should be the Number of AXI Read beats that can be buffered by the AXI Master wrapper minus 1. */
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_RD_DEPTH_SHIFT 24
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_RD_DEPTH_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_AXI_CFG0_AXI_RD_DEPTH(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_AXI_CTRL0 - AXI Master Wrapper Extended Capability Control Register 0. */
typedef union IMX_USB3_USBSS_XECP_AXI_CTRL0_union_t {
    uint32_t R;
    struct {
        uint32_t AXI_BMAX    :4;                 /* AXI BMAX, RW. The register controls maximum burst length - it is used by the AXI Master wrapper to determine maximum value of AxLEN. It uses AXI AxLEN encoding. Default value is the maximum supported one and it is implementation specific. Writing value greater than maximum will result in setting the register to its defaults. This register can be written only when the AXI Master wrapper is halted (AXI_HALT set to '1') and idle (AXI_IDLE is '1'). Note: This register should only be written to during the register initialisation process */
        uint32_t _unused4    :28;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_AXI_CTRL0_t;

/* Register XECP_AXI_CTRL0 - AXI Master Wrapper Extended Capability Control Register 0. */
#define IMX_USB3_USBSS_XECP_AXI_CTRL0_OFFSET 0x18034
/* Field AXI_BMAX - AXI BMAX, RW. The register controls maximum burst length - it is used by the AXI Master wrapper to determine maximum value of AxLEN. It uses AXI AxLEN encoding. Default value is the maximum supported one and it is implementation specific. Writing value greater than maximum will result in setting the register to its defaults. This register can be written only when the AXI Master wrapper is halted (AXI_HALT set to '1') and idle (AXI_IDLE is '1'). Note: This register should only be written to during the register initialisation process */
#define IMX_USB3_USBSS_XECP_AXI_CTRL0_AXI_BMAX_SHIFT 0
#define IMX_USB3_USBSS_XECP_AXI_CTRL0_AXI_BMAX_MASK 0xF
#define IMX_USB3_USBSS_XECP_AXI_CTRL0_AXI_BMAX(v) (((v) << 0) & 0xF)

/* IMX_USB3_USBSS_XECP_AXI_CTRL1 - AXI Master Wrapper Extended Capability Control Register 1. */
typedef union IMX_USB3_USBSS_XECP_AXI_CTRL1_union_t {
    uint32_t R;
    struct {
        uint32_t AXI_WOT     :6;                 /* AXI WRITE_OUTSTANDING, RW. Number of outstanding write transactions that can be initiated by the AXI Master wrapper. Default value of this field is MAX_WRITE_OUTSTANDING-1 (see AXI_MAX_WR_OT field of XECP_AXI_CFG0). Writing value greater than the default will result in setting the register to its defaults. This register can be written only when the AXI Master wrapper is halted (AXI_HALT set to '1') and idle (AXI_IDLE is '1'). The value written to this field should be the requested number of outstanding write transactions minus 1, thus the actual number of possible outstanding write transactions is one more than the programmed value. Note: This register should only be written to during the register initialisation process */
        uint32_t _unused6    :10;                /* Reserved */
        uint32_t AXI_ROT     :6;                 /* AXI READ_OUTSTANDING, RW. Number of outstanding read transactions that can be initiated by the AXI Master wrapper. Default value of this field is MAX_READ_OUTSTANDING-1 (see AXI_MAX_RD_OT field of XECP_AXI_CFG0 register). Writing value greater than the default will result in setting the register to its defaults. This register can be written only when the AXI Master wrapper is halted (AXI_HALT set to '1') and idle (AXI_IDLE is '1'). The value written to this field should be the requested number of outstanding read transactions minus 1, thus the actual number of possible outstanding read transactions is one more than the programmed value. Note: This register should only be written to during the register initialisation process */
        uint32_t _unused22   :10;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_AXI_CTRL1_t;

/* Register XECP_AXI_CTRL1 - AXI Master Wrapper Extended Capability Control Register 1. */
#define IMX_USB3_USBSS_XECP_AXI_CTRL1_OFFSET 0x18038
/* Field AXI_WOT - AXI WRITE_OUTSTANDING, RW. Number of outstanding write transactions that can be initiated by the AXI Master wrapper. Default value of this field is MAX_WRITE_OUTSTANDING-1 (see AXI_MAX_WR_OT field of XECP_AXI_CFG0). Writing value greater than the default will result in setting the register to its defaults. This register can be written only when the AXI Master wrapper is halted (AXI_HALT set to '1') and idle (AXI_IDLE is '1'). The value written to this field should be the requested number of outstanding write transactions minus 1, thus the actual number of possible outstanding write transactions is one more than the programmed value. Note: This register should only be written to during the register initialisation process */
#define IMX_USB3_USBSS_XECP_AXI_CTRL1_AXI_WOT_SHIFT 0
#define IMX_USB3_USBSS_XECP_AXI_CTRL1_AXI_WOT_MASK 0x3F
#define IMX_USB3_USBSS_XECP_AXI_CTRL1_AXI_WOT(v) (((v) << 0) & 0x3F)
/* Field AXI_ROT - AXI READ_OUTSTANDING, RW. Number of outstanding read transactions that can be initiated by the AXI Master wrapper. Default value of this field is MAX_READ_OUTSTANDING-1 (see AXI_MAX_RD_OT field of XECP_AXI_CFG0 register). Writing value greater than the default will result in setting the register to its defaults. This register can be written only when the AXI Master wrapper is halted (AXI_HALT set to '1') and idle (AXI_IDLE is '1'). The value written to this field should be the requested number of outstanding read transactions minus 1, thus the actual number of possible outstanding read transactions is one more than the programmed value. Note: This register should only be written to during the register initialisation process */
#define IMX_USB3_USBSS_XECP_AXI_CTRL1_AXI_ROT_SHIFT 16
#define IMX_USB3_USBSS_XECP_AXI_CTRL1_AXI_ROT_MASK 0x3F0000
#define IMX_USB3_USBSS_XECP_AXI_CTRL1_AXI_ROT(v) (((v) << 0x10) & 0x3F0000)

/* IMX_USB3_USBSS_XECP_AXI_CTRL2 - AXI Master Wrapper Extended Capability Control Register 2. */
typedef union IMX_USB3_USBSS_XECP_AXI_CTRL2_union_t {
    uint32_t R;
    struct {
        uint32_t AXI_WTHRES  :5;                 /* AXI Write Buffer Threshold, RW. When performing an AXI write burst this field specifies the minimum number of required AXI beats buffered prior to starting the burst on AXI W-Channel by asserting wvalid. This allows a user to balance the requirement for minimal latency with the requirement for low bus utilisation during bursts. Burst lengths smaller than or equal to this threshold will be buffered completely and then output on W-Channel. Burst lengths greater than this threshold will output the burst on the W-Channel such that the first AXI_WTHRES beats will be continuously with no drop of WVALID, beats thereafter may or may not be continuous depending on availability of data. Legal values are between 1 and (AXI_WDD-1). A value of 1 means that the burst is started on W-Channel as soon as any data is available without any additional delay. A value of 0 is reserved and should not be used as may lead to unpredictable behaviour. This register can be written only when the AXI Master wrapper is halted (AXI_HALT set to '1') and idle (AXI_IDLE is '1'). Note: This register should only be written to during the register initialisation process. */
        uint32_t _unused5    :27;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_AXI_CTRL2_t;

/* Register XECP_AXI_CTRL2 - AXI Master Wrapper Extended Capability Control Register 2. */
#define IMX_USB3_USBSS_XECP_AXI_CTRL2_OFFSET 0x1803C
/* Field AXI_WTHRES - AXI Write Buffer Threshold, RW. When performing an AXI write burst this field specifies the minimum number of required AXI beats buffered prior to starting the burst on AXI W-Channel by asserting wvalid. This allows a user to balance the requirement for minimal latency with the requirement for low bus utilisation during bursts. Burst lengths smaller than or equal to this threshold will be buffered completely and then output on W-Channel. Burst lengths greater than this threshold will output the burst on the W-Channel such that the first AXI_WTHRES beats will be continuously with no drop of WVALID, beats thereafter may or may not be continuous depending on availability of data. Legal values are between 1 and (AXI_WDD-1). A value of 1 means that the burst is started on W-Channel as soon as any data is available without any additional delay. A value of 0 is reserved and should not be used as may lead to unpredictable behaviour. This register can be written only when the AXI Master wrapper is halted (AXI_HALT set to '1') and idle (AXI_IDLE is '1'). Note: This register should only be written to during the register initialisation process. */
#define IMX_USB3_USBSS_XECP_AXI_CTRL2_AXI_WTHRES_SHIFT 0
#define IMX_USB3_USBSS_XECP_AXI_CTRL2_AXI_WTHRES_MASK 0x1F
#define IMX_USB3_USBSS_XECP_AXI_CTRL2_AXI_WTHRES(v) (((v) << 0) & 0x1F)

/* IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0 - xHCI Supported Protocol Capability. */
typedef union IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_union_t {
    uint32_t R;
    struct {
        uint32_t PID         :8;                 /* Capability ID. The value identifies the capability as Supported Protocol. */
        uint32_t NEXTCAPID   :8;                 /* This field indicates the location of the next capability with respect to the effective address of this capability. Refer to Table 142 of xHCI specification for more information on this field. */
        uint32_t MINOR_REV   :8;                 /* Minor Specification Release Number in Binary-Coded Decimal (i.e.,version x.10 is 10h). This field identifies the minor release number component of the specification with which the xHC is compliant. */
        uint32_t MAJOR_REV   :8;                 /* Major Specification Release Number in Binary-Coded Decimal (i.e.,version 3.x is 03h). This field identifies the major release number component of the specification with which the xHC is compliant. */
    } B;
} IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_t;

/* Register XECP_SUPP_USB2_CAP0 - xHCI Supported Protocol Capability. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_OFFSET 0x18040
/* Field PID - Capability ID. The value identifies the capability as Supported Protocol. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_PID_SHIFT 0
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_PID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_PID(v) (((v) << 0) & 0xFF)
/* Field NEXTCAPID - This field indicates the location of the next capability with respect to the effective address of this capability. Refer to Table 142 of xHCI specification for more information on this field. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_NEXTCAPID_SHIFT 8
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_NEXTCAPID_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_NEXTCAPID(v) (((v) << 0x8) & 0xFF00)
/* Field MINOR_REV - Minor Specification Release Number in Binary-Coded Decimal (i.e.,version x.10 is 10h). This field identifies the minor release number component of the specification with which the xHC is compliant. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_MINOR_REV_SHIFT 16
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_MINOR_REV_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_MINOR_REV(v) (((v) << 0x10) & 0xFF0000)
/* Field MAJOR_REV - Major Specification Release Number in Binary-Coded Decimal (i.e.,version 3.x is 03h). This field identifies the major release number component of the specification with which the xHC is compliant. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_MAJOR_REV_SHIFT 24
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_MAJOR_REV_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_MAJOR_REV(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_SUPP_USB2_CAP1 - xHCI Supported Protocol Capability. */
typedef union IMX_USB3_USBSS_XECP_SUPP_USB2_CAP1_union_t {
    uint32_t R;
    struct {
        uint32_t USB_STRING  :32;                /* Name String, RO. This field is a mnemonic name string that references the specification with which the xHC is compliant. Four ASCII characters may be defined. Allowed characters are: alphanumeric, space, and underscore. Alpha characters are case sensitive. Refer to section 7.2.2 of xHCI specification for defined values. */
    } B;
} IMX_USB3_USBSS_XECP_SUPP_USB2_CAP1_t;

/* Register XECP_SUPP_USB2_CAP1 - xHCI Supported Protocol Capability. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP1_OFFSET 0x18044
/* Field USB_STRING - Name String, RO. This field is a mnemonic name string that references the specification with which the xHC is compliant. Four ASCII characters may be defined. Allowed characters are: alphanumeric, space, and underscore. Alpha characters are case sensitive. Refer to section 7.2.2 of xHCI specification for defined values. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP1_USB_STRING_SHIFT 0
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP1_USB_STRING_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP1_USB_STRING(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2 - xHCI Supported Protocol Capability; USB 2. */
typedef union IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_union_t {
    uint32_t R;
    struct {
        uint32_t COMPATIBLE_PORT_OFFSET :8;      /* This field specifies the starting Port Number of Root Hub Ports that support this protocol. Valid values are 1 to MaxPorts. */
        uint32_t COMPATIBLE_PORT_COUNT :8;       /* This field identifies the number of consecutive Root Hub Ports (starting at the Compatible Port Offset) that support this protocol. Valid values are 1 to MaxPorts. */
        uint32_t L1C         :1;                 /* If '1'LPM is supported (mandatory in xHCI1_00). In xHCI specification this field is reserved RsvdP, see section 7.2.2.1.3 */
        uint32_t HSO         :1;                 /* High-speed Only. Default = Implementation dependent. If this bit is cleared to '0', the USB2 ports described by this capability are Low-, Full-, and High-speed capable. If this bit is set to '1', the USB2 ports described by this capability are High-speed only, e.g. the ports do not support Low- or Full-speed operation. High-speed only implementations may introduce a Tier mismatch, refer to section 4.24.2 of xHCI specification for more information. */
        uint32_t IHI         :1;                 /* Integrated Hub Implemented. Default = Implementation dependent. If this bit is cleared to '0', the Root Hub to External xHC port mapping adheres to the default mapping described in section 4.24.2.1 of xHCI specification. If this bit is set to '1', the Root Hub to External xHC port mapping does not adhere to the default mapping described in section 4.24.2.1 of xHCI specification, and an ACPI or other mechanism is required to define the mapping. */
        uint32_t HLC         :1;                 /* Hardware LPM Capability. Default = Implementation dependent. If this bit is set to '1', the ports described by this xHCI Supported Protocol Capability support hardware controlled USB2 Link Power Management. Refer to section 4.23.5.1.1.1 of xHCI specification. */
        uint32_t HLC_BESL    :1;                 /* HLC_BESL. In xHCI 1.0 specification this field is reserved RsvdP, see section 7.2.2.1.3. The field is described in xHCI 1.1 specification: BESL LPM Capability (BLC), RO. Default = Implementation dependent. If this bit is set to '1', the ports described by this xHCI Supported Protocol Capability shall apply BESL timing to BESL and BESLD fields of the PORTPMSC and PORTHLPMC registers, as defined in Table 13. If this bit is cleared to '0', the ports described by this xHCI Supported Protocol Capability shall apply HIRD timing to BESL and BESLD fields of the PORTPMSC and PORTHLPMC registers, as defined in Table 13. Refer to section 4.23.5.1.1.1 for more information. Note the BESL LMP Capability support (i.e. HLE = 1 and BLC = 1) shall be mandatory for all xHCI 1.1 compliant xHCs. */
        uint32_t _unused21   :7;                 /* Reserved */
        uint32_t PSIC        :4;                 /* Protocol Speed ID Count: 3, USB 2.0 Speed (High, Full, Low). This field indicates the number of Protocol Speed ID (PSI) Dwords that the xHCI Supported Protocol Capability data structure contains. If this field is non-zero, then all speeds supported by the protocol shall be defined using PSI Dwords, i.e. no implied Speed ID mappings apply. */
    } B;
} IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_t;

/* Register XECP_SUPP_USB2_CAP2 - xHCI Supported Protocol Capability; USB 2. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_OFFSET 0x18048
/* Field COMPATIBLE_PORT_OFFSET - This field specifies the starting Port Number of Root Hub Ports that support this protocol. Valid values are 1 to MaxPorts. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_COMPATIBLE_PORT_OFFSET_SHIFT 0
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_COMPATIBLE_PORT_OFFSET_MASK 0xFF
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_COMPATIBLE_PORT_OFFSET(v) (((v) << 0) & 0xFF)
/* Field COMPATIBLE_PORT_COUNT - This field identifies the number of consecutive Root Hub Ports (starting at the Compatible Port Offset) that support this protocol. Valid values are 1 to MaxPorts. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_COMPATIBLE_PORT_COUNT_SHIFT 8
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_COMPATIBLE_PORT_COUNT_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_COMPATIBLE_PORT_COUNT(v) (((v) << 0x8) & 0xFF00)
/* Field L1C - If '1'LPM is supported (mandatory in xHCI1_00). In xHCI specification this field is reserved RsvdP, see section 7.2.2.1.3 */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_L1C_SHIFT 16
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_L1C_MASK 0x10000
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_L1C(v) (((v) << 0x10) & 0x10000)
/* Field HSO - High-speed Only. Default = Implementation dependent. If this bit is cleared to '0', the USB2 ports described by this capability are Low-, Full-, and High-speed capable. If this bit is set to '1', the USB2 ports described by this capability are High-speed only, e.g. the ports do not support Low- or Full-speed operation. High-speed only implementations may introduce a Tier mismatch, refer to section 4.24.2 of xHCI specification for more information. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HSO_SHIFT 17
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HSO_MASK 0x20000
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HSO(v) (((v) << 0x11) & 0x20000)
/* Field IHI - Integrated Hub Implemented. Default = Implementation dependent. If this bit is cleared to '0', the Root Hub to External xHC port mapping adheres to the default mapping described in section 4.24.2.1 of xHCI specification. If this bit is set to '1', the Root Hub to External xHC port mapping does not adhere to the default mapping described in section 4.24.2.1 of xHCI specification, and an ACPI or other mechanism is required to define the mapping. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_IHI_SHIFT 18
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_IHI_MASK 0x40000
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_IHI(v) (((v) << 0x12) & 0x40000)
/* Field HLC - Hardware LPM Capability. Default = Implementation dependent. If this bit is set to '1', the ports described by this xHCI Supported Protocol Capability support hardware controlled USB2 Link Power Management. Refer to section 4.23.5.1.1.1 of xHCI specification. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HLC_SHIFT 19
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HLC_MASK 0x80000
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HLC(v) (((v) << 0x13) & 0x80000)
/* Field HLC_BESL - HLC_BESL. In xHCI 1.0 specification this field is reserved RsvdP, see section 7.2.2.1.3. The field is described in xHCI 1.1 specification: BESL LPM Capability (BLC), RO. Default = Implementation dependent. If this bit is set to '1', the ports described by this xHCI Supported Protocol Capability shall apply BESL timing to BESL and BESLD fields of the PORTPMSC and PORTHLPMC registers, as defined in Table 13. If this bit is cleared to '0', the ports described by this xHCI Supported Protocol Capability shall apply HIRD timing to BESL and BESLD fields of the PORTPMSC and PORTHLPMC registers, as defined in Table 13. Refer to section 4.23.5.1.1.1 for more information. Note the BESL LMP Capability support (i.e. HLE = 1 and BLC = 1) shall be mandatory for all xHCI 1.1 compliant xHCs. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HLC_BESL_SHIFT 20
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HLC_BESL_MASK 0x100000
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_HLC_BESL(v) (((v) << 0x14) & 0x100000)
/* Field PSIC - Protocol Speed ID Count: 3, USB 2.0 Speed (High, Full, Low). This field indicates the number of Protocol Speed ID (PSI) Dwords that the xHCI Supported Protocol Capability data structure contains. If this field is non-zero, then all speeds supported by the protocol shall be defined using PSI Dwords, i.e. no implied Speed ID mappings apply. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_PSIC_SHIFT 28
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_PSIC_MASK 0xF0000000
#define IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_PSIC(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE - Protocol Slot Type. */
typedef union IMX_USB3_USBSS_XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE_union_t {
    uint32_t R;
    struct {
        uint32_t PST         :5;                 /* This field specifies the Protocol Slot Type value, which may be specified when allocating Device Slots that support this protocol. Valid values are 0 to 31. Refer to sections 4.6.3 and 7.2.2.1.4 of xHCI specification. The value of the Protocol Slot Type field declared by a xHCI Supported Protocol Capability structure is unique to an xHC implementation. Software shall not assume a fixed mapping of the Protocol Slot Type value to a specific type of Supported Protocol. Note that for compatibility reasons, the Protocol Slot Type value of 0 is the exception to this rule and reserved for the USB Protocol Device Slot type. */
        uint32_t _unused5    :27;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE_t;

/* Register XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE - Protocol Slot Type. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE_OFFSET 0x1804C
/* Field PST - This field specifies the Protocol Slot Type value, which may be specified when allocating Device Slots that support this protocol. Valid values are 0 to 31. Refer to sections 4.6.3 and 7.2.2.1.4 of xHCI specification. The value of the Protocol Slot Type field declared by a xHCI Supported Protocol Capability structure is unique to an xHC implementation. Software shall not assume a fixed mapping of the Protocol Slot Type value to a specific type of Supported Protocol. Note that for compatibility reasons, the Protocol Slot Type value of 0 is the exception to this rule and reserved for the USB Protocol Device Slot type. */
#define IMX_USB3_USBSS_XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE_PST_SHIFT 0
#define IMX_USB3_USBSS_XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE_PST_MASK 0x1F
#define IMX_USB3_USBSS_XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE_PST(v) (((v) << 0) & 0x1F)

/* IMX_USB3_USBSS_XECP_PSI_FULL_SPEED - Protocol Speed ID, xHCI Supported Protocol Capability */
typedef union IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_union_t {
    uint32_t R;
    struct {
        uint32_t PSIV        :4;                 /* Protocol Speed ID Value. If a device is attached that operates at the bit rate defined by this PSI Dword, then the value of this field shall be reported in the Port Speed field of PORTSC register (5.4.8 of xHCI specification) of a compatible port. Note, the PSIV value of 0 is reserved and shall not be defined by a PSI. */
        uint32_t PSIE        :2;                 /* Protocol Speed ID Exponent. This field defines the base 10 exponent times 3, that shall be applied to the Protocol Speed ID Mantissa when calculating the maximum bit rate represented by this PSI Dword. PSIE Values and corresponding bit rates: 0: Bits per second 1: Kb/s 2: Mb/s 3: Gb/s . */
        uint32_t PLT         :2;                 /* PSI Type. This field identifies whether the PSI Dword defines a symmetric or asymmetric bit rate, and if asymmetric, then this field also indicates if this Dword defines the receive or transmit bit rate. Note that the Asymmetric PSI Dwords shall be paired, i.e. an Rx immediately followed by a Tx, and both Dwords shall define the same value for the PSIV. PLT Values and corresponding bit rate: 0: Symmetric (Single PSI Dword) 1: Reserved 2: Asymmetric Rx (Paired with Asymmetric Tx PSI Dword) 3: Asymmetric Tx (Immediately follows Rx Asymmetric PSI Dword). */
        uint32_t PFD         :1;                 /* PSI Full-duplex. If this bit is '1' the link is full-duplex, and if '0' the link is half-duplex. */
        uint32_t _unused9    :7;                 /* Reserved */
        uint32_t PSIM        :16;                /* Protocol Speed ID Mantissa. This field defines the mantissa that shall be applied to the PSIE when calculating the maximum bit rate represented by this PSI Dword. */
    } B;
} IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_t;

/* Register XECP_PSI_FULL_SPEED - Protocol Speed ID, xHCI Supported Protocol Capability */
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_OFFSET 0x18050
/* Field PSIV - Protocol Speed ID Value. If a device is attached that operates at the bit rate defined by this PSI Dword, then the value of this field shall be reported in the Port Speed field of PORTSC register (5.4.8 of xHCI specification) of a compatible port. Note, the PSIV value of 0 is reserved and shall not be defined by a PSI. */
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIV_SHIFT 0
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIV_MASK 0xF
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIV(v) (((v) << 0) & 0xF)
/* Field PSIE - Protocol Speed ID Exponent. This field defines the base 10 exponent times 3, that shall be applied to the Protocol Speed ID Mantissa when calculating the maximum bit rate represented by this PSI Dword. PSIE Values and corresponding bit rates: 0: Bits per second 1: Kb/s 2: Mb/s 3: Gb/s . */
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIE_SHIFT 4
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIE_MASK 0x30
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIE(v) (((v) << 0x4) & 0x30)
/* Field PLT - PSI Type. This field identifies whether the PSI Dword defines a symmetric or asymmetric bit rate, and if asymmetric, then this field also indicates if this Dword defines the receive or transmit bit rate. Note that the Asymmetric PSI Dwords shall be paired, i.e. an Rx immediately followed by a Tx, and both Dwords shall define the same value for the PSIV. PLT Values and corresponding bit rate: 0: Symmetric (Single PSI Dword) 1: Reserved 2: Asymmetric Rx (Paired with Asymmetric Tx PSI Dword) 3: Asymmetric Tx (Immediately follows Rx Asymmetric PSI Dword). */
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PLT_SHIFT 6
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PLT_MASK 0xC0
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PLT(v) (((v) << 0x6) & 0xC0)
/* Field PFD - PSI Full-duplex. If this bit is '1' the link is full-duplex, and if '0' the link is half-duplex. */
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PFD_SHIFT 8
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PFD_MASK 0x100
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PFD(v) (((v) << 0x8) & 0x100)
/* Field PSIM - Protocol Speed ID Mantissa. This field defines the mantissa that shall be applied to the PSIE when calculating the maximum bit rate represented by this PSI Dword. */
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIM_SHIFT 16
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIM_MASK 0xFFFF0000
#define IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_PSIM(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_XECP_PSI_LOW_SPEED - Protocol Speed ID, xHCI Supported Protocol Capability */
typedef union IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_union_t {
    uint32_t R;
    struct {
        uint32_t PSIV        :4;                 /* Protocol Speed ID Value. If a device is attached that operates at the bit rate defined by this PSI Dword, then the value of this field shall be reported in the Port Speed field of PORTSC register (5.4.8 of xHCI specification) of a compatible port. Note, the PSIV value of 0 is reserved and shall not be defined by a PSI. */
        uint32_t PSIE        :2;                 /* Protocol Speed ID Exponent. This field defines the base 10 exponent times 3, that shall be applied to the Protocol Speed ID Mantissa when calculating the maximum bit rate represented by this PSI Dword. PSIE Values and corresponding bit rates: 0: Bits per second 1: Kb/s 2: Mb/s 3: Gb/s . */
        uint32_t PLT         :2;                 /* PSI Type. This field identifies whether the PSI Dword defines a symmetric or asymmetric bit rate, and if asymmetric, then this field also indicates if this Dword defines the receive or transmit bit rate. Note that the Asymmetric PSI Dwords shall be paired, i.e. an Rx immediately followed by a Tx, and both Dwords shall define the same value for the PSIV. PLT Values and corresponding bit rate: 0: Symmetric Single (PSI Dword) 1: Reserved 2: Asymmetric Rx (Paired with Asymmetric Tx PSI Dword) 3: Asymmetric Tx (Immediately follows Rx Asymmetric PSI Dword). */
        uint32_t PFD         :1;                 /* PSI Full-duplex. If this bit is '1' the link is full-duplex, and if '0' the link is half-duplex. */
        uint32_t _unused9    :7;                 /* Reserved */
        uint32_t PSIM        :16;                /* Protocol Speed ID Mantissa. This field defines the mantissa that shall be applied to the PSIE when calculating the maximum bit rate represented by this PSI Dword. */
    } B;
} IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_t;

/* Register XECP_PSI_LOW_SPEED - Protocol Speed ID, xHCI Supported Protocol Capability */
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_OFFSET 0x18054
/* Field PSIV - Protocol Speed ID Value. If a device is attached that operates at the bit rate defined by this PSI Dword, then the value of this field shall be reported in the Port Speed field of PORTSC register (5.4.8 of xHCI specification) of a compatible port. Note, the PSIV value of 0 is reserved and shall not be defined by a PSI. */
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIV_SHIFT 0
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIV_MASK 0xF
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIV(v) (((v) << 0) & 0xF)
/* Field PSIE - Protocol Speed ID Exponent. This field defines the base 10 exponent times 3, that shall be applied to the Protocol Speed ID Mantissa when calculating the maximum bit rate represented by this PSI Dword. PSIE Values and corresponding bit rates: 0: Bits per second 1: Kb/s 2: Mb/s 3: Gb/s . */
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIE_SHIFT 4
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIE_MASK 0x30
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIE(v) (((v) << 0x4) & 0x30)
/* Field PLT - PSI Type. This field identifies whether the PSI Dword defines a symmetric or asymmetric bit rate, and if asymmetric, then this field also indicates if this Dword defines the receive or transmit bit rate. Note that the Asymmetric PSI Dwords shall be paired, i.e. an Rx immediately followed by a Tx, and both Dwords shall define the same value for the PSIV. PLT Values and corresponding bit rate: 0: Symmetric Single (PSI Dword) 1: Reserved 2: Asymmetric Rx (Paired with Asymmetric Tx PSI Dword) 3: Asymmetric Tx (Immediately follows Rx Asymmetric PSI Dword). */
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PLT_SHIFT 6
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PLT_MASK 0xC0
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PLT(v) (((v) << 0x6) & 0xC0)
/* Field PFD - PSI Full-duplex. If this bit is '1' the link is full-duplex, and if '0' the link is half-duplex. */
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PFD_SHIFT 8
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PFD_MASK 0x100
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PFD(v) (((v) << 0x8) & 0x100)
/* Field PSIM - Protocol Speed ID Mantissa. This field defines the mantissa that shall be applied to the PSIE when calculating the maximum bit rate represented by this PSI Dword. */
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIM_SHIFT 16
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIM_MASK 0xFFFF0000
#define IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_PSIM(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED - Protocol Speed ID, xHCI Supported Protocol Capability */
typedef union IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_union_t {
    uint32_t R;
    struct {
        uint32_t PSIV        :4;                 /* Protocol Speed ID Value. If a device is attached that operates at the bit rate defined by this PSI Dword, then the value of this field shall be reported in the Port Speed field of PORTSC register (5.4.8 of xHCI specification) of a compatible port. Note, the PSIV value of 0 is reserved and shall not be defined by a PSI. */
        uint32_t PSIE        :2;                 /* Protocol Speed ID Exponent. This field defines the base 10 exponent times 3, that shall be applied to the Protocol Speed ID Mantissa when calculating the maximum bit rate represented by this PSI Dword. PSIE Values and corresponding bit rates: 0: Bits per second 1: Kb/s 2: Mb/s 3: Gb/s . */
        uint32_t PLT         :2;                 /* PSI Type. This field identifies whether the PSI Dword defines a symmetric or asymmetric bit rate, and if asymmetric, then this field also indicates if this Dword defines the receive or transmit bit rate. Note that the Asymmetric PSI Dwords shall be paired, i.e. an Rx immediately followed by a Tx, and both Dwords shall define the same value for the PSIV. PLT Values and corresponding bit rate: 0: Symmetric Single (PSI Dword) 1: Reserved 2: Asymmetric Rx (Paired with Asymmetric Tx PSI Dword) 3: Asymmetric Tx (Immediately follows Rx Asymmetric PSI Dword). */
        uint32_t PFD         :1;                 /* PSI Full-duplex. If this bit is '1' the link is full-duplex, and if '0' the link is half-duplex. */
        uint32_t _unused9    :7;                 /* Reserved */
        uint32_t PSIM        :16;                /* Protocol Speed ID Mantissa. This field defines the mantissa that shall be applied to the PSIE when calculating the maximum bit rate represented by this PSI Dword. */
    } B;
} IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_t;

/* Register XECP_PSI_HIGH_SPEED - Protocol Speed ID, xHCI Supported Protocol Capability */
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_OFFSET 0x18058
/* Field PSIV - Protocol Speed ID Value. If a device is attached that operates at the bit rate defined by this PSI Dword, then the value of this field shall be reported in the Port Speed field of PORTSC register (5.4.8 of xHCI specification) of a compatible port. Note, the PSIV value of 0 is reserved and shall not be defined by a PSI. */
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIV_SHIFT 0
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIV_MASK 0xF
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIV(v) (((v) << 0) & 0xF)
/* Field PSIE - Protocol Speed ID Exponent. This field defines the base 10 exponent times 3, that shall be applied to the Protocol Speed ID Mantissa when calculating the maximum bit rate represented by this PSI Dword. PSIE Values and corresponding bit rates: 0: Bits per second 1: Kb/s 2: Mb/s 3: Gb/s . */
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIE_SHIFT 4
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIE_MASK 0x30
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIE(v) (((v) << 0x4) & 0x30)
/* Field PLT - PSI Type. This field identifies whether the PSI Dword defines a symmetric or asymmetric bit rate, and if asymmetric, then this field also indicates if this Dword defines the receive or transmit bit rate. Note that the Asymmetric PSI Dwords shall be paired, i.e. an Rx immediately followed by a Tx, and both Dwords shall define the same value for the PSIV. PLT Values and corresponding bit rate: 0: Symmetric Single (PSI Dword) 1: Reserved 2: Asymmetric Rx (Paired with Asymmetric Tx PSI Dword) 3: Asymmetric Tx (Immediately follows Rx Asymmetric PSI Dword). */
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PLT_SHIFT 6
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PLT_MASK 0xC0
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PLT(v) (((v) << 0x6) & 0xC0)
/* Field PFD - PSI Full-duplex. If this bit is '1' the link is full-duplex, and if '0' the link is half-duplex. */
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PFD_SHIFT 8
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PFD_MASK 0x100
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PFD(v) (((v) << 0x8) & 0x100)
/* Field PSIM - Protocol Speed ID Mantissa. This field defines the mantissa that shall be applied to the PSIE when calculating the maximum bit rate represented by this PSI Dword. */
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIM_SHIFT 16
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIM_MASK 0xFFFF0000
#define IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_PSIM(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0 - xHCI Supported Protocol Capability. */
typedef union IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_union_t {
    uint32_t R;
    struct {
        uint32_t PID         :8;                 /* Capability ID. The value identifies the capability as Supported Protocol. */
        uint32_t NEXTCAPID   :8;                 /* This field indicates the location of the next capability with respect to the effective address of this capability. Refer to Table 142 of xHCI specification for more information on this field. */
        uint32_t MINOR_REV   :8;                 /* Minor Specification Release Number in Binary-Coded Decimal (i.e.,version x.10 is 10h). This field identifies the minor release number component of the specification with which the xHC is compliant. */
        uint32_t MAJOR_REV   :8;                 /* Major Specification Release Number in Binary-Coded Decimal (i.e.,version 3.x is 03h). This field identifies the major release number component of the specification with which the xHC is compliant. */
    } B;
} IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_t;

/* Register XECP_SUPP_USB3_CAP0 - xHCI Supported Protocol Capability. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_OFFSET 0x18060
/* Field PID - Capability ID. The value identifies the capability as Supported Protocol. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_PID_SHIFT 0
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_PID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_PID(v) (((v) << 0) & 0xFF)
/* Field NEXTCAPID - This field indicates the location of the next capability with respect to the effective address of this capability. Refer to Table 142 of xHCI specification for more information on this field. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_NEXTCAPID_SHIFT 8
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_NEXTCAPID_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_NEXTCAPID(v) (((v) << 0x8) & 0xFF00)
/* Field MINOR_REV - Minor Specification Release Number in Binary-Coded Decimal (i.e.,version x.10 is 10h). This field identifies the minor release number component of the specification with which the xHC is compliant. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_MINOR_REV_SHIFT 16
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_MINOR_REV_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_MINOR_REV(v) (((v) << 0x10) & 0xFF0000)
/* Field MAJOR_REV - Major Specification Release Number in Binary-Coded Decimal (i.e.,version 3.x is 03h). This field identifies the major release number component of the specification with which the xHC is compliant. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_MAJOR_REV_SHIFT 24
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_MAJOR_REV_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_MAJOR_REV(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_SUPP_USB3_CAP1 - xHCI Supported Protocol Capability. */
typedef union IMX_USB3_USBSS_XECP_SUPP_USB3_CAP1_union_t {
    uint32_t R;
    struct {
        uint32_t USB_STRING  :32;                /* Name String, RO. This field is a mnemonic name string that references the specification with which the xHC is compliant. Four ASCII characters may be defined. Allowed characters are: alphanumeric, space, and underscore. Alpha characters are case sensitive. Refer to section 7.2.2 of xHCI specification for defined values. */
    } B;
} IMX_USB3_USBSS_XECP_SUPP_USB3_CAP1_t;

/* Register XECP_SUPP_USB3_CAP1 - xHCI Supported Protocol Capability. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP1_OFFSET 0x18064
/* Field USB_STRING - Name String, RO. This field is a mnemonic name string that references the specification with which the xHC is compliant. Four ASCII characters may be defined. Allowed characters are: alphanumeric, space, and underscore. Alpha characters are case sensitive. Refer to section 7.2.2 of xHCI specification for defined values. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP1_USB_STRING_SHIFT 0
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP1_USB_STRING_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP1_USB_STRING(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2 - xHCI Supported Protocol Capability; USB 3. */
typedef union IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_union_t {
    uint32_t R;
    struct {
        uint32_t COMPATIBLE_PORT_OFFSET :8;      /* This field specifies the starting Port Number of Root Hub Ports that support this protocol. Valid values are 1 to MaxPorts. */
        uint32_t COMPATIBLE_PORT_COUNT :8;       /* This field identifies the number of consecutive Root Hub Ports (starting at the Compatible Port Offset) that support this protocol. Valid values are 1 to MaxPorts. */
        uint32_t _unused16   :12;                /* Reserved */
        uint32_t PSIC        :4;                 /* Protocol Speed ID CountCount : 1, USB 3.0 Speed (Super Speed). This field indicates the number of Protocol Speed ID (PSI) Dwords that the xHCI Supported Protocol Capability data structure contains. If this field is non-zero, then all speeds supported by the protocol shall be defined using PSI Dwords, i.e. no implied Speed ID mappings apply. */
    } B;
} IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_t;

/* Register XECP_SUPP_USB3_CAP2 - xHCI Supported Protocol Capability; USB 3. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_OFFSET 0x18068
/* Field COMPATIBLE_PORT_OFFSET - This field specifies the starting Port Number of Root Hub Ports that support this protocol. Valid values are 1 to MaxPorts. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_COMPATIBLE_PORT_OFFSET_SHIFT 0
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_COMPATIBLE_PORT_OFFSET_MASK 0xFF
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_COMPATIBLE_PORT_OFFSET(v) (((v) << 0) & 0xFF)
/* Field COMPATIBLE_PORT_COUNT - This field identifies the number of consecutive Root Hub Ports (starting at the Compatible Port Offset) that support this protocol. Valid values are 1 to MaxPorts. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_COMPATIBLE_PORT_COUNT_SHIFT 8
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_COMPATIBLE_PORT_COUNT_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_COMPATIBLE_PORT_COUNT(v) (((v) << 0x8) & 0xFF00)
/* Field PSIC - Protocol Speed ID CountCount : 1, USB 3.0 Speed (Super Speed). This field indicates the number of Protocol Speed ID (PSI) Dwords that the xHCI Supported Protocol Capability data structure contains. If this field is non-zero, then all speeds supported by the protocol shall be defined using PSI Dwords, i.e. no implied Speed ID mappings apply. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_PSIC_SHIFT 28
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_PSIC_MASK 0xF0000000
#define IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_PSIC(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE - Protocol Slot Type. */
typedef union IMX_USB3_USBSS_XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE_union_t {
    uint32_t R;
    struct {
        uint32_t PST         :5;                 /* This field specifies the Protocol Slot Type value, which may be specified when allocating Device Slots that support this protocol. Valid values are 0 to 31. Refer to sections 4.6.3 and 7.2.2.1.4 of xHCI specification. The value of the Protocol Slot Type field declared by a xHCI Supported Protocol Capability structure is unique to an xHC implementation. Software shall not assume a fixed mapping of the Protocol Slot Type value to a specific type of Supported Protocol. Note that for compatibility reasons, the Protocol Slot Type value of 0 is the exception to this rule and reserved for the USB Protocol Device Slot type. */
        uint32_t _unused5    :27;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE_t;

/* Register XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE - Protocol Slot Type. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE_OFFSET 0x1806C
/* Field PST - This field specifies the Protocol Slot Type value, which may be specified when allocating Device Slots that support this protocol. Valid values are 0 to 31. Refer to sections 4.6.3 and 7.2.2.1.4 of xHCI specification. The value of the Protocol Slot Type field declared by a xHCI Supported Protocol Capability structure is unique to an xHC implementation. Software shall not assume a fixed mapping of the Protocol Slot Type value to a specific type of Supported Protocol. Note that for compatibility reasons, the Protocol Slot Type value of 0 is the exception to this rule and reserved for the USB Protocol Device Slot type. */
#define IMX_USB3_USBSS_XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE_PST_SHIFT 0
#define IMX_USB3_USBSS_XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE_PST_MASK 0x1F
#define IMX_USB3_USBSS_XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE_PST(v) (((v) << 0) & 0x1F)

/* IMX_USB3_USBSS_PSI_SUPER_SPEED - Protocol Speed ID, xHCI Supported Protocol Capability */
typedef union IMX_USB3_USBSS_PSI_SUPER_SPEED_union_t {
    uint32_t R;
    struct {
        uint32_t PSIV        :4;                 /* Protocol Speed ID Value. If a device is attached that operates at the bit rate defined by this PSI Dword, then the value of this field shall be reported in the Port Speed field of PORTSC register (5.4.8 of xHCI specification) of a compatible port. Note, the PSIV value of 0 is reserved and shall not be defined by a PSI. */
        uint32_t PSIE        :2;                 /* Protocol Speed ID Exponent. This field defines the base 10 exponent times 3, that shall be applied to the Protocol Speed ID Mantissa when calculating the maximum bit rate represented by this PSI Dword. PSIE Values and corresponding bit rates: 0: Bits per second 1: Kb/s 2: Mb/s 3: Gb/s . */
        uint32_t PLT         :2;                 /* PSI Type. This field identifies whether the PSI Dword defines a symmetric or asymmetric bit rate, and if asymmetric, then this field also indicates if this Dword defines the receive or transmit bit rate. Note that the Asymmetric PSI Dwords shall be paired, i.e. an Rx immediately followed by a Tx, and both Dwords shall define the same value for the PSIV. PLT Values and corresponding bit rate: 0: Symmetric Single (PSI Dword) 1: Reserved 2: Asymmetric Rx (Paired with Asymmetric Tx PSI Dword) 3: Asymmetric Tx (Immediately follows Rx Asymmetric PSI Dword). */
        uint32_t PFD         :1;                 /* PSI Full-duplex. If this bit is '1' the link is full-duplex, and if '0' the link is half-duplex. */
        uint32_t _unused9    :7;                 /* Reserved */
        uint32_t PSIM        :16;                /* Protocol Speed ID Mantissa. This field defines the mantissa that shall be applied to the PSIE when calculating the maximum bit rate represented by this PSI Dword. */
    } B;
} IMX_USB3_USBSS_PSI_SUPER_SPEED_t;

/* Register PSI_SUPER_SPEED - Protocol Speed ID, xHCI Supported Protocol Capability */
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_OFFSET 0x18070
/* Field PSIV - Protocol Speed ID Value. If a device is attached that operates at the bit rate defined by this PSI Dword, then the value of this field shall be reported in the Port Speed field of PORTSC register (5.4.8 of xHCI specification) of a compatible port. Note, the PSIV value of 0 is reserved and shall not be defined by a PSI. */
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIV_SHIFT 0
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIV_MASK 0xF
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIV(v) (((v) << 0) & 0xF)
/* Field PSIE - Protocol Speed ID Exponent. This field defines the base 10 exponent times 3, that shall be applied to the Protocol Speed ID Mantissa when calculating the maximum bit rate represented by this PSI Dword. PSIE Values and corresponding bit rates: 0: Bits per second 1: Kb/s 2: Mb/s 3: Gb/s . */
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIE_SHIFT 4
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIE_MASK 0x30
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIE(v) (((v) << 0x4) & 0x30)
/* Field PLT - PSI Type. This field identifies whether the PSI Dword defines a symmetric or asymmetric bit rate, and if asymmetric, then this field also indicates if this Dword defines the receive or transmit bit rate. Note that the Asymmetric PSI Dwords shall be paired, i.e. an Rx immediately followed by a Tx, and both Dwords shall define the same value for the PSIV. PLT Values and corresponding bit rate: 0: Symmetric Single (PSI Dword) 1: Reserved 2: Asymmetric Rx (Paired with Asymmetric Tx PSI Dword) 3: Asymmetric Tx (Immediately follows Rx Asymmetric PSI Dword). */
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PLT_SHIFT 6
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PLT_MASK 0xC0
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PLT(v) (((v) << 0x6) & 0xC0)
/* Field PFD - PSI Full-duplex. If this bit is '1' the link is full-duplex, and if '0' the link is half-duplex. */
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PFD_SHIFT 8
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PFD_MASK 0x100
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PFD(v) (((v) << 0x8) & 0x100)
/* Field PSIM - Protocol Speed ID Mantissa. This field defines the mantissa that shall be applied to the PSIE when calculating the maximum bit rate represented by this PSI Dword. */
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIM_SHIFT 16
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIM_MASK 0xFFFF0000
#define IMX_USB3_USBSS_PSI_SUPER_SPEED_PSIM(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_XECP_CMDM_STS0 - Command Ring related status register. */
typedef union IMX_USB3_USBSS_XECP_CMDM_STS0_union_t {
    uint32_t R;
    struct {
        uint32_t VEND_DEF_CMDM_CAP_ID_193 :8;    /* Vendor defined capability ID. Command Ring Manager capability ID. */
        uint32_t XECP_CMDM_NEXT_CAP_OFFSET :8;   /* Next capability offset */
        uint32_t CMD_RUNNING :1;                 /* Indicates that the command ring is running */
        uint32_t HOST_CMD_DB_RANG_STICKY :1;     /* Indicates that command ring has a doorbell pending */
        uint32_t STOPPING_CMD_RING :1;           /* Indicates that a STOP on the Command Ring is in progress */
        uint32_t _unused19   :1;                 /* Reserved field, RO */
        uint32_t TRM_STALL_REQ :1;               /* Indicates that transfer ring manager is issuing and EP state update due to stall received */
        uint32_t TRM_EPERR_UPD_REQ :1;           /* Indicates that Transfer Ring Manager is issuing and EP update due to an EP error condition detected */
        uint32_t DBM_EP_UPD_REQ :1;              /* Indicates that Doorbell Manager is issuing and EP update due to a doorbell ring on an EP that is in stop state */
        uint32_t UPDATE_ENDPT_ACTIVE :1;         /* Indicates that updating of EP state is in progress */
        uint32_t ODMA_ADDRESS_DEV_PENDING :1;    /* Indicates that ODMA has an address device command in progress. */
        uint32_t ODMA_ADDRESS_DEV_DONE :1;       /* Indicates that current address device command is done by ODMA. */
        uint32_t CMDM_CLR_DB_REQ :1;             /* Indicates that clearing an EP out of schedule is in progress. */
        uint32_t CMDM_STOP_REQ :1;               /* Indicates that Command Ring stop command is in progress. */
        uint32_t CMDM_CNTX_LOCK_REQ :1;          /* Indicates that Command Manager has requested a context lock. */
        uint32_t TRM_CNTX_IN_USE :1;             /* Indicates that TRM modules owns the context access currently */
        uint32_t ODMA_CNTX_IN_USE :1;            /* Indicates that ODMA module currently owns currently the context access */
        uint32_t IDMA_CNTX_IN_USE :1;            /* Indicates that IDMA module currently owns the context access : */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_STS0_t;

/* Register XECP_CMDM_STS0 - Command Ring related status register. */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_OFFSET 0x18080
/* Field VEND_DEF_CMDM_CAP_ID_193 - Vendor defined capability ID. Command Ring Manager capability ID. */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_VEND_DEF_CMDM_CAP_ID_193_SHIFT 0
#define IMX_USB3_USBSS_XECP_CMDM_STS0_VEND_DEF_CMDM_CAP_ID_193_MASK 0xFF
#define IMX_USB3_USBSS_XECP_CMDM_STS0_VEND_DEF_CMDM_CAP_ID_193(v) (((v) << 0) & 0xFF)
/* Field XECP_CMDM_NEXT_CAP_OFFSET - Next capability offset */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_XECP_CMDM_NEXT_CAP_OFFSET_SHIFT 8
#define IMX_USB3_USBSS_XECP_CMDM_STS0_XECP_CMDM_NEXT_CAP_OFFSET_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_CMDM_STS0_XECP_CMDM_NEXT_CAP_OFFSET(v) (((v) << 0x8) & 0xFF00)
/* Field CMD_RUNNING - Indicates that the command ring is running */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMD_RUNNING_SHIFT 16
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMD_RUNNING_MASK 0x10000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMD_RUNNING(v) (((v) << 0x10) & 0x10000)
/* Field HOST_CMD_DB_RANG_STICKY - Indicates that command ring has a doorbell pending */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_HOST_CMD_DB_RANG_STICKY_SHIFT 17
#define IMX_USB3_USBSS_XECP_CMDM_STS0_HOST_CMD_DB_RANG_STICKY_MASK 0x20000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_HOST_CMD_DB_RANG_STICKY(v) (((v) << 0x11) & 0x20000)
/* Field STOPPING_CMD_RING - Indicates that a STOP on the Command Ring is in progress */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_STOPPING_CMD_RING_SHIFT 18
#define IMX_USB3_USBSS_XECP_CMDM_STS0_STOPPING_CMD_RING_MASK 0x40000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_STOPPING_CMD_RING(v) (((v) << 0x12) & 0x40000)
/* Field TRM_STALL_REQ - Indicates that transfer ring manager is issuing and EP state update due to stall received */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_STALL_REQ_SHIFT 20
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_STALL_REQ_MASK 0x100000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_STALL_REQ(v) (((v) << 0x14) & 0x100000)
/* Field TRM_EPERR_UPD_REQ - Indicates that Transfer Ring Manager is issuing and EP update due to an EP error condition detected */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_EPERR_UPD_REQ_SHIFT 21
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_EPERR_UPD_REQ_MASK 0x200000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_EPERR_UPD_REQ(v) (((v) << 0x15) & 0x200000)
/* Field DBM_EP_UPD_REQ - Indicates that Doorbell Manager is issuing and EP update due to a doorbell ring on an EP that is in stop state */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_DBM_EP_UPD_REQ_SHIFT 22
#define IMX_USB3_USBSS_XECP_CMDM_STS0_DBM_EP_UPD_REQ_MASK 0x400000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_DBM_EP_UPD_REQ(v) (((v) << 0x16) & 0x400000)
/* Field UPDATE_ENDPT_ACTIVE - Indicates that updating of EP state is in progress */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_UPDATE_ENDPT_ACTIVE_SHIFT 23
#define IMX_USB3_USBSS_XECP_CMDM_STS0_UPDATE_ENDPT_ACTIVE_MASK 0x800000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_UPDATE_ENDPT_ACTIVE(v) (((v) << 0x17) & 0x800000)
/* Field ODMA_ADDRESS_DEV_PENDING - Indicates that ODMA has an address device command in progress. */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_ADDRESS_DEV_PENDING_SHIFT 24
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_ADDRESS_DEV_PENDING_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_ADDRESS_DEV_PENDING(v) (((v) << 0x18) & 0x1000000)
/* Field ODMA_ADDRESS_DEV_DONE - Indicates that current address device command is done by ODMA. */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_ADDRESS_DEV_DONE_SHIFT 25
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_ADDRESS_DEV_DONE_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_ADDRESS_DEV_DONE(v) (((v) << 0x19) & 0x2000000)
/* Field CMDM_CLR_DB_REQ - Indicates that clearing an EP out of schedule is in progress. */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_CLR_DB_REQ_SHIFT 26
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_CLR_DB_REQ_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_CLR_DB_REQ(v) (((v) << 0x1A) & 0x4000000)
/* Field CMDM_STOP_REQ - Indicates that Command Ring stop command is in progress. */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_STOP_REQ_SHIFT 27
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_STOP_REQ_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_STOP_REQ(v) (((v) << 0x1B) & 0x8000000)
/* Field CMDM_CNTX_LOCK_REQ - Indicates that Command Manager has requested a context lock. */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_CNTX_LOCK_REQ_SHIFT 28
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_CNTX_LOCK_REQ_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_CMDM_CNTX_LOCK_REQ(v) (((v) << 0x1C) & 0x10000000)
/* Field TRM_CNTX_IN_USE - Indicates that TRM modules owns the context access currently */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_CNTX_IN_USE_SHIFT 29
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_CNTX_IN_USE_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_TRM_CNTX_IN_USE(v) (((v) << 0x1D) & 0x20000000)
/* Field ODMA_CNTX_IN_USE - Indicates that ODMA module currently owns currently the context access */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_CNTX_IN_USE_SHIFT 30
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_CNTX_IN_USE_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_ODMA_CNTX_IN_USE(v) (((v) << 0x1E) & 0x40000000)
/* Field IDMA_CNTX_IN_USE - Indicates that IDMA module currently owns the context access : */
#define IMX_USB3_USBSS_XECP_CMDM_STS0_IDMA_CNTX_IN_USE_SHIFT 31
#define IMX_USB3_USBSS_XECP_CMDM_STS0_IDMA_CNTX_IN_USE_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_CMDM_STS0_IDMA_CNTX_IN_USE(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_CMDM_RESERVED_1 - Event ring manager module reserved space. */
typedef union IMX_USB3_USBSS_XECP_CMDM_RESERVED_1_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved field, RO. */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_RESERVED_1_t;

/* Register XECP_CMDM_RESERVED_1 - Event ring manager module reserved space. */
#define IMX_USB3_USBSS_XECP_CMDM_RESERVED_1_OFFSET 0x18084

/* IMX_USB3_USBSS_XECP_CMDM_RESERVED_2 - Event ring manager module reserved space. */
typedef union IMX_USB3_USBSS_XECP_CMDM_RESERVED_2_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved field, RO. */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_RESERVED_2_t;

/* Register XECP_CMDM_RESERVED_2 - Event ring manager module reserved space. */
#define IMX_USB3_USBSS_XECP_CMDM_RESERVED_2_OFFSET 0x18088

/* IMX_USB3_USBSS_XECP_CMDM_RESERVED_3 - Event ring manager module reserved space. */
typedef union IMX_USB3_USBSS_XECP_CMDM_RESERVED_3_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved field, RO. */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_RESERVED_3_t;

/* Register XECP_CMDM_RESERVED_3 - Event ring manager module reserved space. */
#define IMX_USB3_USBSS_XECP_CMDM_RESERVED_3_OFFSET 0x1808C

/* IMX_USB3_USBSS_XECP_CMDM_RESERVED_4 - Event ring manager module reserved space. */
typedef union IMX_USB3_USBSS_XECP_CMDM_RESERVED_4_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved field, RO. */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_RESERVED_4_t;

/* Register XECP_CMDM_RESERVED_4 - Event ring manager module reserved space. */
#define IMX_USB3_USBSS_XECP_CMDM_RESERVED_4_OFFSET 0x18090

/* IMX_USB3_USBSS_XECP_CMDM_RESERVED_5 - Event ring manager module reserved space. */
typedef union IMX_USB3_USBSS_XECP_CMDM_RESERVED_5_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved field, RO. */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_RESERVED_5_t;

/* Register XECP_CMDM_RESERVED_5 - Event ring manager module reserved space. */
#define IMX_USB3_USBSS_XECP_CMDM_RESERVED_5_OFFSET 0x18094

/* IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1 - Command Manager Control register 1. */
typedef union IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t UPDATE_ENDPT_EVENT_ENABLE :1;   /* '0': Disable generation of the completion event. '1': Enable the command manager to generate a completion event after an EP state update due to internal error. This bit is for test debug. */
        uint32_t FORCE_BANDWIDTH_FAIL :1;        /* '0': Bandwidth calculation handled normally. '1': Forces a failure in the endpoint bandwidth calculation so that engine will reject a configure EP command. */
        uint32_t CLR_CNTX_4SETDQPTR :1;          /* '0': Disable clearing internal TRM and DMA context during a set TR DQ pointer command. '1': Enable clearing internal TRM and DMA context during a set TR DQ pointer command. */
        uint32_t ADDR_DEV_SLST_BSR_CHECK_EN :1;  /* '0': Address device does not return the error for this condition. '1': Enable the EP state (default state) check with address device command with BSR. If failed, an event with context state error will be generated. */
        uint32_t CLR_CNTX_4RSTDEV :1;            /* '0': Disable clearing internal TRM and DMA context during a reset device command. '1': Enable clearing internal TRM and DMA context during a reset device command. */
        uint32_t CLR_CNTX_4ENSLOT_REG :1;        /* '0': Disable clearing internal TRM and DMA context during an enable slot command. '1': Enable clearing internal TRM and DMA context during an enable slot command. */
        uint32_t CLR_CNTX_4ENADDR :1;            /* '0': Disable clearing internal TRM and DMA context during an address device command. '1': Enable clearing internal TRM and DMA context during an address device command. */
        uint32_t CLR_CNTX_4ENCFGENDPT :1;        /* '0': Disable clearing internal TRM and DMA context during a configure endpoint command. '1': Enable clearing internal TRM and DMA context during a configure endpoint command. */
        uint32_t CLR_EP_CNTX_4EN_SLOT :1;        /* '0': Disable clearing other internal EP status signals during an enable slot command. '1': Enable clearing other internal EP related status signals such as EP scheduled array, credit stored per EP. etc., during an enable slot command. */
        uint32_t CLR_EP_CNTX_4RST_ENDPT :1;      /* '0': Disable clearing other internal EP status signals during a reset endpoint command. '1': Enable clearing other internal EP related status signals such as EP scheduled array, credit stored per EP. etc. during a reset endpoint command. */
        uint32_t CLR_EP_CNTX_4RST_DEVICE :1;     /* '0': Disable clearing other internal EP status signals during a reset device command. '1': Enable clearing other internal EP related status signals such as EP scheduled array, credit stored per EP, etc. during a reset device command. */
        uint32_t CLR_EP_CNTX_4CFG_ENDPT :1;      /* '0': Disable clearing other internal EP status signals during a configure endpoint command. '1': Enable clearing other internal EP related status signals such as EP scheduled array, credit stored per EP, etc. during a configure endpoint command. */
        uint32_t GLOB_TSP_EN :1;                 /* '0': Disable the global context preservation. '1': Enable the internal context preservation for all commands that needs to preserve some of the internal context fields as a command with TSP would. */
        uint32_t INIT_RETRY  :1;                 /* init_retry. Reserved to always read value of '1'. */
        uint32_t EVAL_EPST_CHECK_EN :1;          /* '0': Disable evaluating the endpoint state during an Evaluate Context command, '1': Enable EP state check during an Evaluate Context command. If failed, context error will be returned. */
        uint32_t CLR_EP_CNTX_4DIS_SLOT :1;       /* '0': Disable clearing internal TRM and DMA context as well as the internal EP status signals during a disable slot command. '1': Enable clearing internal TRM and DMA context as well as the internal EP status signals during a disable slot command. */
        uint32_t CLR_SPLIT_STATE_WITH_TSPSET :1; /* This bit allows engine to reset the split states when reset endpoint with TSP is posted. The split state is an internal context field in DMA engine. '0': Indicates that reset endpoint with TSP will preserve the split state. '1': Indicates that the reset endpoint with TSP will not preserve the split state. */
        uint32_t FORCE_BANDWIDTH_PASS :1;        /* force_bandwidth_pass */
        uint32_t FORCE_BANDWIDTH_SYS_PASS :1;    /* force_bandwidth_sys_pass */
        uint32_t REPORT_BANDWIDTH_SKIP_SCAN :1;  /* report_bandwidth_skip_scan */
        uint32_t ENABLE_MAX_EP_CACHE :1;         /* enable_max_ep_cache */
        uint32_t CFG_ENDPT_CNTX_LOCK_DIS :1;     /* Context lock mechanism to ensure command manager has exclusive access to internal context. This is a disable bit to allow software to turn off the context lock for configure endpoint command. This is a test/debug feature. '1': indicates disabled. '0': Indicates enabled */
        uint32_t FEATURE_RETRY_EN :1;            /* Enable the EOB and NPKT==0 (called NYET condition for USB3) to be used to update a retry bit during stream switching operation. This is an internal safety feature. It should be treated as reserved bit. */
        uint32_t EVAL_CNTX_BW_SCAN_EN :1;        /* Enable the Host Controller's Bandwidth checks for the Evaluate Context Command. Rescan the BW during evaluate context */
        uint32_t DEFAULT_ISOCH_EP_BANDWIDTH :4;  /* Bandwidth calculation parameter: Default bandwidth for an Isochronous Endpoint. */
        uint32_t DEFAULT_INTR_EP_BANDWIDTH :4;   /* Bandwidth calculation parameter: Default bandwidth for an Interrupt Endpoint. */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_t;

/* Register XECP_CMDM_CTRL_REG1 - Command Manager Control register 1. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_OFFSET 0x18098
/* Field UPDATE_ENDPT_EVENT_ENABLE - '0': Disable generation of the completion event. '1': Enable the command manager to generate a completion event after an EP state update due to internal error. This bit is for test debug. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_UPDATE_ENDPT_EVENT_ENABLE_SHIFT 0
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_UPDATE_ENDPT_EVENT_ENABLE_MASK 0x1
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_UPDATE_ENDPT_EVENT_ENABLE(v) (((v) << 0) & 0x1)
/* Field FORCE_BANDWIDTH_FAIL - '0': Bandwidth calculation handled normally. '1': Forces a failure in the endpoint bandwidth calculation so that engine will reject a configure EP command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_FAIL_SHIFT 1
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_FAIL_MASK 0x2
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_FAIL(v) (((v) << 0x1) & 0x2)
/* Field CLR_CNTX_4SETDQPTR - '0': Disable clearing internal TRM and DMA context during a set TR DQ pointer command. '1': Enable clearing internal TRM and DMA context during a set TR DQ pointer command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4SETDQPTR_SHIFT 2
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4SETDQPTR_MASK 0x4
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4SETDQPTR(v) (((v) << 0x2) & 0x4)
/* Field ADDR_DEV_SLST_BSR_CHECK_EN - '0': Address device does not return the error for this condition. '1': Enable the EP state (default state) check with address device command with BSR. If failed, an event with context state error will be generated. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_ADDR_DEV_SLST_BSR_CHECK_EN_SHIFT 3
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_ADDR_DEV_SLST_BSR_CHECK_EN_MASK 0x8
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_ADDR_DEV_SLST_BSR_CHECK_EN(v) (((v) << 0x3) & 0x8)
/* Field CLR_CNTX_4RSTDEV - '0': Disable clearing internal TRM and DMA context during a reset device command. '1': Enable clearing internal TRM and DMA context during a reset device command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4RSTDEV_SHIFT 4
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4RSTDEV_MASK 0x10
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4RSTDEV(v) (((v) << 0x4) & 0x10)
/* Field CLR_CNTX_4ENSLOT_REG - '0': Disable clearing internal TRM and DMA context during an enable slot command. '1': Enable clearing internal TRM and DMA context during an enable slot command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENSLOT_REG_SHIFT 5
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENSLOT_REG_MASK 0x20
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENSLOT_REG(v) (((v) << 0x5) & 0x20)
/* Field CLR_CNTX_4ENADDR - '0': Disable clearing internal TRM and DMA context during an address device command. '1': Enable clearing internal TRM and DMA context during an address device command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENADDR_SHIFT 6
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENADDR_MASK 0x40
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENADDR(v) (((v) << 0x6) & 0x40)
/* Field CLR_CNTX_4ENCFGENDPT - '0': Disable clearing internal TRM and DMA context during a configure endpoint command. '1': Enable clearing internal TRM and DMA context during a configure endpoint command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENCFGENDPT_SHIFT 7
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENCFGENDPT_MASK 0x80
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_CNTX_4ENCFGENDPT(v) (((v) << 0x7) & 0x80)
/* Field CLR_EP_CNTX_4EN_SLOT - '0': Disable clearing other internal EP status signals during an enable slot command. '1': Enable clearing other internal EP related status signals such as EP scheduled array, credit stored per EP. etc., during an enable slot command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4EN_SLOT_SHIFT 8
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4EN_SLOT_MASK 0x100
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4EN_SLOT(v) (((v) << 0x8) & 0x100)
/* Field CLR_EP_CNTX_4RST_ENDPT - '0': Disable clearing other internal EP status signals during a reset endpoint command. '1': Enable clearing other internal EP related status signals such as EP scheduled array, credit stored per EP. etc. during a reset endpoint command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4RST_ENDPT_SHIFT 9
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4RST_ENDPT_MASK 0x200
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4RST_ENDPT(v) (((v) << 0x9) & 0x200)
/* Field CLR_EP_CNTX_4RST_DEVICE - '0': Disable clearing other internal EP status signals during a reset device command. '1': Enable clearing other internal EP related status signals such as EP scheduled array, credit stored per EP, etc. during a reset device command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4RST_DEVICE_SHIFT 10
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4RST_DEVICE_MASK 0x400
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4RST_DEVICE(v) (((v) << 0xA) & 0x400)
/* Field CLR_EP_CNTX_4CFG_ENDPT - '0': Disable clearing other internal EP status signals during a configure endpoint command. '1': Enable clearing other internal EP related status signals such as EP scheduled array, credit stored per EP, etc. during a configure endpoint command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4CFG_ENDPT_SHIFT 11
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4CFG_ENDPT_MASK 0x800
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4CFG_ENDPT(v) (((v) << 0xB) & 0x800)
/* Field GLOB_TSP_EN - '0': Disable the global context preservation. '1': Enable the internal context preservation for all commands that needs to preserve some of the internal context fields as a command with TSP would. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_GLOB_TSP_EN_SHIFT 12
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_GLOB_TSP_EN_MASK 0x1000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_GLOB_TSP_EN(v) (((v) << 0xC) & 0x1000)
/* Field INIT_RETRY - init_retry. Reserved to always read value of '1'. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_INIT_RETRY_SHIFT 13
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_INIT_RETRY_MASK 0x2000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_INIT_RETRY(v) (((v) << 0xD) & 0x2000)
/* Field EVAL_EPST_CHECK_EN - '0': Disable evaluating the endpoint state during an Evaluate Context command, '1': Enable EP state check during an Evaluate Context command. If failed, context error will be returned. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_EVAL_EPST_CHECK_EN_SHIFT 14
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_EVAL_EPST_CHECK_EN_MASK 0x4000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_EVAL_EPST_CHECK_EN(v) (((v) << 0xE) & 0x4000)
/* Field CLR_EP_CNTX_4DIS_SLOT - '0': Disable clearing internal TRM and DMA context as well as the internal EP status signals during a disable slot command. '1': Enable clearing internal TRM and DMA context as well as the internal EP status signals during a disable slot command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4DIS_SLOT_SHIFT 15
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4DIS_SLOT_MASK 0x8000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_EP_CNTX_4DIS_SLOT(v) (((v) << 0xF) & 0x8000)
/* Field CLR_SPLIT_STATE_WITH_TSPSET - This bit allows engine to reset the split states when reset endpoint with TSP is posted. The split state is an internal context field in DMA engine. '0': Indicates that reset endpoint with TSP will preserve the split state. '1': Indicates that the reset endpoint with TSP will not preserve the split state. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_SPLIT_STATE_WITH_TSPSET_SHIFT 16
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_SPLIT_STATE_WITH_TSPSET_MASK 0x10000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CLR_SPLIT_STATE_WITH_TSPSET(v) (((v) << 0x10) & 0x10000)
/* Field FORCE_BANDWIDTH_PASS - force_bandwidth_pass */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_PASS_SHIFT 17
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_PASS_MASK 0x20000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_PASS(v) (((v) << 0x11) & 0x20000)
/* Field FORCE_BANDWIDTH_SYS_PASS - force_bandwidth_sys_pass */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_SYS_PASS_SHIFT 18
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_SYS_PASS_MASK 0x40000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FORCE_BANDWIDTH_SYS_PASS(v) (((v) << 0x12) & 0x40000)
/* Field REPORT_BANDWIDTH_SKIP_SCAN - report_bandwidth_skip_scan */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_REPORT_BANDWIDTH_SKIP_SCAN_SHIFT 19
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_REPORT_BANDWIDTH_SKIP_SCAN_MASK 0x80000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_REPORT_BANDWIDTH_SKIP_SCAN(v) (((v) << 0x13) & 0x80000)
/* Field ENABLE_MAX_EP_CACHE - enable_max_ep_cache */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_ENABLE_MAX_EP_CACHE_SHIFT 20
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_ENABLE_MAX_EP_CACHE_MASK 0x100000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_ENABLE_MAX_EP_CACHE(v) (((v) << 0x14) & 0x100000)
/* Field CFG_ENDPT_CNTX_LOCK_DIS - Context lock mechanism to ensure command manager has exclusive access to internal context. This is a disable bit to allow software to turn off the context lock for configure endpoint command. This is a test/debug feature. '1': indicates disabled. '0': Indicates enabled */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CFG_ENDPT_CNTX_LOCK_DIS_SHIFT 21
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CFG_ENDPT_CNTX_LOCK_DIS_MASK 0x200000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_CFG_ENDPT_CNTX_LOCK_DIS(v) (((v) << 0x15) & 0x200000)
/* Field FEATURE_RETRY_EN - Enable the EOB and NPKT==0 (called NYET condition for USB3) to be used to update a retry bit during stream switching operation. This is an internal safety feature. It should be treated as reserved bit. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FEATURE_RETRY_EN_SHIFT 22
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FEATURE_RETRY_EN_MASK 0x400000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_FEATURE_RETRY_EN(v) (((v) << 0x16) & 0x400000)
/* Field EVAL_CNTX_BW_SCAN_EN - Enable the Host Controller's Bandwidth checks for the Evaluate Context Command. Rescan the BW during evaluate context */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_EVAL_CNTX_BW_SCAN_EN_SHIFT 23
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_EVAL_CNTX_BW_SCAN_EN_MASK 0x800000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_EVAL_CNTX_BW_SCAN_EN(v) (((v) << 0x17) & 0x800000)
/* Field DEFAULT_ISOCH_EP_BANDWIDTH - Bandwidth calculation parameter: Default bandwidth for an Isochronous Endpoint. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_DEFAULT_ISOCH_EP_BANDWIDTH_SHIFT 24
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_DEFAULT_ISOCH_EP_BANDWIDTH_MASK 0xF000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_DEFAULT_ISOCH_EP_BANDWIDTH(v) (((v) << 0x18) & 0xF000000)
/* Field DEFAULT_INTR_EP_BANDWIDTH - Bandwidth calculation parameter: Default bandwidth for an Interrupt Endpoint. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_DEFAULT_INTR_EP_BANDWIDTH_SHIFT 28
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_DEFAULT_INTR_EP_BANDWIDTH_MASK 0xF0000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_DEFAULT_INTR_EP_BANDWIDTH(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2 - Command Manager Control register 2. */
typedef union IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_union_t {
    uint32_t R;
    struct {
        uint32_t CLR_ST      :14;                /* Clear state machine present state: Setting a specified bit to '1', will reset the corresponding command manager state machine to the starting/idle state. bit-0: disable slot state machine; bit-1: enable slot state machine; bit-2: reset endpoint state machine; bit-3: reset device state machine; bit-4: command ring state machine; bit-5: stop endpoint state machine; bit-6: set dq pointer state machine; bit-7: force header state machine; bit-8: evaluate context state machine; bit-9: update endpoint state machine; bit-10: address device state machine; bit-11: port bandwidth state machine; bit-12: read output context state machine; bit-13: configure endpoint state machine; */
        uint32_t BURST_SIZE_DEFAULT_EN :1;       /* When context is first initialized, it is assumed one remote NPKT. It is also assumed that max burst size as remote NPKT. This bit enables to assume max burst size as remote NPKT. '0': Assume 1 NPKT. '1': Assume max burst size as NPKT. */
        uint32_t DISABLE_STALL_CLR_EP :1;        /* '0': Stall handling does clear the internal EP status signals. '1': Disable the clear function when stall response received. */
        uint32_t INCREASE_UPDATE_EP_PRIORITY_EN :1; /* Increase Update EP priority over commands in the command ring to avoid prolonging STALL handling. '0': Pending commands have a higher priority than update endpoint processing. '1': Update endpoint processing in the command manager has a higher priority than pending commands. Note: Enabling this bit can prevent prolonged stall handling. */
        uint32_t TRM_BREAK_LOOP_EN :1;           /* trm_break_loop_en. This is an internal safeguard register. It enables a different mechanism of handling stop endpoint command. It should be treated as a reserved field. The default should not be alternate unless specific purpose. '0': Disable. '1': Enable. */
        uint32_t TSP_4SET_DQPTR_REG :1;          /* '0': Disable sequence number preservation during set DQ pointer command. '1': Enable sequence number to be preserved during set DQ pointer command. */
        uint32_t FORCE_RESET_ENDPT_REG :1;       /* '0': Check the slot and endpoint state prior to processing a reset endpoint command. '1': Ignore the slot and endpoint state when processing a reset endpoint command. */
        uint32_t SET_DQPTR_CLR_EP_ARYS :1;       /* '0': Disable clearing other internal EP status signals during a set DQ pointer command. '1': Enable clearing other internal EP status signals during a set DQ pointer command. */
        uint32_t CMD_ST_DIS_REG :1;              /* '0': Delay processing command ring TRB while internal context requests are pending. '1': Process command ring TRBs normally. */
        uint32_t ENABLE_BW_CAL :1;               /* '0': Disable hardware bandwidth calculations. '1': Enable hardware bandwidth calculations. */
        uint32_t CLR_CNTX_4RST_ENDPT_REG :1;     /* '0': Disable clearing internal TRM and DMA context during a reset endpoint command. '1': Enable clearing internal TRM and DMA context during a reset endpoint command. */
        uint32_t MOVE_XFER_DQPTR_2CPL_DQPTR_EN :1; /* '0': The internal context write DQ pointer moved to internal read pointer during reset EP command. '1': The write DQ pointer stays as it was during reset endpoint command. */
        uint32_t CLR_EP_CNTX_4STALL_UPD :1;      /* '0': Disable clearing other internal EP status signal during stall handling. '1': Enable clearing other internal EP status signal during stall handling. */
        uint32_t CLR_EP_CNTX_4STOP_ENDPT :1;     /* '0': Disable clearing other internal per EP status signal during a stop endpoint command. '1': Enable clearing other internal per EP status signal during a stop endpoint command. */
        uint32_t ALL_CLK_GATE_DIS :1;            /* '0': Turn ON the TTE clock. '1': Turn OFF the TTE clock. */
        uint32_t SRE         :1;                 /* Force and error on save command always. '0': do not force, '1': always force return save error. */
        uint32_t SLOT_ID_OVERIDE_EN :1;          /* Force '0' on slot ID when a command transfer event is generated. '0': not forced, '1': Forced to 0. */
        uint32_t STOP_ENDPT_2MS_TIMEOUT_EN :1;   /* Enable a delay to stop endpoint command that is executed in XFER engine. '0': XFER engine will not wait. '1': XFER engine will always wait for 2 ms before it checks whether an EP transfer ring is at a stop of packet boundary */
        uint32_t DOING_2DW_OCNTX_WR_EN :1;       /* Enable only to update the EP state to output context on every EP output context update condition. This is to allow to have a control over either update the entire EPoutput context field or only update the first two DWORDs. '0': update the entire output context field. '1': update only 2 DWORDs */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_t;

/* Register XECP_CMDM_CTRL_REG2 - Command Manager Control register 2. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_OFFSET 0x1809C
/* Field CLR_ST - Clear state machine present state: Setting a specified bit to '1', will reset the corresponding command manager state machine to the starting/idle state. bit-0: disable slot state machine; bit-1: enable slot state machine; bit-2: reset endpoint state machine; bit-3: reset device state machine; bit-4: command ring state machine; bit-5: stop endpoint state machine; bit-6: set dq pointer state machine; bit-7: force header state machine; bit-8: evaluate context state machine; bit-9: update endpoint state machine; bit-10: address device state machine; bit-11: port bandwidth state machine; bit-12: read output context state machine; bit-13: configure endpoint state machine; */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_ST_SHIFT 0
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_ST_MASK 0x3FFF
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_ST(v) (((v) << 0) & 0x3FFF)
/* Field BURST_SIZE_DEFAULT_EN - When context is first initialized, it is assumed one remote NPKT. It is also assumed that max burst size as remote NPKT. This bit enables to assume max burst size as remote NPKT. '0': Assume 1 NPKT. '1': Assume max burst size as NPKT. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_BURST_SIZE_DEFAULT_EN_SHIFT 14
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_BURST_SIZE_DEFAULT_EN_MASK 0x4000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_BURST_SIZE_DEFAULT_EN(v) (((v) << 0xE) & 0x4000)
/* Field DISABLE_STALL_CLR_EP - '0': Stall handling does clear the internal EP status signals. '1': Disable the clear function when stall response received. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_DISABLE_STALL_CLR_EP_SHIFT 15
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_DISABLE_STALL_CLR_EP_MASK 0x8000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_DISABLE_STALL_CLR_EP(v) (((v) << 0xF) & 0x8000)
/* Field INCREASE_UPDATE_EP_PRIORITY_EN - Increase Update EP priority over commands in the command ring to avoid prolonging STALL handling. '0': Pending commands have a higher priority than update endpoint processing. '1': Update endpoint processing in the command manager has a higher priority than pending commands. Note: Enabling this bit can prevent prolonged stall handling. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_INCREASE_UPDATE_EP_PRIORITY_EN_SHIFT 16
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_INCREASE_UPDATE_EP_PRIORITY_EN_MASK 0x10000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_INCREASE_UPDATE_EP_PRIORITY_EN(v) (((v) << 0x10) & 0x10000)
/* Field TRM_BREAK_LOOP_EN - trm_break_loop_en. This is an internal safeguard register. It enables a different mechanism of handling stop endpoint command. It should be treated as a reserved field. The default should not be alternate unless specific purpose. '0': Disable. '1': Enable. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_TRM_BREAK_LOOP_EN_SHIFT 17
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_TRM_BREAK_LOOP_EN_MASK 0x20000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_TRM_BREAK_LOOP_EN(v) (((v) << 0x11) & 0x20000)
/* Field TSP_4SET_DQPTR_REG - '0': Disable sequence number preservation during set DQ pointer command. '1': Enable sequence number to be preserved during set DQ pointer command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_TSP_4SET_DQPTR_REG_SHIFT 18
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_TSP_4SET_DQPTR_REG_MASK 0x40000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_TSP_4SET_DQPTR_REG(v) (((v) << 0x12) & 0x40000)
/* Field FORCE_RESET_ENDPT_REG - '0': Check the slot and endpoint state prior to processing a reset endpoint command. '1': Ignore the slot and endpoint state when processing a reset endpoint command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_FORCE_RESET_ENDPT_REG_SHIFT 19
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_FORCE_RESET_ENDPT_REG_MASK 0x80000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_FORCE_RESET_ENDPT_REG(v) (((v) << 0x13) & 0x80000)
/* Field SET_DQPTR_CLR_EP_ARYS - '0': Disable clearing other internal EP status signals during a set DQ pointer command. '1': Enable clearing other internal EP status signals during a set DQ pointer command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SET_DQPTR_CLR_EP_ARYS_SHIFT 20
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SET_DQPTR_CLR_EP_ARYS_MASK 0x100000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SET_DQPTR_CLR_EP_ARYS(v) (((v) << 0x14) & 0x100000)
/* Field CMD_ST_DIS_REG - '0': Delay processing command ring TRB while internal context requests are pending. '1': Process command ring TRBs normally. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CMD_ST_DIS_REG_SHIFT 21
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CMD_ST_DIS_REG_MASK 0x200000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CMD_ST_DIS_REG(v) (((v) << 0x15) & 0x200000)
/* Field ENABLE_BW_CAL - '0': Disable hardware bandwidth calculations. '1': Enable hardware bandwidth calculations. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_ENABLE_BW_CAL_SHIFT 22
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_ENABLE_BW_CAL_MASK 0x400000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_ENABLE_BW_CAL(v) (((v) << 0x16) & 0x400000)
/* Field CLR_CNTX_4RST_ENDPT_REG - '0': Disable clearing internal TRM and DMA context during a reset endpoint command. '1': Enable clearing internal TRM and DMA context during a reset endpoint command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_CNTX_4RST_ENDPT_REG_SHIFT 23
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_CNTX_4RST_ENDPT_REG_MASK 0x800000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_CNTX_4RST_ENDPT_REG(v) (((v) << 0x17) & 0x800000)
/* Field MOVE_XFER_DQPTR_2CPL_DQPTR_EN - '0': The internal context write DQ pointer moved to internal read pointer during reset EP command. '1': The write DQ pointer stays as it was during reset endpoint command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_MOVE_XFER_DQPTR_2CPL_DQPTR_EN_SHIFT 24
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_MOVE_XFER_DQPTR_2CPL_DQPTR_EN_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_MOVE_XFER_DQPTR_2CPL_DQPTR_EN(v) (((v) << 0x18) & 0x1000000)
/* Field CLR_EP_CNTX_4STALL_UPD - '0': Disable clearing other internal EP status signal during stall handling. '1': Enable clearing other internal EP status signal during stall handling. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_EP_CNTX_4STALL_UPD_SHIFT 25
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_EP_CNTX_4STALL_UPD_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_EP_CNTX_4STALL_UPD(v) (((v) << 0x19) & 0x2000000)
/* Field CLR_EP_CNTX_4STOP_ENDPT - '0': Disable clearing other internal per EP status signal during a stop endpoint command. '1': Enable clearing other internal per EP status signal during a stop endpoint command. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_EP_CNTX_4STOP_ENDPT_SHIFT 26
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_EP_CNTX_4STOP_ENDPT_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_CLR_EP_CNTX_4STOP_ENDPT(v) (((v) << 0x1A) & 0x4000000)
/* Field ALL_CLK_GATE_DIS - '0': Turn ON the TTE clock. '1': Turn OFF the TTE clock. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_ALL_CLK_GATE_DIS_SHIFT 27
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_ALL_CLK_GATE_DIS_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_ALL_CLK_GATE_DIS(v) (((v) << 0x1B) & 0x8000000)
/* Field SRE - Force and error on save command always. '0': do not force, '1': always force return save error. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SRE_SHIFT 28
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SRE_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SRE(v) (((v) << 0x1C) & 0x10000000)
/* Field SLOT_ID_OVERIDE_EN - Force '0' on slot ID when a command transfer event is generated. '0': not forced, '1': Forced to 0. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SLOT_ID_OVERIDE_EN_SHIFT 29
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SLOT_ID_OVERIDE_EN_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_SLOT_ID_OVERIDE_EN(v) (((v) << 0x1D) & 0x20000000)
/* Field STOP_ENDPT_2MS_TIMEOUT_EN - Enable a delay to stop endpoint command that is executed in XFER engine. '0': XFER engine will not wait. '1': XFER engine will always wait for 2 ms before it checks whether an EP transfer ring is at a stop of packet boundary */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_STOP_ENDPT_2MS_TIMEOUT_EN_SHIFT 30
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_STOP_ENDPT_2MS_TIMEOUT_EN_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_STOP_ENDPT_2MS_TIMEOUT_EN(v) (((v) << 0x1E) & 0x40000000)
/* Field DOING_2DW_OCNTX_WR_EN - Enable only to update the EP state to output context on every EP output context update condition. This is to allow to have a control over either update the entire EPoutput context field or only update the first two DWORDs. '0': update the entire output context field. '1': update only 2 DWORDs */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_DOING_2DW_OCNTX_WR_EN_SHIFT 31
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_DOING_2DW_OCNTX_WR_EN_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_DOING_2DW_OCNTX_WR_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3 - Command Manager Control register 3. */
typedef union IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_union_t {
    uint32_t R;
    struct {
        uint32_t DEFAULT_PORT_BANDWD_AVAIL :8;   /* The default available bandwidth to advertise on each LS, FS, SS port in 10% increments (90%). Bandwidth calculation is a reserved field for PPT. */
        uint32_t DEFAULT_HS_BANDWD_AVAIL :8;     /* The default available bandwidth to advertise on each HS port in 10% increments (80%). Bandwidth Calculation is a reserved field for PPT. */
        uint32_t DISABLE_SLOT_TIMER_SELECT :2;   /* These two bits specify the delay that we can have for disable slot state to be completed. We can delay the generation of the command transfer event during disable slot command. Possible values: '00': delay is disabled, '01': 100us delay, '10': 8ms delay, '11': 10ms delay. */
        uint32_t CLR_TRM_DMA_CNTX_EN :1;         /* clr_trm_dma_cntx_en */
        uint32_t STOP_2TIMEOUT_EN :1;            /* stop_2timeout_en. Stop transaction timeout. */
        uint32_t BREAK_CNTX_LOCK_EN :1;          /* break_cntx_lock_en */
        uint32_t STOP_EP_CLR_STREAM_ST_EN :1;    /* stop_ep_clr_stream_st_en. Enable stop endpoint command to return stream st to disabled (0) in EP context. */
        uint32_t ALLOW_CLR_4STOP :1;             /* allow_clr_4stop */
        uint32_t STREAM_ALWAYS_UPDATE_CNTX :1;   /* stream_always_update_cntx */
        uint32_t SET_BURST_SIZE_4PRDC_DIS :1;    /* set_burst_size_4prdc_dis */
        uint32_t STOP_EP_CLR_LCSTREAM_ID_EN :1;  /* stop_ep_clr_lcstream_id_en. Enable stop endpoint command to return stream st to disabled (0) in EP context. */
        uint32_t UPDATE_CNTX_WHEN_STOPPED :1;    /* update_cntx_when_stopped. Allow setTRDQPtr cmd to update the local context anytime the EP is not running (otherwise checks CSTREAMID). */
        uint32_t DISABLE_SETDQPTR_CLR_STREAM_ST :1; /* disable_setdqptr_clr_stream_st. Disable setTRDQPtr from clearing the current stream state. */
        uint32_t DISABLE_NON0EP_CNTX_CLR :1;     /* disable_non0ep_cntx_clr */
        uint32_t EXTRA_DB_RM_4STOP_EN :1;        /* extra_db_rm_4stop_en */
        uint32_t IGNORE_HI_ATOMIC_EN :1;         /* ignore_hi_atomic_en */
        uint32_t FRINDEX_WR_EN :1;               /* MFIndex register write enable. For debug purposes. */
    } B;
} IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_t;

/* Register XECP_CMDM_CTRL_REG3 - Command Manager Control register 3. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_OFFSET 0x180A0
/* Field DEFAULT_PORT_BANDWD_AVAIL - The default available bandwidth to advertise on each LS, FS, SS port in 10% increments (90%). Bandwidth calculation is a reserved field for PPT. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DEFAULT_PORT_BANDWD_AVAIL_SHIFT 0
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DEFAULT_PORT_BANDWD_AVAIL_MASK 0xFF
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DEFAULT_PORT_BANDWD_AVAIL(v) (((v) << 0) & 0xFF)
/* Field DEFAULT_HS_BANDWD_AVAIL - The default available bandwidth to advertise on each HS port in 10% increments (80%). Bandwidth Calculation is a reserved field for PPT. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DEFAULT_HS_BANDWD_AVAIL_SHIFT 8
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DEFAULT_HS_BANDWD_AVAIL_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DEFAULT_HS_BANDWD_AVAIL(v) (((v) << 0x8) & 0xFF00)
/* Field DISABLE_SLOT_TIMER_SELECT - These two bits specify the delay that we can have for disable slot state to be completed. We can delay the generation of the command transfer event during disable slot command. Possible values: '00': delay is disabled, '01': 100us delay, '10': 8ms delay, '11': 10ms delay. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_SLOT_TIMER_SELECT_SHIFT 16
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_SLOT_TIMER_SELECT_MASK 0x30000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_SLOT_TIMER_SELECT(v) (((v) << 0x10) & 0x30000)
/* Field CLR_TRM_DMA_CNTX_EN - clr_trm_dma_cntx_en */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_CLR_TRM_DMA_CNTX_EN_SHIFT 18
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_CLR_TRM_DMA_CNTX_EN_MASK 0x40000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_CLR_TRM_DMA_CNTX_EN(v) (((v) << 0x12) & 0x40000)
/* Field STOP_2TIMEOUT_EN - stop_2timeout_en. Stop transaction timeout. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_2TIMEOUT_EN_SHIFT 19
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_2TIMEOUT_EN_MASK 0x80000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_2TIMEOUT_EN(v) (((v) << 0x13) & 0x80000)
/* Field BREAK_CNTX_LOCK_EN - break_cntx_lock_en */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_BREAK_CNTX_LOCK_EN_SHIFT 20
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_BREAK_CNTX_LOCK_EN_MASK 0x100000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_BREAK_CNTX_LOCK_EN(v) (((v) << 0x14) & 0x100000)
/* Field STOP_EP_CLR_STREAM_ST_EN - stop_ep_clr_stream_st_en. Enable stop endpoint command to return stream st to disabled (0) in EP context. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_EP_CLR_STREAM_ST_EN_SHIFT 21
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_EP_CLR_STREAM_ST_EN_MASK 0x200000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_EP_CLR_STREAM_ST_EN(v) (((v) << 0x15) & 0x200000)
/* Field ALLOW_CLR_4STOP - allow_clr_4stop */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_ALLOW_CLR_4STOP_SHIFT 22
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_ALLOW_CLR_4STOP_MASK 0x400000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_ALLOW_CLR_4STOP(v) (((v) << 0x16) & 0x400000)
/* Field STREAM_ALWAYS_UPDATE_CNTX - stream_always_update_cntx */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STREAM_ALWAYS_UPDATE_CNTX_SHIFT 23
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STREAM_ALWAYS_UPDATE_CNTX_MASK 0x800000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STREAM_ALWAYS_UPDATE_CNTX(v) (((v) << 0x17) & 0x800000)
/* Field SET_BURST_SIZE_4PRDC_DIS - set_burst_size_4prdc_dis */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_SET_BURST_SIZE_4PRDC_DIS_SHIFT 24
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_SET_BURST_SIZE_4PRDC_DIS_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_SET_BURST_SIZE_4PRDC_DIS(v) (((v) << 0x18) & 0x1000000)
/* Field STOP_EP_CLR_LCSTREAM_ID_EN - stop_ep_clr_lcstream_id_en. Enable stop endpoint command to return stream st to disabled (0) in EP context. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_EP_CLR_LCSTREAM_ID_EN_SHIFT 25
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_EP_CLR_LCSTREAM_ID_EN_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_STOP_EP_CLR_LCSTREAM_ID_EN(v) (((v) << 0x19) & 0x2000000)
/* Field UPDATE_CNTX_WHEN_STOPPED - update_cntx_when_stopped. Allow setTRDQPtr cmd to update the local context anytime the EP is not running (otherwise checks CSTREAMID). */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_UPDATE_CNTX_WHEN_STOPPED_SHIFT 26
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_UPDATE_CNTX_WHEN_STOPPED_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_UPDATE_CNTX_WHEN_STOPPED(v) (((v) << 0x1A) & 0x4000000)
/* Field DISABLE_SETDQPTR_CLR_STREAM_ST - disable_setdqptr_clr_stream_st. Disable setTRDQPtr from clearing the current stream state. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_SETDQPTR_CLR_STREAM_ST_SHIFT 27
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_SETDQPTR_CLR_STREAM_ST_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_SETDQPTR_CLR_STREAM_ST(v) (((v) << 0x1B) & 0x8000000)
/* Field DISABLE_NON0EP_CNTX_CLR - disable_non0ep_cntx_clr */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_NON0EP_CNTX_CLR_SHIFT 28
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_NON0EP_CNTX_CLR_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_DISABLE_NON0EP_CNTX_CLR(v) (((v) << 0x1C) & 0x10000000)
/* Field EXTRA_DB_RM_4STOP_EN - extra_db_rm_4stop_en */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_EXTRA_DB_RM_4STOP_EN_SHIFT 29
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_EXTRA_DB_RM_4STOP_EN_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_EXTRA_DB_RM_4STOP_EN(v) (((v) << 0x1D) & 0x20000000)
/* Field IGNORE_HI_ATOMIC_EN - ignore_hi_atomic_en */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_IGNORE_HI_ATOMIC_EN_SHIFT 30
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_IGNORE_HI_ATOMIC_EN_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_IGNORE_HI_ATOMIC_EN(v) (((v) << 0x1E) & 0x40000000)
/* Field FRINDEX_WR_EN - MFIndex register write enable. For debug purposes. */
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_FRINDEX_WR_EN_SHIFT 31
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_FRINDEX_WR_EN_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_FRINDEX_WR_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_CAP - This is a register that describes the host controller's extended capability location. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_union_t {
    uint32_t R;
    struct {
        uint32_t VEND_DEF_HOST_CAP_ID_192 :8;    /* Capability ID. This field identifies the xHCI Extended capability. 192-255 are IDs available for vendor specific extensions to the xHCI. */
        uint32_t XECP_HOST_NEXT_CAP_OFFSET :8;   /* Next xHCI Extended Capability Pointer. This field points to the xHC MMIO space offset of the next xHCI extended capability pointer. A value of 00h indicates the end of the extended capability list. A non-zero value in this register indicates a relative offset, in Dwords, from this Dword to the beginning of the next extended capability. For example, assuming an effective address of this data structure is 350h and assuming a pointer value of 068h, we can calculate the following effective address: 350h + (068h << 2) -> 350h + 1A0h -> 4F0h */
        uint32_t _unused16   :16;                /* Reserved field, RO. */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_t;

/* Register XECP_HOST_CTRL_CAP - This is a register that describes the host controller's extended capability location. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_OFFSET 0x180B0
/* Field VEND_DEF_HOST_CAP_ID_192 - Capability ID. This field identifies the xHCI Extended capability. 192-255 are IDs available for vendor specific extensions to the xHCI. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_VEND_DEF_HOST_CAP_ID_192_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_VEND_DEF_HOST_CAP_ID_192_MASK 0xFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_VEND_DEF_HOST_CAP_ID_192(v) (((v) << 0) & 0xFF)
/* Field XECP_HOST_NEXT_CAP_OFFSET - Next xHCI Extended Capability Pointer. This field points to the xHC MMIO space offset of the next xHCI extended capability pointer. A value of 00h indicates the end of the extended capability list. A non-zero value in this register indicates a relative offset, in Dwords, from this Dword to the beginning of the next extended capability. For example, assuming an effective address of this data structure is 350h and assuming a pointer value of 068h, we can calculate the following effective address: 350h + (068h << 2) -> 350h + 1A0h -> 4F0h */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_XECP_HOST_NEXT_CAP_OFFSET_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_XECP_HOST_NEXT_CAP_OFFSET_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_XECP_HOST_NEXT_CAP_OFFSET(v) (((v) << 0x8) & 0xFF00)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_RSVD - Reserved space. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_RSVD_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved: Reserved for future RO implementations. Registers or memory that shall be treated as read-only by system software. Rsvd registers shall return zero when read. Software shall ignore the value read from these bits. Note: At present the fields are implemented as RO. */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_RSVD_t;

/* Register XECP_HOST_CTRL_RSVD - Reserved space. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_RSVD_OFFSET 0x180B4

/* IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG - Override Endpoint Flow Control. */
typedef union IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_union_t {
    uint32_t R;
    struct {
        uint32_t EP_DIR      :1;                 /* Indicates the direction of the Endpoint */
        uint32_t EP_NUM      :4;                 /* Endpoint number */
        uint32_t SLOT_NUM    :5;                 /* Slot number. */
        uint32_t _unused10   :22;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_t;

/* Register XECP_HOST_CLR_MASK_REG - Override Endpoint Flow Control. */
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_OFFSET 0x180B8
/* Field EP_DIR - Indicates the direction of the Endpoint */
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_EP_DIR_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_EP_DIR_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_EP_DIR(v) (((v) << 0) & 0x1)
/* Field EP_NUM - Endpoint number */
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_EP_NUM_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_EP_NUM_MASK 0x1E
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_EP_NUM(v) (((v) << 0x1) & 0x1E)
/* Field SLOT_NUM - Slot number. */
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_SLOT_NUM_SHIFT 5
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_SLOT_NUM_MASK 0x3E0
#define IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_SLOT_NUM(v) (((v) << 0x5) & 0x3E0)

/* IMX_USB3_USBSS_XECP_HOST_CLR_IN_EP_VALID_REG - Clear Active IN EP ID Control. */
typedef union IMX_USB3_USBSS_XECP_HOST_CLR_IN_EP_VALID_REG_union_t {
    uint32_t R;
    struct {
        uint32_t PORT_NUM    :32;                /* This field indicates the port number. */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CLR_IN_EP_VALID_REG_t;

/* Register XECP_HOST_CLR_IN_EP_VALID_REG - Clear Active IN EP ID Control. */
#define IMX_USB3_USBSS_XECP_HOST_CLR_IN_EP_VALID_REG_OFFSET 0x180BC
/* Field PORT_NUM - This field indicates the port number. */
#define IMX_USB3_USBSS_XECP_HOST_CLR_IN_EP_VALID_REG_PORT_NUM_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CLR_IN_EP_VALID_REG_PORT_NUM_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_HOST_CLR_IN_EP_VALID_REG_PORT_NUM(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG - Clear Poll Mask Control. */
typedef union IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_union_t {
    uint32_t R;
    struct {
        uint32_t EP_DIR      :1;                 /* Indicates the direction of the Endpoint */
        uint32_t EP_NUM      :4;                 /* Endpoint number */
        uint32_t SLOT_NUM    :5;                 /* Slot number */
        uint32_t _unused10   :22;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_t;

/* Register XECP_HOST_CLR_PMASK_REG - Clear Poll Mask Control. */
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_OFFSET 0x180C0
/* Field EP_DIR - Indicates the direction of the Endpoint */
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_EP_DIR_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_EP_DIR_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_EP_DIR(v) (((v) << 0) & 0x1)
/* Field EP_NUM - Endpoint number */
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_EP_NUM_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_EP_NUM_MASK 0x1E
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_EP_NUM(v) (((v) << 0x1) & 0x1E)
/* Field SLOT_NUM - Slot number */
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_SLOT_NUM_SHIFT 5
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_SLOT_NUM_MASK 0x3E0
#define IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_SLOT_NUM(v) (((v) << 0x5) & 0x3E0)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG - Port Credit Control. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_union_t {
    uint32_t R;
    struct {
        uint32_t PORT_NUM    :8;                 /* port number */
        uint32_t _unused8    :18;                /* Reserved field, RO */
        uint32_t ST_UPD_REG  :1;                 /* Slot state control. st_upd_reg */
        uint32_t MINUS_4RFIFO :1;                /* Indicates whether the subtract command operates on TX FIFO credit or RX FIFO credit. */
        uint32_t MINUS_OCRD  :1;                 /* Subtract one credit from a port */
        uint32_t PLUS_OCRD   :1;                 /* Add one credit to a port */
        uint32_t CLR_CPL_ST  :1;                 /* Write '1' to force CPL state return to IDLE */
        uint32_t CLR_XFER_ST :1;                 /* Write '1' to force XFER state return to IDLE */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_t;

/* Register XECP_HOST_CTRL_OCRD_REG - Port Credit Control. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_OFFSET 0x180C4
/* Field PORT_NUM - port number */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_PORT_NUM_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_PORT_NUM_MASK 0xFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_PORT_NUM(v) (((v) << 0) & 0xFF)
/* Field ST_UPD_REG - Slot state control. st_upd_reg */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_ST_UPD_REG_SHIFT 26
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_ST_UPD_REG_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_ST_UPD_REG(v) (((v) << 0x1A) & 0x4000000)
/* Field MINUS_4RFIFO - Indicates whether the subtract command operates on TX FIFO credit or RX FIFO credit. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_MINUS_4RFIFO_SHIFT 27
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_MINUS_4RFIFO_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_MINUS_4RFIFO(v) (((v) << 0x1B) & 0x8000000)
/* Field MINUS_OCRD - Subtract one credit from a port */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_MINUS_OCRD_SHIFT 28
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_MINUS_OCRD_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_MINUS_OCRD(v) (((v) << 0x1C) & 0x10000000)
/* Field PLUS_OCRD - Add one credit to a port */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_PLUS_OCRD_SHIFT 29
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_PLUS_OCRD_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_PLUS_OCRD(v) (((v) << 0x1D) & 0x20000000)
/* Field CLR_CPL_ST - Write '1' to force CPL state return to IDLE */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_CLR_CPL_ST_SHIFT 30
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_CLR_CPL_ST_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_CLR_CPL_ST(v) (((v) << 0x1E) & 0x40000000)
/* Field CLR_XFER_ST - Write '1' to force XFER state return to IDLE */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_CLR_XFER_ST_SHIFT 31
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_CLR_XFER_ST_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_CLR_XFER_ST(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_LO - Test Bus Low Bits: Host controller test bus low 32 bits. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_LO_union_t {
    uint32_t R;
    struct {
        uint32_t TEST_BUS_LO :32;                /* Host controller test bus low 32-bits. */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_LO_t;

/* Register XECP_HOST_CTRL_TEST_BUS_LO - Test Bus Low Bits: Host controller test bus low 32 bits. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_LO_OFFSET 0x180C8
/* Field TEST_BUS_LO - Host controller test bus low 32-bits. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_LO_TEST_BUS_LO_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_LO_TEST_BUS_LO_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_LO_TEST_BUS_LO(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_HI - Test Bus High Bits: Host controller test bus high 32 bits. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_HI_union_t {
    uint32_t R;
    struct {
        uint32_t TEST_BUS_HI :32;                /* Host controller test bus high 32-bits. */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_HI_t;

/* Register XECP_HOST_CTRL_TEST_BUS_HI - Test Bus High Bits: Host controller test bus high 32 bits. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_HI_OFFSET 0x180CC
/* Field TEST_BUS_HI - Host controller test bus high 32-bits. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_HI_TEST_BUS_HI_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_HI_TEST_BUS_HI_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_HI_TEST_BUS_HI(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1 - Host Control Transfer Manager (TRM) register. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t IN_TD_PACE_ENABLE :1;           /* '0': Disable TD pacing for IN endpoint. '1': Enable TD pacing for IN endpoints. */
        uint32_t DISABLE_FC_4INRDY :1;           /* '0': Obey the NPKT0 and EOB flow control. '1': Ignore received flow control for implied NRDY (e.g EOB or NPKT=0) for USB3 only */
        uint32_t LINK_NOP_SUCESS_EN :1;          /* '0': Process transaction errors due to CERR count reached or transaction timeout reported by the DMA engine. '1': Ignore transaction errors reported by the DMA engine. */
        uint32_t DISABLE_STALL :1;               /* '0': Process stalls reported by the DMA engine. '1': Ignore stall response received reported by the DMA engine. */
        uint32_t XPORT_CRD_DISABLE :1;           /* This bit is designed to allow XFER engine to do a transfer without checking against the available port credit. '0': Advertises accurate buffer credit information to the scheduler. '1': Advertises non-zero buffer credits to the scheduler (e.g. never backpressure back on buffer credit information) */
        uint32_t CPL_PKT_CLR_MASK_EN :1;         /* Enable a function, which clears a mask of an EP on any response of that EP. '0': Clear the scheduler mask normally, '1': Clear the scheduler mask on each received packet. */
        uint32_t EN_BB_PORT_DISABLE :1;          /* '0': Babble errors will not disable the port. '1': Babble errors will disable the auto detect function This will allow engine to handle more than 4 TRBs per packet. */
        uint32_t NPKT0_FC_DISABLE :1;            /* '0': USB3 responses with NumPkts equal to 0 will be treated as a flow control condition. '1': USB3 responses with NumPkts equal to 0 will not be treated as a flow control condition. */
        uint32_t TRB_CACHE_INVALIDE_EN :1;       /* '0': Disable internal TRB cache invalidation. '1': Enable internal TRB cache invalidation auto detect function. This will allow engine to handle more than 4 TRBs per packet. */
        uint32_t IN_NPKT_PACE_DISABLE :1;        /* Setting this bit to '1' will force the transfer engine state machine to exit the CPL_WAIT state. This is designed to avoid unexpected deadlock in CPL_WAIT state. */
        uint32_t FLUSH_2CLR_VALID_EN :1;         /* This bit is modified to support PPTB0, LPT and CP for a feature that we will clear the single IN EP array based on ISO flush or short flush. '0': Indicate that we do not need to clear IN EP array based on flush conditions. '1': indicate that we do clear IN EP array based on flush conditions */
        uint32_t CTRL_REG_CLR_BNDRY :1;          /* Setting this bit to '1' will force the transfer engine to set the packet boundary flag. This flag is an important flag, which may cause a deadlock. This is a safety feature that we have plugged in. */
        uint32_t ENT_EN      :1;                 /* '0': ENT bit is ignored. '1': ENT bit is processed. The transfer engine will service the next TRB. */
        uint32_t SINGLE_BURST_EN :1;             /* '0': Bulk and interrupt endpoints use burst size defined by endpoint context. '1: Force the Bulk and Interrupt endpoints to use a burst size of 1. */
        uint32_t XFER_BLOCK_EN :1;               /* Not used. XFER engine has a new function that provides a support to ISO EP within a long PCIe delayed system. The long delay can cause missing service interval while pending response has not all been returned. This bit enables engine to identify a MSI condition and store the context bit for a pending response so that we can process a MSI event when pending response received. '0': disable this function, '1': enable this function. */
        uint32_t ISO_0LEN_LPF_EN :1;             /* Enables a special internal state branch condition for periodic EP during its transfer ring process. If we have identified that the next TRB is a non DMAnable TRB such as LINK TRB, or Event data TRB, then this bit enables XFER engine to continue process the next TRB as if the ENT bit of the TRB is set. '0': disable, '1': enable. */
        uint32_t SET_ADDR_ERR_EN :1;             /* '0': Disable error reporting if a SETUP TRB contains the following: bRequest = SET_ADDRES, bmRequestType = (DTD) Host-to-device, Type = Standard, Recipient = Device. '1': Enable error reporting for this case. */
        uint32_t PHASE1_IMD_EN :1;               /* Enable a special branch condition of the XFER ring process state. This is to ensure that we have a DMA request issued to DMA engine during a PHASE1 process of the TTE. '0': disabled, '1': enabled */
        uint32_t NO_OP_AS_TD :1;                 /* This bit is modified to enable the NO_OP TRB as a TD when Missing Service Interval Error has encountered. This is only for PPT B0, LPT and CB. '0': disable, '1': enable. */
        uint32_t SHORT_ERR_4MSI_EN :1;           /* This bit is modified to enable a feature where we can control whether or not to report an event with completion code of Missed Service Error when a short packet response has been received not in the expected service interval. '0': Disable this function so that the xHC engine will report an event with completion code of Short packet indication and another event with MSE at the end of the TD, '1': Enables all completion event that supposedly is short to the MSE. */
        uint32_t DEADLOCK_DETECT_EN :1;          /* '0': Disable timeout of TRB error processing. '1': Enable timeout of a TRB processing in few critical states that possibly have a deadlock for unexpected reason. A vendor defined completion code is generated in the event of a timeout during TRB processing. */
        uint32_t DISABLE_ERDY_DROP :1;           /* '0': Drop ERDYs received when not in a flow control state. '1': Do not drop ERDYs received when not in a flow control state. Note: We typically drop unexpected ERDY */
        uint32_t CPL_DB_RANG_EN :1;              /* Setting this bit to '1' will force an internal doorbell ring on the EP that it has received a response. */
        uint32_t WRITE_ERDP_LO :1;               /* When ERDP register is updated by software, it is expected as an atomic function since this is a 64-bit register. It is expected, that the ERDP (64-bit register) is updated together when ERDP high 32 is written. We have this bit designed to ignore the atomic operation required from software for ERDP low 32 bits. When this bit is set to '1', it will update the ERDP low 32 bits when software issues a CPU write to the ERDP low 32 bits. '0': not ignore, '1': ignore atomic operation. */
        uint32_t DISABLE_IMD_4NODMA :1;          /* This is a special internal branch condition control in XFER engine which does the EP transfer ring process. When this bit is set, the XFER will not continue even if the next TRB is identified as a non DMA TRB. The engine will then wait for the next scheduled request for this EP. '0': Disable, '1': Enable the branch condition. */
        uint32_t TRB_ERR_RM_DB_EN :1;            /* This is a special internal branch condition control in XFER engine which does the EP transfer ring process. When this bit is set a retry condition identified by completion engine will cause XFER engine to stop what it is currently in progress and start over from IDLE state. '0': Disable, '1': Enable the branch condition. */
        uint32_t EP_HALT_2RETRY_EN :1;           /* This is a special internal condition enable for CPL engine which it enables all EP halt conditions detected to cause the proper actions in a response. '0': Disabled, '1': Enabled. Note: Only default condition of '1' is valid. */
        uint32_t ENABLE_NOOP_UPD :1;             /* This bit has been modified for its usage since PPT A0. It is used to allow NO-OP TRB to be treated in a same way as link TRB. In other words, it will update the internal context when it is fetched while the internal context cache TRB FIFO is empty. '0': Disable the function, '1': Enable the cache function. */
        uint32_t DISABLE_CPL_SST_PPIPE_ERR :1;   /* '0': Enable the error check, '1': Disable the error check for prime PIPE stream state. It will generate a transfer event with prime PIPE error completion code if an error is detected. */
        uint32_t DISABLE_CPL_SST_MDATA_ERR :1;   /* '0': Enable the error check. '1': Disable the error check for Data Move stream state. It will generate a transfer event with prime PIPE error completion code if an error is detected. */
        uint32_t USB2_NAK_AUTO_DETECT_REG_EN :1; /* '0': Disables a special function which detects NAK received and goes into a single packet pace mode so that we do not burst ahead. '1': Enables a special function which detects NAK received and goes into a single packet pace mode so that we do not burst ahead. */
        uint32_t TRB_PACE_EN :1;                 /* Must be set to '0'. */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_t;

/* Register XECP_HOST_CTRL_TRM_REG1 - Host Control Transfer Manager (TRM) register. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_OFFSET 0x180D0
/* Field IN_TD_PACE_ENABLE - '0': Disable TD pacing for IN endpoint. '1': Enable TD pacing for IN endpoints. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_IN_TD_PACE_ENABLE_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_IN_TD_PACE_ENABLE_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_IN_TD_PACE_ENABLE(v) (((v) << 0) & 0x1)
/* Field DISABLE_FC_4INRDY - '0': Obey the NPKT0 and EOB flow control. '1': Ignore received flow control for implied NRDY (e.g EOB or NPKT=0) for USB3 only */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_FC_4INRDY_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_FC_4INRDY_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_FC_4INRDY(v) (((v) << 0x1) & 0x2)
/* Field LINK_NOP_SUCESS_EN - '0': Process transaction errors due to CERR count reached or transaction timeout reported by the DMA engine. '1': Ignore transaction errors reported by the DMA engine. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_LINK_NOP_SUCESS_EN_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_LINK_NOP_SUCESS_EN_MASK 0x4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_LINK_NOP_SUCESS_EN(v) (((v) << 0x2) & 0x4)
/* Field DISABLE_STALL - '0': Process stalls reported by the DMA engine. '1': Ignore stall response received reported by the DMA engine. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_STALL_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_STALL_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_STALL(v) (((v) << 0x3) & 0x8)
/* Field XPORT_CRD_DISABLE - This bit is designed to allow XFER engine to do a transfer without checking against the available port credit. '0': Advertises accurate buffer credit information to the scheduler. '1': Advertises non-zero buffer credits to the scheduler (e.g. never backpressure back on buffer credit information) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_XPORT_CRD_DISABLE_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_XPORT_CRD_DISABLE_MASK 0x10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_XPORT_CRD_DISABLE(v) (((v) << 0x4) & 0x10)
/* Field CPL_PKT_CLR_MASK_EN - Enable a function, which clears a mask of an EP on any response of that EP. '0': Clear the scheduler mask normally, '1': Clear the scheduler mask on each received packet. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CPL_PKT_CLR_MASK_EN_SHIFT 5
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CPL_PKT_CLR_MASK_EN_MASK 0x20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CPL_PKT_CLR_MASK_EN(v) (((v) << 0x5) & 0x20)
/* Field EN_BB_PORT_DISABLE - '0': Babble errors will not disable the port. '1': Babble errors will disable the auto detect function This will allow engine to handle more than 4 TRBs per packet. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_EN_BB_PORT_DISABLE_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_EN_BB_PORT_DISABLE_MASK 0x40
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_EN_BB_PORT_DISABLE(v) (((v) << 0x6) & 0x40)
/* Field NPKT0_FC_DISABLE - '0': USB3 responses with NumPkts equal to 0 will be treated as a flow control condition. '1': USB3 responses with NumPkts equal to 0 will not be treated as a flow control condition. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_NPKT0_FC_DISABLE_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_NPKT0_FC_DISABLE_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_NPKT0_FC_DISABLE(v) (((v) << 0x7) & 0x80)
/* Field TRB_CACHE_INVALIDE_EN - '0': Disable internal TRB cache invalidation. '1': Enable internal TRB cache invalidation auto detect function. This will allow engine to handle more than 4 TRBs per packet. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_CACHE_INVALIDE_EN_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_CACHE_INVALIDE_EN_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_CACHE_INVALIDE_EN(v) (((v) << 0x8) & 0x100)
/* Field IN_NPKT_PACE_DISABLE - Setting this bit to '1' will force the transfer engine state machine to exit the CPL_WAIT state. This is designed to avoid unexpected deadlock in CPL_WAIT state. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_IN_NPKT_PACE_DISABLE_SHIFT 9
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_IN_NPKT_PACE_DISABLE_MASK 0x200
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_IN_NPKT_PACE_DISABLE(v) (((v) << 0x9) & 0x200)
/* Field FLUSH_2CLR_VALID_EN - This bit is modified to support PPTB0, LPT and CP for a feature that we will clear the single IN EP array based on ISO flush or short flush. '0': Indicate that we do not need to clear IN EP array based on flush conditions. '1': indicate that we do clear IN EP array based on flush conditions */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_FLUSH_2CLR_VALID_EN_SHIFT 10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_FLUSH_2CLR_VALID_EN_MASK 0x400
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_FLUSH_2CLR_VALID_EN(v) (((v) << 0xA) & 0x400)
/* Field CTRL_REG_CLR_BNDRY - Setting this bit to '1' will force the transfer engine to set the packet boundary flag. This flag is an important flag, which may cause a deadlock. This is a safety feature that we have plugged in. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CTRL_REG_CLR_BNDRY_SHIFT 11
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CTRL_REG_CLR_BNDRY_MASK 0x800
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CTRL_REG_CLR_BNDRY(v) (((v) << 0xB) & 0x800)
/* Field ENT_EN - '0': ENT bit is ignored. '1': ENT bit is processed. The transfer engine will service the next TRB. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ENT_EN_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ENT_EN_MASK 0x1000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ENT_EN(v) (((v) << 0xC) & 0x1000)
/* Field SINGLE_BURST_EN - '0': Bulk and interrupt endpoints use burst size defined by endpoint context. '1: Force the Bulk and Interrupt endpoints to use a burst size of 1. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SINGLE_BURST_EN_SHIFT 13
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SINGLE_BURST_EN_MASK 0x2000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SINGLE_BURST_EN(v) (((v) << 0xD) & 0x2000)
/* Field XFER_BLOCK_EN - Not used. XFER engine has a new function that provides a support to ISO EP within a long PCIe delayed system. The long delay can cause missing service interval while pending response has not all been returned. This bit enables engine to identify a MSI condition and store the context bit for a pending response so that we can process a MSI event when pending response received. '0': disable this function, '1': enable this function. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_XFER_BLOCK_EN_SHIFT 14
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_XFER_BLOCK_EN_MASK 0x4000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_XFER_BLOCK_EN(v) (((v) << 0xE) & 0x4000)
/* Field ISO_0LEN_LPF_EN - Enables a special internal state branch condition for periodic EP during its transfer ring process. If we have identified that the next TRB is a non DMAnable TRB such as LINK TRB, or Event data TRB, then this bit enables XFER engine to continue process the next TRB as if the ENT bit of the TRB is set. '0': disable, '1': enable. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ISO_0LEN_LPF_EN_SHIFT 15
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ISO_0LEN_LPF_EN_MASK 0x8000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ISO_0LEN_LPF_EN(v) (((v) << 0xF) & 0x8000)
/* Field SET_ADDR_ERR_EN - '0': Disable error reporting if a SETUP TRB contains the following: bRequest = SET_ADDRES, bmRequestType = (DTD) Host-to-device, Type = Standard, Recipient = Device. '1': Enable error reporting for this case. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SET_ADDR_ERR_EN_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SET_ADDR_ERR_EN_MASK 0x10000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SET_ADDR_ERR_EN(v) (((v) << 0x10) & 0x10000)
/* Field PHASE1_IMD_EN - Enable a special branch condition of the XFER ring process state. This is to ensure that we have a DMA request issued to DMA engine during a PHASE1 process of the TTE. '0': disabled, '1': enabled */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_PHASE1_IMD_EN_SHIFT 17
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_PHASE1_IMD_EN_MASK 0x20000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_PHASE1_IMD_EN(v) (((v) << 0x11) & 0x20000)
/* Field NO_OP_AS_TD - This bit is modified to enable the NO_OP TRB as a TD when Missing Service Interval Error has encountered. This is only for PPT B0, LPT and CB. '0': disable, '1': enable. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_NO_OP_AS_TD_SHIFT 18
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_NO_OP_AS_TD_MASK 0x40000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_NO_OP_AS_TD(v) (((v) << 0x12) & 0x40000)
/* Field SHORT_ERR_4MSI_EN - This bit is modified to enable a feature where we can control whether or not to report an event with completion code of Missed Service Error when a short packet response has been received not in the expected service interval. '0': Disable this function so that the xHC engine will report an event with completion code of Short packet indication and another event with MSE at the end of the TD, '1': Enables all completion event that supposedly is short to the MSE. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SHORT_ERR_4MSI_EN_SHIFT 19
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SHORT_ERR_4MSI_EN_MASK 0x80000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_SHORT_ERR_4MSI_EN(v) (((v) << 0x13) & 0x80000)
/* Field DEADLOCK_DETECT_EN - '0': Disable timeout of TRB error processing. '1': Enable timeout of a TRB processing in few critical states that possibly have a deadlock for unexpected reason. A vendor defined completion code is generated in the event of a timeout during TRB processing. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DEADLOCK_DETECT_EN_SHIFT 20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DEADLOCK_DETECT_EN_MASK 0x100000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DEADLOCK_DETECT_EN(v) (((v) << 0x14) & 0x100000)
/* Field DISABLE_ERDY_DROP - '0': Drop ERDYs received when not in a flow control state. '1': Do not drop ERDYs received when not in a flow control state. Note: We typically drop unexpected ERDY */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_ERDY_DROP_SHIFT 21
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_ERDY_DROP_MASK 0x200000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_ERDY_DROP(v) (((v) << 0x15) & 0x200000)
/* Field CPL_DB_RANG_EN - Setting this bit to '1' will force an internal doorbell ring on the EP that it has received a response. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CPL_DB_RANG_EN_SHIFT 22
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CPL_DB_RANG_EN_MASK 0x400000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_CPL_DB_RANG_EN(v) (((v) << 0x16) & 0x400000)
/* Field WRITE_ERDP_LO - When ERDP register is updated by software, it is expected as an atomic function since this is a 64-bit register. It is expected, that the ERDP (64-bit register) is updated together when ERDP high 32 is written. We have this bit designed to ignore the atomic operation required from software for ERDP low 32 bits. When this bit is set to '1', it will update the ERDP low 32 bits when software issues a CPU write to the ERDP low 32 bits. '0': not ignore, '1': ignore atomic operation. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_WRITE_ERDP_LO_SHIFT 23
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_WRITE_ERDP_LO_MASK 0x800000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_WRITE_ERDP_LO(v) (((v) << 0x17) & 0x800000)
/* Field DISABLE_IMD_4NODMA - This is a special internal branch condition control in XFER engine which does the EP transfer ring process. When this bit is set, the XFER will not continue even if the next TRB is identified as a non DMA TRB. The engine will then wait for the next scheduled request for this EP. '0': Disable, '1': Enable the branch condition. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_IMD_4NODMA_SHIFT 24
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_IMD_4NODMA_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_IMD_4NODMA(v) (((v) << 0x18) & 0x1000000)
/* Field TRB_ERR_RM_DB_EN - This is a special internal branch condition control in XFER engine which does the EP transfer ring process. When this bit is set a retry condition identified by completion engine will cause XFER engine to stop what it is currently in progress and start over from IDLE state. '0': Disable, '1': Enable the branch condition. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_ERR_RM_DB_EN_SHIFT 25
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_ERR_RM_DB_EN_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_ERR_RM_DB_EN(v) (((v) << 0x19) & 0x2000000)
/* Field EP_HALT_2RETRY_EN - This is a special internal condition enable for CPL engine which it enables all EP halt conditions detected to cause the proper actions in a response. '0': Disabled, '1': Enabled. Note: Only default condition of '1' is valid. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_EP_HALT_2RETRY_EN_SHIFT 26
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_EP_HALT_2RETRY_EN_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_EP_HALT_2RETRY_EN(v) (((v) << 0x1A) & 0x4000000)
/* Field ENABLE_NOOP_UPD - This bit has been modified for its usage since PPT A0. It is used to allow NO-OP TRB to be treated in a same way as link TRB. In other words, it will update the internal context when it is fetched while the internal context cache TRB FIFO is empty. '0': Disable the function, '1': Enable the cache function. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ENABLE_NOOP_UPD_SHIFT 27
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ENABLE_NOOP_UPD_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_ENABLE_NOOP_UPD(v) (((v) << 0x1B) & 0x8000000)
/* Field DISABLE_CPL_SST_PPIPE_ERR - '0': Enable the error check, '1': Disable the error check for prime PIPE stream state. It will generate a transfer event with prime PIPE error completion code if an error is detected. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_CPL_SST_PPIPE_ERR_SHIFT 28
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_CPL_SST_PPIPE_ERR_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_CPL_SST_PPIPE_ERR(v) (((v) << 0x1C) & 0x10000000)
/* Field DISABLE_CPL_SST_MDATA_ERR - '0': Enable the error check. '1': Disable the error check for Data Move stream state. It will generate a transfer event with prime PIPE error completion code if an error is detected. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_CPL_SST_MDATA_ERR_SHIFT 29
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_CPL_SST_MDATA_ERR_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_DISABLE_CPL_SST_MDATA_ERR(v) (((v) << 0x1D) & 0x20000000)
/* Field USB2_NAK_AUTO_DETECT_REG_EN - '0': Disables a special function which detects NAK received and goes into a single packet pace mode so that we do not burst ahead. '1': Enables a special function which detects NAK received and goes into a single packet pace mode so that we do not burst ahead. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_USB2_NAK_AUTO_DETECT_REG_EN_SHIFT 30
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_USB2_NAK_AUTO_DETECT_REG_EN_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_USB2_NAK_AUTO_DETECT_REG_EN(v) (((v) << 0x1E) & 0x40000000)
/* Field TRB_PACE_EN - Must be set to '0'. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_PACE_EN_SHIFT 31
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_PACE_EN_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_TRB_PACE_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1 - Host Control Scheduler register. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t POLL_DELAY_DIS :1;              /* Host Control Scheduler: Disable poll delay function */
        uint32_t TRM_ACTIVE_IN_EP_VALID :1;      /* Host Control Scheduler: Disable TRM active IN EP valid check function */
        uint32_t SCH_2       :1;                 /* Host Control Scheduler: Disable TTE IN overlap */
        uint32_t TTE_ENABLE_INTROUT_OVERLAP_STOP :1; /* Host Control Scheduler: tte_enable_introut_overlap_stop */
        uint32_t SCH_SORT_PATTERN :2;            /* Host Control Scheduler: Search priority. Possible values: '00': Sort by Interval then ISO over interrupt, '01','10','11': Experimental sort algorithms. */
        uint32_t SCH_ASYNC_OUT_MAX_PERF :1;      /* Host Control Scheduler: Enable maximal out performance (may cause unfairness or short term starvation). */
        uint32_t SCH_ASYNC_1PKT_PERF :1;         /* Host Control Scheduler: Disable burst limit '1' for async in presence of another port periodic packets. */
        uint32_t SCRATCH_PAD_EN :1;              /* Command Manager: Enables scratch pad function */
        uint32_t MAXEP       :2;                 /* Command Manager: Allow dynamically setting different max EP allowed. The max EP supported scales with the scratch pad size. This allows driver to allocate small memory sizes if it needed. 0: 32 EPs, 1: 16 EPs, 2: 8 EPs, 3: 4 EPs. */
        uint32_t CACHE_SIZE_CTRL :2;             /* Command Manager: Context cache enable */
        uint32_t TTE_0       :1;                 /* TTE: Disable interrupt complete split limit to 3 micro frames */
        uint32_t TTE_1       :1;                 /* TTE: Disable checking of missed microframes */
        uint32_t TTE_2       :1;                 /* TTE: Disable split error request to TRM on unserved interrupt-INs */
        uint32_t TTE_3       :2;                 /* TTE: Reserved */
        uint32_t DISABLE_GL_HUB_ISO_FIX :1;      /* TTE: disable_gl_hub_iso_fix */
        uint32_t DISABLE_GL_HUB_INT_FIX :1;      /* TTE: disable_gl_hub_int_fix */
        uint32_t TTE_4       :1;                 /* TTE: Reserved */
        uint32_t SCH_STOP_SERVE_NC :1;           /* Host Control Scheduler: Enable Stop serving packets to disabled port */
        uint32_t SCH_CCLK_PRDC_DONE_CHECK :2;    /* Host Control Scheduler: sch_cclk_prdc_done_check */
        uint32_t SCH_ASYNC_PRDC_CC_DIS :1;       /* Host Control Scheduler: sch_async_prdc_cc_dis */
        uint32_t SCH_TT_OVERLAP_ALL_INS :1;      /* Host Control Scheduler: sch_tt_overlap_all_ins */
        uint32_t SCH_ASYNC_1PKT_SPLIT_PREF :1;   /* Host Control Scheduler: sch_async_1pkt_split_pref */
        uint32_t SCH_BLOCK_PENDING_EN :1;        /* Host Control Scheduler: sch_block_pending_en */
        uint32_t SCH_LIMIT_PRDC :4;              /* Host Control Scheduler: sch_limit_prdc */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_t;

/* Register XECP_HOST_CTRL_SCH_REG1 - Host Control Scheduler register. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_OFFSET 0x180D4
/* Field POLL_DELAY_DIS - Host Control Scheduler: Disable poll delay function */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_POLL_DELAY_DIS_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_POLL_DELAY_DIS_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_POLL_DELAY_DIS(v) (((v) << 0) & 0x1)
/* Field TRM_ACTIVE_IN_EP_VALID - Host Control Scheduler: Disable TRM active IN EP valid check function */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TRM_ACTIVE_IN_EP_VALID_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TRM_ACTIVE_IN_EP_VALID_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TRM_ACTIVE_IN_EP_VALID(v) (((v) << 0x1) & 0x2)
/* Field SCH_2 - Host Control Scheduler: Disable TTE IN overlap */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_2_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_2_MASK 0x4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_2(v) (((v) << 0x2) & 0x4)
/* Field TTE_ENABLE_INTROUT_OVERLAP_STOP - Host Control Scheduler: tte_enable_introut_overlap_stop */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_ENABLE_INTROUT_OVERLAP_STOP_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_ENABLE_INTROUT_OVERLAP_STOP_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_ENABLE_INTROUT_OVERLAP_STOP(v) (((v) << 0x3) & 0x8)
/* Field SCH_SORT_PATTERN - Host Control Scheduler: Search priority. Possible values: '00': Sort by Interval then ISO over interrupt, '01','10','11': Experimental sort algorithms. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_SORT_PATTERN_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_SORT_PATTERN_MASK 0x30
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_SORT_PATTERN(v) (((v) << 0x4) & 0x30)
/* Field SCH_ASYNC_OUT_MAX_PERF - Host Control Scheduler: Enable maximal out performance (may cause unfairness or short term starvation). */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_OUT_MAX_PERF_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_OUT_MAX_PERF_MASK 0x40
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_OUT_MAX_PERF(v) (((v) << 0x6) & 0x40)
/* Field SCH_ASYNC_1PKT_PERF - Host Control Scheduler: Disable burst limit '1' for async in presence of another port periodic packets. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_1PKT_PERF_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_1PKT_PERF_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_1PKT_PERF(v) (((v) << 0x7) & 0x80)
/* Field SCRATCH_PAD_EN - Command Manager: Enables scratch pad function */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCRATCH_PAD_EN_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCRATCH_PAD_EN_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCRATCH_PAD_EN(v) (((v) << 0x8) & 0x100)
/* Field MAXEP - Command Manager: Allow dynamically setting different max EP allowed. The max EP supported scales with the scratch pad size. This allows driver to allocate small memory sizes if it needed. 0: 32 EPs, 1: 16 EPs, 2: 8 EPs, 3: 4 EPs. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_MAXEP_SHIFT 9
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_MAXEP_MASK 0x600
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_MAXEP(v) (((v) << 0x9) & 0x600)
/* Field CACHE_SIZE_CTRL - Command Manager: Context cache enable */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_CACHE_SIZE_CTRL_SHIFT 11
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_CACHE_SIZE_CTRL_MASK 0x1800
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_CACHE_SIZE_CTRL(v) (((v) << 0xB) & 0x1800)
/* Field TTE_0 - TTE: Disable interrupt complete split limit to 3 micro frames */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_0_SHIFT 13
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_0_MASK 0x2000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_0(v) (((v) << 0xD) & 0x2000)
/* Field TTE_1 - TTE: Disable checking of missed microframes */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_1_SHIFT 14
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_1_MASK 0x4000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_1(v) (((v) << 0xE) & 0x4000)
/* Field TTE_2 - TTE: Disable split error request to TRM on unserved interrupt-INs */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_2_SHIFT 15
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_2_MASK 0x8000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_2(v) (((v) << 0xF) & 0x8000)
/* Field TTE_3 - TTE: Reserved */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_3_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_3_MASK 0x30000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_3(v) (((v) << 0x10) & 0x30000)
/* Field DISABLE_GL_HUB_ISO_FIX - TTE: disable_gl_hub_iso_fix */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_DISABLE_GL_HUB_ISO_FIX_SHIFT 18
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_DISABLE_GL_HUB_ISO_FIX_MASK 0x40000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_DISABLE_GL_HUB_ISO_FIX(v) (((v) << 0x12) & 0x40000)
/* Field DISABLE_GL_HUB_INT_FIX - TTE: disable_gl_hub_int_fix */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_DISABLE_GL_HUB_INT_FIX_SHIFT 19
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_DISABLE_GL_HUB_INT_FIX_MASK 0x80000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_DISABLE_GL_HUB_INT_FIX(v) (((v) << 0x13) & 0x80000)
/* Field TTE_4 - TTE: Reserved */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_4_SHIFT 20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_4_MASK 0x100000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_TTE_4(v) (((v) << 0x14) & 0x100000)
/* Field SCH_STOP_SERVE_NC - Host Control Scheduler: Enable Stop serving packets to disabled port */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_STOP_SERVE_NC_SHIFT 21
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_STOP_SERVE_NC_MASK 0x200000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_STOP_SERVE_NC(v) (((v) << 0x15) & 0x200000)
/* Field SCH_CCLK_PRDC_DONE_CHECK - Host Control Scheduler: sch_cclk_prdc_done_check */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_CCLK_PRDC_DONE_CHECK_SHIFT 22
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_CCLK_PRDC_DONE_CHECK_MASK 0xC00000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_CCLK_PRDC_DONE_CHECK(v) (((v) << 0x16) & 0xC00000)
/* Field SCH_ASYNC_PRDC_CC_DIS - Host Control Scheduler: sch_async_prdc_cc_dis */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_PRDC_CC_DIS_SHIFT 24
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_PRDC_CC_DIS_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_PRDC_CC_DIS(v) (((v) << 0x18) & 0x1000000)
/* Field SCH_TT_OVERLAP_ALL_INS - Host Control Scheduler: sch_tt_overlap_all_ins */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_TT_OVERLAP_ALL_INS_SHIFT 25
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_TT_OVERLAP_ALL_INS_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_TT_OVERLAP_ALL_INS(v) (((v) << 0x19) & 0x2000000)
/* Field SCH_ASYNC_1PKT_SPLIT_PREF - Host Control Scheduler: sch_async_1pkt_split_pref */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_1PKT_SPLIT_PREF_SHIFT 26
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_1PKT_SPLIT_PREF_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_ASYNC_1PKT_SPLIT_PREF(v) (((v) << 0x1A) & 0x4000000)
/* Field SCH_BLOCK_PENDING_EN - Host Control Scheduler: sch_block_pending_en */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_BLOCK_PENDING_EN_SHIFT 27
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_BLOCK_PENDING_EN_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_BLOCK_PENDING_EN(v) (((v) << 0x1B) & 0x8000000)
/* Field SCH_LIMIT_PRDC - Host Control Scheduler: sch_limit_prdc */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_LIMIT_PRDC_SHIFT 28
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_LIMIT_PRDC_MASK 0xF0000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_SCH_LIMIT_PRDC(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG - Host Control ODMA. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_union_t {
    uint32_t R;
    struct {
        uint32_t EP_TRANS_TIMEOUT_EN :1;         /* '0': Enables the EP Transaction Timeout Function, '1': Disables the EP Transaction Timeout Function */
        uint32_t EP_TRANS_TIMEOUT_LEN :2;        /* Controls the duration of the EP Transaction Timeout (depends on the settings of EP Transaction Base Timer (bit[12])). Possible values: 0: 64us ([12]=0) or 8ms ([12]=1) EP Transaction Timeout, 1: 32us ([12]=0) or 4ms ([12]=1) EP Transaction Timeout, 2: 16us ([12]=0) or 2ms ([12]=1) EP Transaction Timeout, 3: EP Transaction Timer is DISABLED. */
        uint32_t ODMA_RD_TO_IDLE :1;             /* Setting this field generates a pulse that returns the Out DMA Read Finite State Machine into the IDLE state. */
        uint32_t ODMA_RESP_TO_IDLE :1;           /* Setting this field generates a pulse that returns the Out DMA Response Finite State Machine into the IDLE state. */
        uint32_t ODMA_COMPLETION_TO_IDLE :1;     /* Setting this field generates a pulse that returns the Out DMA Completion Finite State Machine into the IDLE state */
        uint32_t ODMA_SET_ADDR_TO_IDLE :1;       /* Setting this field generates a pulse that returns the Out DMA Set Address Finite State Machine into the IDLE state */
        uint32_t ODMA_7      :1;                 /* Setting this field generates a pulse that implicitly returns all of the Out DMA ACK credits on all ports */
        uint32_t CLEAR_CNTX_LOCKS :1;            /* Setting this field generates a pulse that clears the ownership of the context semaphore that is shared between the Out DMA Response and Completion Finite State Machines */
        uint32_t ODMA_9      :1;                 /* Setting this field prohibits the Set Address Finite State Machine from being flow controlled when an ACK with NPKT=0 is received in response to the SETUP DP initiated during SET_ADDRESS */
        uint32_t EP_TIMER_TICK :1;               /* Setting this field will disable the EP Transaction Timer function when the Command Manager is performing a Stop Endpoint Command or when the LTSSM is in Recovery */
        uint32_t ODMA_11     :1;                 /* Setting this field will prohibit the Set Address Finite State Machine Credit Handshake with TTE Logic */
        uint32_t EP_BASE_TIMER :1;               /* '0': Employs a 1us EP Transaction Base Timer. Enables a Timeout range from 16us to 64us '1': Employs a 125us EP Transaction Base Timer. Enables a Timeout range from 2ms to 8ms */
        uint32_t ACK_CRD_CHECK_EN :1;            /* '0': Disable the ACK credit check function '1': Enable the ACK credit check function that ODMA provides */
        uint32_t SPEED_UP_TIMEOUT :1;            /* '0': Disable the speed up transaction timeout function. '1': Enable the transaction timeout speed up based on no-connect detected on a particular port */
        uint32_t _unused15   :17;                /* Reserved field, RW */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_t;

/* Register XECP_HOST_CTRL_ODMA_REG - Host Control ODMA. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_OFFSET 0x180D8
/* Field EP_TRANS_TIMEOUT_EN - '0': Enables the EP Transaction Timeout Function, '1': Disables the EP Transaction Timeout Function */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TRANS_TIMEOUT_EN_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TRANS_TIMEOUT_EN_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TRANS_TIMEOUT_EN(v) (((v) << 0) & 0x1)
/* Field EP_TRANS_TIMEOUT_LEN - Controls the duration of the EP Transaction Timeout (depends on the settings of EP Transaction Base Timer (bit[12])). Possible values: 0: 64us ([12]=0) or 8ms ([12]=1) EP Transaction Timeout, 1: 32us ([12]=0) or 4ms ([12]=1) EP Transaction Timeout, 2: 16us ([12]=0) or 2ms ([12]=1) EP Transaction Timeout, 3: EP Transaction Timer is DISABLED. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TRANS_TIMEOUT_LEN_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TRANS_TIMEOUT_LEN_MASK 0x6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TRANS_TIMEOUT_LEN(v) (((v) << 0x1) & 0x6)
/* Field ODMA_RD_TO_IDLE - Setting this field generates a pulse that returns the Out DMA Read Finite State Machine into the IDLE state. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_RD_TO_IDLE_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_RD_TO_IDLE_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_RD_TO_IDLE(v) (((v) << 0x3) & 0x8)
/* Field ODMA_RESP_TO_IDLE - Setting this field generates a pulse that returns the Out DMA Response Finite State Machine into the IDLE state. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_RESP_TO_IDLE_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_RESP_TO_IDLE_MASK 0x10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_RESP_TO_IDLE(v) (((v) << 0x4) & 0x10)
/* Field ODMA_COMPLETION_TO_IDLE - Setting this field generates a pulse that returns the Out DMA Completion Finite State Machine into the IDLE state */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_COMPLETION_TO_IDLE_SHIFT 5
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_COMPLETION_TO_IDLE_MASK 0x20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_COMPLETION_TO_IDLE(v) (((v) << 0x5) & 0x20)
/* Field ODMA_SET_ADDR_TO_IDLE - Setting this field generates a pulse that returns the Out DMA Set Address Finite State Machine into the IDLE state */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_SET_ADDR_TO_IDLE_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_SET_ADDR_TO_IDLE_MASK 0x40
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_SET_ADDR_TO_IDLE(v) (((v) << 0x6) & 0x40)
/* Field ODMA_7 - Setting this field generates a pulse that implicitly returns all of the Out DMA ACK credits on all ports */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_7_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_7_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_7(v) (((v) << 0x7) & 0x80)
/* Field CLEAR_CNTX_LOCKS - Setting this field generates a pulse that clears the ownership of the context semaphore that is shared between the Out DMA Response and Completion Finite State Machines */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_CLEAR_CNTX_LOCKS_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_CLEAR_CNTX_LOCKS_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_CLEAR_CNTX_LOCKS(v) (((v) << 0x8) & 0x100)
/* Field ODMA_9 - Setting this field prohibits the Set Address Finite State Machine from being flow controlled when an ACK with NPKT=0 is received in response to the SETUP DP initiated during SET_ADDRESS */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_9_SHIFT 9
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_9_MASK 0x200
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_9(v) (((v) << 0x9) & 0x200)
/* Field EP_TIMER_TICK - Setting this field will disable the EP Transaction Timer function when the Command Manager is performing a Stop Endpoint Command or when the LTSSM is in Recovery */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TIMER_TICK_SHIFT 10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TIMER_TICK_MASK 0x400
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_TIMER_TICK(v) (((v) << 0xA) & 0x400)
/* Field ODMA_11 - Setting this field will prohibit the Set Address Finite State Machine Credit Handshake with TTE Logic */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_11_SHIFT 11
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_11_MASK 0x800
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ODMA_11(v) (((v) << 0xB) & 0x800)
/* Field EP_BASE_TIMER - '0': Employs a 1us EP Transaction Base Timer. Enables a Timeout range from 16us to 64us '1': Employs a 125us EP Transaction Base Timer. Enables a Timeout range from 2ms to 8ms */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_BASE_TIMER_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_BASE_TIMER_MASK 0x1000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_EP_BASE_TIMER(v) (((v) << 0xC) & 0x1000)
/* Field ACK_CRD_CHECK_EN - '0': Disable the ACK credit check function '1': Enable the ACK credit check function that ODMA provides */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ACK_CRD_CHECK_EN_SHIFT 13
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ACK_CRD_CHECK_EN_MASK 0x2000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_ACK_CRD_CHECK_EN(v) (((v) << 0xD) & 0x2000)
/* Field SPEED_UP_TIMEOUT - '0': Disable the speed up transaction timeout function. '1': Enable the transaction timeout speed up based on no-connect detected on a particular port */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_SPEED_UP_TIMEOUT_SHIFT 14
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_SPEED_UP_TIMEOUT_MASK 0x4000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_SPEED_UP_TIMEOUT(v) (((v) << 0xE) & 0x4000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG - Host Control IDMA. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_union_t {
    uint32_t R;
    struct {
        uint32_t EP_TRANS_TIMEOUT_EN :1;         /* '0': Enables the EP Transaction Timeout Function, '1': Disables the EP Transaction Timeout Function. */
        uint32_t EP_TIMER_TICK :2;               /* '00': 1us/125us/1ms/4ms EP Timer Tick '01': 2us/250us/2ms/8ms EP Timer Tick '10': 4us/500us/4ms/16ms EP Timer Tick '11': Disabled EP Timer Tick */
        uint32_t IDMA_PTR_BUF_ROOM_RESTORE_PULSE :1; /* Setting this field generates a pulse that clears all the Read and Write Pointers associated with the various DMA Address FIFOs causing them to appear empty */
        uint32_t RESTORE_RDP_CREDITS_PULSE :1;   /* Setting this field generates a pulse that implicitly returns all of the IN DMA Data Packet credits on all ports. */
        uint32_t ACK_PST_CLR_PULSE :1;           /* Setting this field generates a pulse that returns the IN DMA Acknowledge Finite State Machine into the IDLE state. */
        uint32_t DM_PST_CLR_PULSE :1;            /* Setting this field generates a pulse that returns the IN DMA Data Mover Finite State Machine into the IDLE state */
        uint32_t CLEAR_CNTX_LOCKS :1;            /* Setting this field generates a pulse that clears the ownership of the context semaphore that is shared between the IN DMA Acknowledge and Data Mover Finite State Machines */
        uint32_t COMPLIANCE_ISO_ENABLE :1;       /* Setting this field enables the Compliance Isochronous mode of operation. It bounds the upper limit on the NPKT field for all ISO Acknowledgments generated from the Host to the value of 2. */
        uint32_t IDMA_9      :1;                 /* Setting this field will disable the EP Transaction Timer function when the Command Manager is performing a Stop Endpoint Command or when the LTSSM is in Recovery */
        uint32_t TIMER_TICK0 :1;                 /* '0': Employs a 1us EP Transaction Base Timer. Enables a Timeout range from 16us to 64us. '1': Employs a 125us EP Transaction Base Timer. Enables a Timeout range from 2ms to 8ms. */
        uint32_t SEQ_NUM_ADJ_ON_NRDY :1;         /* '0': Enable sequence number adjustment on NRDY received for USB3 when we are expecting a response. '1': Enable sequence number adjustment on any NRDY received for USB3. */
        uint32_t SPEED_UP_TIMEOUT :1;            /* '0': Disable the speed up transaction timeout function. '1': Enable the transaction timeout speed up based on no-connect detected on a particular port */
        uint32_t IDMA_13     :1;                 /* Disable dropping all deferred packets on ISO Endpoints. */
        uint32_t IDMA_14     :1;                 /* Disable drop spurious DP when EP is in flow conrtrol. */
        uint32_t IDMA_15     :1;                 /* Disable drop spurious DP when i_npkt==0 */
        uint32_t IDMA_PTR_BUF_ROOM_SET :1;       /* '0': Default IDMA Pointer Buffer Room to 8 : Requires strobe of host_ctrl_idma_reg[3](idma_ptr_buf_room_restore_pulse) to take effect, '1': Default IDMA Pointer Buffer Room to 4 : Requires strobe of host_ctrl_idma_reg[3](idma_ptr_buf_room_restore_pulse) to take effect. */
        uint32_t IDMA_17     :1;                 /* '0': All ACK ACKs are put in the Periodic Header FIFO in XPPE, '1': Only Periodic ACK ACKs are put in the Periodic Header FIFO in XPPE. */
        uint32_t IDMA_ADDR_FIFO_FLUSH_BIT :1;    /* Flush IDMA Address FIFO strobe. */
        uint32_t IDMA_23_19  :5;                 /* Port Number of Address FIFO to Flush. */
        uint32_t IDMA_24     :1;                 /* '0': Flush an Async Address FIFO, '1': Flush a Periodic Address FIFO. */
        uint32_t IDMA_25     :1;                 /* Flush TTE Address FIFO */
        uint32_t TIMER_TICK1 :1;                 /* Allows to select the EP Timer Tick to be either the 1us timer tick or the 125us timer tick or the 1ms timer tick or the 4ms timer tick based on the setting of this bit and bit 10 of this register. The encoding is as follows (bit{[26],[10]}): '00' : 1us EP Timer Tick, '01' : 125us EP Timer Tick, '10' : 1ms EP Timer Tick, '11' : 4ms EP Timer Tick. */
        uint32_t IDMA_27     :1;                 /* '0': Drop Deferred Stream Reject TPs. (default) (Bug #5434), '1': Allow Deferred Stream Reject TPs. */
        uint32_t IDMA_28     :1;                 /* '0': Drop Deferred Ack/Ack TPs. (default) (Bug #5481), '1': Allow Deferred Ack/Ack TPs. */
        uint32_t DB_EVENT_GEN_EN :1;             /* Used in Doorbell Manager. '0': Do not generate an event. '1': Enable an event generated with completion code TRB_CMPL_ENDPOINT_NOT_ENABLED_ERR when a doorbell ring on an EP, which has not running or stop state. */
        uint32_t EVENT_PRIORITY :1;              /* Used in Event Manager. '0': CPL Engine priority over XFER Manager, '1': XFER Manager priority over CPL Engine. */
        uint32_t EVENT_FIFO_DIS :1;              /* Used in Event Manager. '0': Enable single ring optimization, '1': Disable single ring optimization. */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_t;

/* Register XECP_HOST_CTRL_IDMA_REG - Host Control IDMA. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_OFFSET 0x180DC
/* Field EP_TRANS_TIMEOUT_EN - '0': Enables the EP Transaction Timeout Function, '1': Disables the EP Transaction Timeout Function. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EP_TRANS_TIMEOUT_EN_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EP_TRANS_TIMEOUT_EN_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EP_TRANS_TIMEOUT_EN(v) (((v) << 0) & 0x1)
/* Field EP_TIMER_TICK - '00': 1us/125us/1ms/4ms EP Timer Tick '01': 2us/250us/2ms/8ms EP Timer Tick '10': 4us/500us/4ms/16ms EP Timer Tick '11': Disabled EP Timer Tick */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EP_TIMER_TICK_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EP_TIMER_TICK_MASK 0x6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EP_TIMER_TICK(v) (((v) << 0x1) & 0x6)
/* Field IDMA_PTR_BUF_ROOM_RESTORE_PULSE - Setting this field generates a pulse that clears all the Read and Write Pointers associated with the various DMA Address FIFOs causing them to appear empty */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_PTR_BUF_ROOM_RESTORE_PULSE_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_PTR_BUF_ROOM_RESTORE_PULSE_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_PTR_BUF_ROOM_RESTORE_PULSE(v) (((v) << 0x3) & 0x8)
/* Field RESTORE_RDP_CREDITS_PULSE - Setting this field generates a pulse that implicitly returns all of the IN DMA Data Packet credits on all ports. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_RESTORE_RDP_CREDITS_PULSE_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_RESTORE_RDP_CREDITS_PULSE_MASK 0x10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_RESTORE_RDP_CREDITS_PULSE(v) (((v) << 0x4) & 0x10)
/* Field ACK_PST_CLR_PULSE - Setting this field generates a pulse that returns the IN DMA Acknowledge Finite State Machine into the IDLE state. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_ACK_PST_CLR_PULSE_SHIFT 5
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_ACK_PST_CLR_PULSE_MASK 0x20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_ACK_PST_CLR_PULSE(v) (((v) << 0x5) & 0x20)
/* Field DM_PST_CLR_PULSE - Setting this field generates a pulse that returns the IN DMA Data Mover Finite State Machine into the IDLE state */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_DM_PST_CLR_PULSE_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_DM_PST_CLR_PULSE_MASK 0x40
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_DM_PST_CLR_PULSE(v) (((v) << 0x6) & 0x40)
/* Field CLEAR_CNTX_LOCKS - Setting this field generates a pulse that clears the ownership of the context semaphore that is shared between the IN DMA Acknowledge and Data Mover Finite State Machines */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_CLEAR_CNTX_LOCKS_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_CLEAR_CNTX_LOCKS_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_CLEAR_CNTX_LOCKS(v) (((v) << 0x7) & 0x80)
/* Field COMPLIANCE_ISO_ENABLE - Setting this field enables the Compliance Isochronous mode of operation. It bounds the upper limit on the NPKT field for all ISO Acknowledgments generated from the Host to the value of 2. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_COMPLIANCE_ISO_ENABLE_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_COMPLIANCE_ISO_ENABLE_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_COMPLIANCE_ISO_ENABLE(v) (((v) << 0x8) & 0x100)
/* Field IDMA_9 - Setting this field will disable the EP Transaction Timer function when the Command Manager is performing a Stop Endpoint Command or when the LTSSM is in Recovery */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_9_SHIFT 9
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_9_MASK 0x200
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_9(v) (((v) << 0x9) & 0x200)
/* Field TIMER_TICK0 - '0': Employs a 1us EP Transaction Base Timer. Enables a Timeout range from 16us to 64us. '1': Employs a 125us EP Transaction Base Timer. Enables a Timeout range from 2ms to 8ms. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_TIMER_TICK0_SHIFT 10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_TIMER_TICK0_MASK 0x400
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_TIMER_TICK0(v) (((v) << 0xA) & 0x400)
/* Field SEQ_NUM_ADJ_ON_NRDY - '0': Enable sequence number adjustment on NRDY received for USB3 when we are expecting a response. '1': Enable sequence number adjustment on any NRDY received for USB3. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_SEQ_NUM_ADJ_ON_NRDY_SHIFT 11
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_SEQ_NUM_ADJ_ON_NRDY_MASK 0x800
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_SEQ_NUM_ADJ_ON_NRDY(v) (((v) << 0xB) & 0x800)
/* Field SPEED_UP_TIMEOUT - '0': Disable the speed up transaction timeout function. '1': Enable the transaction timeout speed up based on no-connect detected on a particular port */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_SPEED_UP_TIMEOUT_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_SPEED_UP_TIMEOUT_MASK 0x1000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_SPEED_UP_TIMEOUT(v) (((v) << 0xC) & 0x1000)
/* Field IDMA_13 - Disable dropping all deferred packets on ISO Endpoints. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_13_SHIFT 13
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_13_MASK 0x2000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_13(v) (((v) << 0xD) & 0x2000)
/* Field IDMA_14 - Disable drop spurious DP when EP is in flow conrtrol. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_14_SHIFT 14
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_14_MASK 0x4000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_14(v) (((v) << 0xE) & 0x4000)
/* Field IDMA_15 - Disable drop spurious DP when i_npkt==0 */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_15_SHIFT 15
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_15_MASK 0x8000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_15(v) (((v) << 0xF) & 0x8000)
/* Field IDMA_PTR_BUF_ROOM_SET - '0': Default IDMA Pointer Buffer Room to 8 : Requires strobe of host_ctrl_idma_reg[3](idma_ptr_buf_room_restore_pulse) to take effect, '1': Default IDMA Pointer Buffer Room to 4 : Requires strobe of host_ctrl_idma_reg[3](idma_ptr_buf_room_restore_pulse) to take effect. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_PTR_BUF_ROOM_SET_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_PTR_BUF_ROOM_SET_MASK 0x10000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_PTR_BUF_ROOM_SET(v) (((v) << 0x10) & 0x10000)
/* Field IDMA_17 - '0': All ACK ACKs are put in the Periodic Header FIFO in XPPE, '1': Only Periodic ACK ACKs are put in the Periodic Header FIFO in XPPE. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_17_SHIFT 17
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_17_MASK 0x20000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_17(v) (((v) << 0x11) & 0x20000)
/* Field IDMA_ADDR_FIFO_FLUSH_BIT - Flush IDMA Address FIFO strobe. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_ADDR_FIFO_FLUSH_BIT_SHIFT 18
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_ADDR_FIFO_FLUSH_BIT_MASK 0x40000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_ADDR_FIFO_FLUSH_BIT(v) (((v) << 0x12) & 0x40000)
/* Field IDMA_23_19 - Port Number of Address FIFO to Flush. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_23_19_SHIFT 19
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_23_19_MASK 0xF80000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_23_19(v) (((v) << 0x13) & 0xF80000)
/* Field IDMA_24 - '0': Flush an Async Address FIFO, '1': Flush a Periodic Address FIFO. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_24_SHIFT 24
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_24_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_24(v) (((v) << 0x18) & 0x1000000)
/* Field IDMA_25 - Flush TTE Address FIFO */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_25_SHIFT 25
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_25_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_25(v) (((v) << 0x19) & 0x2000000)
/* Field TIMER_TICK1 - Allows to select the EP Timer Tick to be either the 1us timer tick or the 125us timer tick or the 1ms timer tick or the 4ms timer tick based on the setting of this bit and bit 10 of this register. The encoding is as follows (bit{[26],[10]}): '00' : 1us EP Timer Tick, '01' : 125us EP Timer Tick, '10' : 1ms EP Timer Tick, '11' : 4ms EP Timer Tick. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_TIMER_TICK1_SHIFT 26
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_TIMER_TICK1_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_TIMER_TICK1(v) (((v) << 0x1A) & 0x4000000)
/* Field IDMA_27 - '0': Drop Deferred Stream Reject TPs. (default) (Bug #5434), '1': Allow Deferred Stream Reject TPs. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_27_SHIFT 27
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_27_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_27(v) (((v) << 0x1B) & 0x8000000)
/* Field IDMA_28 - '0': Drop Deferred Ack/Ack TPs. (default) (Bug #5481), '1': Allow Deferred Ack/Ack TPs. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_28_SHIFT 28
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_28_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_IDMA_28(v) (((v) << 0x1C) & 0x10000000)
/* Field DB_EVENT_GEN_EN - Used in Doorbell Manager. '0': Do not generate an event. '1': Enable an event generated with completion code TRB_CMPL_ENDPOINT_NOT_ENABLED_ERR when a doorbell ring on an EP, which has not running or stop state. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_DB_EVENT_GEN_EN_SHIFT 29
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_DB_EVENT_GEN_EN_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_DB_EVENT_GEN_EN(v) (((v) << 0x1D) & 0x20000000)
/* Field EVENT_PRIORITY - Used in Event Manager. '0': CPL Engine priority over XFER Manager, '1': XFER Manager priority over CPL Engine. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EVENT_PRIORITY_SHIFT 30
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EVENT_PRIORITY_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EVENT_PRIORITY(v) (((v) << 0x1E) & 0x40000000)
/* Field EVENT_FIFO_DIS - Used in Event Manager. '0': Enable single ring optimization, '1': Disable single ring optimization. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EVENT_FIFO_DIS_SHIFT 31
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EVENT_FIFO_DIS_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_EVENT_FIFO_DIS(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL - Global Port Control. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_union_t {
    uint32_t R;
    struct {
        uint32_t RES1        :4;                 /* Reserved to 1 (reserved for PP) */
        uint32_t TEST_BUS_SEL_CTRL_BITS :5;
        uint32_t _unused9    :2;                 /* Reserved field, RW */
        uint32_t PCIE_GASKET :1;                 /* Reserved to '1'. Note: An internal register bit for PCIe gasket. It is only valid for value of '1' */
        uint32_t ENABLE_ITP_XMT :1;              /* Bit(s) of this field are designated to individually control each USB3 port to enable ITP transmission. 0: Do not Transmit any ITP. 1: Transmit ITP */
        uint32_t HBUF_WATER_MARK_REG_CCLK :4;    /* This 4-bit register is designed as a water mark for when to turn on link FC credit return disable. This is used in xhc_prot_rppe.v for receive buffer management. We have 8 header credit in per port receive buffer. When buffer received enough packets, it will need to disable the link credit FC return in order to balance the processing delay within DMA engine. 0: Always enable link credit FC return, 1-8: Water mark value. */
        uint32_t OVERFLOW_SYS_ERR_EN :1;         /* '0': Disable error generation. '1': Enable to generate a host system error when receive buffer overflow on any ports. */
        uint32_t RD_WR_ADDR_CONFLICT_EN :1;      /* rd_wr_addr_conflict_en */
        uint32_t LOCK_HEADER_DATA_EN :1;         /* lock_header_data_en */
        uint32_t _unused20   :12;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_t;

/* Register XECP_HOST_CTRL_PORT_CTRL - Global Port Control. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_OFFSET 0x180E0
/* Field RES1 - Reserved to 1 (reserved for PP) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_RES1_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_RES1_MASK 0xF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_RES1(v) (((v) << 0) & 0xF)
/* Field TEST_BUS_SEL_CTRL_BITS -  */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_TEST_BUS_SEL_CTRL_BITS_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_TEST_BUS_SEL_CTRL_BITS_MASK 0x1F0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_TEST_BUS_SEL_CTRL_BITS(v) (((v) << 0x4) & 0x1F0)
/* Field PCIE_GASKET - Reserved to '1'. Note: An internal register bit for PCIe gasket. It is only valid for value of '1' */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_PCIE_GASKET_SHIFT 11
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_PCIE_GASKET_MASK 0x800
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_PCIE_GASKET(v) (((v) << 0xB) & 0x800)
/* Field ENABLE_ITP_XMT - Bit(s) of this field are designated to individually control each USB3 port to enable ITP transmission. 0: Do not Transmit any ITP. 1: Transmit ITP */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_ENABLE_ITP_XMT_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_ENABLE_ITP_XMT_MASK 0x1000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_ENABLE_ITP_XMT(v) (((v) << 0xC) & 0x1000)
/* Field HBUF_WATER_MARK_REG_CCLK - This 4-bit register is designed as a water mark for when to turn on link FC credit return disable. This is used in xhc_prot_rppe.v for receive buffer management. We have 8 header credit in per port receive buffer. When buffer received enough packets, it will need to disable the link credit FC return in order to balance the processing delay within DMA engine. 0: Always enable link credit FC return, 1-8: Water mark value. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_HBUF_WATER_MARK_REG_CCLK_SHIFT 13
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_HBUF_WATER_MARK_REG_CCLK_MASK 0x1E000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_HBUF_WATER_MARK_REG_CCLK(v) (((v) << 0xD) & 0x1E000)
/* Field OVERFLOW_SYS_ERR_EN - '0': Disable error generation. '1': Enable to generate a host system error when receive buffer overflow on any ports. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_OVERFLOW_SYS_ERR_EN_SHIFT 17
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_OVERFLOW_SYS_ERR_EN_MASK 0x20000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_OVERFLOW_SYS_ERR_EN(v) (((v) << 0x11) & 0x20000)
/* Field RD_WR_ADDR_CONFLICT_EN - rd_wr_addr_conflict_en */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_RD_WR_ADDR_CONFLICT_EN_SHIFT 18
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_RD_WR_ADDR_CONFLICT_EN_MASK 0x40000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_RD_WR_ADDR_CONFLICT_EN(v) (((v) << 0x12) & 0x40000)
/* Field LOCK_HEADER_DATA_EN - lock_header_data_en */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_LOCK_HEADER_DATA_EN_SHIFT 19
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_LOCK_HEADER_DATA_EN_MASK 0x80000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_LOCK_HEADER_DATA_EN(v) (((v) << 0x13) & 0x80000)

/* IMX_USB3_USBSS_XECP_AUX_CTRL_REG - AUX Reset Control. */
typedef union IMX_USB3_USBSS_XECP_AUX_CTRL_REG_union_t {
    uint32_t R;
    struct {
        uint32_t FORCE_FD_RST :2;                /* Writing to this field a value of 2'b11 will cause a fundamental reset. The only valid write values are 2'b11 or 2'b00 */
        uint32_t IGNORE_PERST_4FD_RST :1;        /* When fundamental reset is asserted during AUX power up, if this bit is set, then we will ignore PERST# such that purely wait for timeout to deassert fundamental reset. */
        uint32_t IGNORE_PERST_4MAIN_PWRUP :1;    /* When set to '1' ignore waiting for PERST# deassertion during main power show down. */
        uint32_t PM_CTRL_MAIN_RST_EN :1;         /* When set to '1' allow main power off condition to trigger a main power domain reset */
        uint32_t IGNORE_MAIN_PWRUP_RST :1;       /* When set to '1', it enables the reset isolation function that we have added during HC reset or Per port reset. */
        uint32_t IGNORE_WARM_RST_2USB_PHY :1;    /* When set to '1' ignore warm reset to the USB PHY */
        uint32_t IGNORE_HC_WARM_RST_2USB_PHY :1; /* When set to '1' ignore HC reset to the USB PHY */
        uint32_t IGNORE_MAIN_PWRUP_2PCIE_PHY :1; /* When set to '1' ignore main power up reset to PCIe PHY */
        uint32_t IGNORE_MAIN_PWRUP_2PCORE :1;    /* When set to '1' ignore main power up reset to PCIe core */
        uint32_t IGNORE_MAIN_PWRUP_4U2PORT :1;   /* When set to '1' ignore main power up reset to USB2 port logic */
        uint32_t IGNORE_MAIN_PWRUP_4U3PORT :1;   /* When set to '1' ignore main power up reset to USB3 port logic */
        uint32_t IGNORE_WARM_RST_4U3PORT :1;     /* When set to '1' ignore warm reset to the USB3 port logic */
        uint32_t IGNORE_HOT_RST_4U3PORT :1;      /* When set to '1' ignore hot reset to the USB3 port logic */
        uint32_t PCIE_LINKDOWN_RST_EN :1;        /* When set to '1' allow PCIe link down to cause a reset to the rest of the core as the HC reset would. */
        uint32_t IGNORE_WARM_RST_4UPHY_PON :1;   /* When set to '1' ignore warm reset of the portSC to the USB PHY power on reset */
        uint32_t IGNORE_MAC_PHY_PIPE_RST :1;     /* When set to '1' ignore the LTSSM of USB link state transition caused reset to USB PHY PIPE reset */
        uint32_t IGNORE_HC_RST_2PCIE_PHY :1;     /* When set to '1' ignore HC reset to the PCIe PHY PIPE reset */
        uint32_t EEPROM_LOAD_ON_MAIN :1;         /* When set to '1' enable EEPROM reload on every main power-up */
        uint32_t IGNORE_MAIN_PWRUP_HC_2PCORE :1; /* When set to '1' enable the HC liked reset caused by PCIe link down condition detected. If PCIe link down detected, a link down reset will always be fired to PCIe core. */
        uint32_t IGNORE_HC_WARM_RST_4UPHY_PON :1; /* When set to '1' ignore HC reset to the USB PHY power-on reset */
        uint32_t IGNORE_HCRESET_4USB2 :1;        /* When set to '1' ignore HC reset to reset the USB2 Port logic */
        uint32_t COLD_RST_N_PULSE :1;            /* When set to '1' allow software to fire a cold reset to USB port logic */
        uint32_t IGNORE_MAIN_PWRUP_2USB_PHY :1;  /* When set to '1' ignore main powerup reset to USB PHY PIPE reset */
        uint32_t IGNORE_LINKDOWN_RST_4UPORT :1;  /* When set to '1' ignore a port reset that is caused by a USB port link went down. */
        uint32_t FAST_SIM_RST :1;                /* This bit enables a speed up function or AUX reset at startup. Normally we wait for 20ms after AUX power level has reached. When in speed up mode, we wait only around 3-4us. '0: Disabled, '1: Enabled for fast sim. */
        uint32_t IGNORE_PERST_EN :1;             /* This bit disables the PERST# to cause an internal reset. '0: enable '1: disable the PERST# */
        uint32_t PERST_4MAIN_EN :1;              /* This bit enables the internal reset control module to immediately start a reset assertion process when PERST# is deasserted without waiting for PCIe device is out of D3 state. This is for warm reboot only. The PERST# can still have impact as a reset if the xHC is in D3 and allow PERST# as a powerup reset bit set. '0: disabled '1: enabled PERST# as an immediately reset */
        uint32_t PERST_2PWDOWN_EN :1;            /* This bit enables the AUX PM control module to assert mac_phy_powerdown state to P1 as soon as PERST# is deasserted. If disabled, then the AUX PM control state will follow its nature cause to determine the power down states for PIPE. '0': disabled, '1': enabled. */
        uint32_t PCIE_PHY_RST_SEL :1;            /* This bit enables AUX reset control module to assert the pcie_phy_reset either from PIPE reset or from Aux power up reset only. The pcie_phy_reset is an internal signal for CB PHY only. '0': Aux PowerUp Reset, '1': PIPE PHY reset */
        uint32_t PERST_FILTER_DIS :1;            /* reserved. perst_filter_dis */
        uint32_t _unused31   :1;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_AUX_CTRL_REG_t;

/* Register XECP_AUX_CTRL_REG - AUX Reset Control. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_OFFSET 0x18100
/* Field FORCE_FD_RST - Writing to this field a value of 2'b11 will cause a fundamental reset. The only valid write values are 2'b11 or 2'b00 */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_FORCE_FD_RST_SHIFT 0
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_FORCE_FD_RST_MASK 0x3
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_FORCE_FD_RST(v) (((v) << 0) & 0x3)
/* Field IGNORE_PERST_4FD_RST - When fundamental reset is asserted during AUX power up, if this bit is set, then we will ignore PERST# such that purely wait for timeout to deassert fundamental reset. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_4FD_RST_SHIFT 2
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_4FD_RST_MASK 0x4
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_4FD_RST(v) (((v) << 0x2) & 0x4)
/* Field IGNORE_PERST_4MAIN_PWRUP - When set to '1' ignore waiting for PERST# deassertion during main power show down. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_4MAIN_PWRUP_SHIFT 3
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_4MAIN_PWRUP_MASK 0x8
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_4MAIN_PWRUP(v) (((v) << 0x3) & 0x8)
/* Field PM_CTRL_MAIN_RST_EN - When set to '1' allow main power off condition to trigger a main power domain reset */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PM_CTRL_MAIN_RST_EN_SHIFT 4
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PM_CTRL_MAIN_RST_EN_MASK 0x10
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PM_CTRL_MAIN_RST_EN(v) (((v) << 0x4) & 0x10)
/* Field IGNORE_MAIN_PWRUP_RST - When set to '1', it enables the reset isolation function that we have added during HC reset or Per port reset. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_RST_SHIFT 5
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_RST_MASK 0x20
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_RST(v) (((v) << 0x5) & 0x20)
/* Field IGNORE_WARM_RST_2USB_PHY - When set to '1' ignore warm reset to the USB PHY */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_2USB_PHY_SHIFT 6
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_2USB_PHY_MASK 0x40
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_2USB_PHY(v) (((v) << 0x6) & 0x40)
/* Field IGNORE_HC_WARM_RST_2USB_PHY - When set to '1' ignore HC reset to the USB PHY */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_WARM_RST_2USB_PHY_SHIFT 7
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_WARM_RST_2USB_PHY_MASK 0x80
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_WARM_RST_2USB_PHY(v) (((v) << 0x7) & 0x80)
/* Field IGNORE_MAIN_PWRUP_2PCIE_PHY - When set to '1' ignore main power up reset to PCIe PHY */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2PCIE_PHY_SHIFT 8
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2PCIE_PHY_MASK 0x100
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2PCIE_PHY(v) (((v) << 0x8) & 0x100)
/* Field IGNORE_MAIN_PWRUP_2PCORE - When set to '1' ignore main power up reset to PCIe core */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2PCORE_SHIFT 9
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2PCORE_MASK 0x200
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2PCORE(v) (((v) << 0x9) & 0x200)
/* Field IGNORE_MAIN_PWRUP_4U2PORT - When set to '1' ignore main power up reset to USB2 port logic */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_4U2PORT_SHIFT 10
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_4U2PORT_MASK 0x400
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_4U2PORT(v) (((v) << 0xA) & 0x400)
/* Field IGNORE_MAIN_PWRUP_4U3PORT - When set to '1' ignore main power up reset to USB3 port logic */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_4U3PORT_SHIFT 11
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_4U3PORT_MASK 0x800
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_4U3PORT(v) (((v) << 0xB) & 0x800)
/* Field IGNORE_WARM_RST_4U3PORT - When set to '1' ignore warm reset to the USB3 port logic */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_4U3PORT_SHIFT 12
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_4U3PORT_MASK 0x1000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_4U3PORT(v) (((v) << 0xC) & 0x1000)
/* Field IGNORE_HOT_RST_4U3PORT - When set to '1' ignore hot reset to the USB3 port logic */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HOT_RST_4U3PORT_SHIFT 13
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HOT_RST_4U3PORT_MASK 0x2000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HOT_RST_4U3PORT(v) (((v) << 0xD) & 0x2000)
/* Field PCIE_LINKDOWN_RST_EN - When set to '1' allow PCIe link down to cause a reset to the rest of the core as the HC reset would. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PCIE_LINKDOWN_RST_EN_SHIFT 14
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PCIE_LINKDOWN_RST_EN_MASK 0x4000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PCIE_LINKDOWN_RST_EN(v) (((v) << 0xE) & 0x4000)
/* Field IGNORE_WARM_RST_4UPHY_PON - When set to '1' ignore warm reset of the portSC to the USB PHY power on reset */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_4UPHY_PON_SHIFT 15
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_4UPHY_PON_MASK 0x8000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_WARM_RST_4UPHY_PON(v) (((v) << 0xF) & 0x8000)
/* Field IGNORE_MAC_PHY_PIPE_RST - When set to '1' ignore the LTSSM of USB link state transition caused reset to USB PHY PIPE reset */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAC_PHY_PIPE_RST_SHIFT 16
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAC_PHY_PIPE_RST_MASK 0x10000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAC_PHY_PIPE_RST(v) (((v) << 0x10) & 0x10000)
/* Field IGNORE_HC_RST_2PCIE_PHY - When set to '1' ignore HC reset to the PCIe PHY PIPE reset */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_RST_2PCIE_PHY_SHIFT 17
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_RST_2PCIE_PHY_MASK 0x20000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_RST_2PCIE_PHY(v) (((v) << 0x11) & 0x20000)
/* Field EEPROM_LOAD_ON_MAIN - When set to '1' enable EEPROM reload on every main power-up */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_EEPROM_LOAD_ON_MAIN_SHIFT 18
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_EEPROM_LOAD_ON_MAIN_MASK 0x40000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_EEPROM_LOAD_ON_MAIN(v) (((v) << 0x12) & 0x40000)
/* Field IGNORE_MAIN_PWRUP_HC_2PCORE - When set to '1' enable the HC liked reset caused by PCIe link down condition detected. If PCIe link down detected, a link down reset will always be fired to PCIe core. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_HC_2PCORE_SHIFT 19
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_HC_2PCORE_MASK 0x80000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_HC_2PCORE(v) (((v) << 0x13) & 0x80000)
/* Field IGNORE_HC_WARM_RST_4UPHY_PON - When set to '1' ignore HC reset to the USB PHY power-on reset */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_WARM_RST_4UPHY_PON_SHIFT 20
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_WARM_RST_4UPHY_PON_MASK 0x100000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HC_WARM_RST_4UPHY_PON(v) (((v) << 0x14) & 0x100000)
/* Field IGNORE_HCRESET_4USB2 - When set to '1' ignore HC reset to reset the USB2 Port logic */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HCRESET_4USB2_SHIFT 21
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HCRESET_4USB2_MASK 0x200000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_HCRESET_4USB2(v) (((v) << 0x15) & 0x200000)
/* Field COLD_RST_N_PULSE - When set to '1' allow software to fire a cold reset to USB port logic */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_COLD_RST_N_PULSE_SHIFT 22
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_COLD_RST_N_PULSE_MASK 0x400000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_COLD_RST_N_PULSE(v) (((v) << 0x16) & 0x400000)
/* Field IGNORE_MAIN_PWRUP_2USB_PHY - When set to '1' ignore main powerup reset to USB PHY PIPE reset */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2USB_PHY_SHIFT 23
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2USB_PHY_MASK 0x800000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_MAIN_PWRUP_2USB_PHY(v) (((v) << 0x17) & 0x800000)
/* Field IGNORE_LINKDOWN_RST_4UPORT - When set to '1' ignore a port reset that is caused by a USB port link went down. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_LINKDOWN_RST_4UPORT_SHIFT 24
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_LINKDOWN_RST_4UPORT_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_LINKDOWN_RST_4UPORT(v) (((v) << 0x18) & 0x1000000)
/* Field FAST_SIM_RST - This bit enables a speed up function or AUX reset at startup. Normally we wait for 20ms after AUX power level has reached. When in speed up mode, we wait only around 3-4us. '0: Disabled, '1: Enabled for fast sim. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_FAST_SIM_RST_SHIFT 25
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_FAST_SIM_RST_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_FAST_SIM_RST(v) (((v) << 0x19) & 0x2000000)
/* Field IGNORE_PERST_EN - This bit disables the PERST# to cause an internal reset. '0: enable '1: disable the PERST# */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_EN_SHIFT 26
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_EN_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_IGNORE_PERST_EN(v) (((v) << 0x1A) & 0x4000000)
/* Field PERST_4MAIN_EN - This bit enables the internal reset control module to immediately start a reset assertion process when PERST# is deasserted without waiting for PCIe device is out of D3 state. This is for warm reboot only. The PERST# can still have impact as a reset if the xHC is in D3 and allow PERST# as a powerup reset bit set. '0: disabled '1: enabled PERST# as an immediately reset */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_4MAIN_EN_SHIFT 27
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_4MAIN_EN_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_4MAIN_EN(v) (((v) << 0x1B) & 0x8000000)
/* Field PERST_2PWDOWN_EN - This bit enables the AUX PM control module to assert mac_phy_powerdown state to P1 as soon as PERST# is deasserted. If disabled, then the AUX PM control state will follow its nature cause to determine the power down states for PIPE. '0': disabled, '1': enabled. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_2PWDOWN_EN_SHIFT 28
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_2PWDOWN_EN_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_2PWDOWN_EN(v) (((v) << 0x1C) & 0x10000000)
/* Field PCIE_PHY_RST_SEL - This bit enables AUX reset control module to assert the pcie_phy_reset either from PIPE reset or from Aux power up reset only. The pcie_phy_reset is an internal signal for CB PHY only. '0': Aux PowerUp Reset, '1': PIPE PHY reset */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PCIE_PHY_RST_SEL_SHIFT 29
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PCIE_PHY_RST_SEL_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PCIE_PHY_RST_SEL(v) (((v) << 0x1D) & 0x20000000)
/* Field PERST_FILTER_DIS - reserved. perst_filter_dis */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_FILTER_DIS_SHIFT 30
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_FILTER_DIS_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG_PERST_FILTER_DIS(v) (((v) << 0x1E) & 0x40000000)

/* IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG - Super Speed Bandwidth Overload. */
typedef union IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_union_t {
    uint32_t R;
    struct {
        uint32_t SS_BW_CALC  :12;                /* BW calculation: Overhead per packet for SS BW calculations. See white paper. */
        uint32_t MAX_TT_BW   :12;                /* Max. TT BW allowed. See white paper */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_t;

/* Register XECP_HOST_BW_OV_SS_REG - Super Speed Bandwidth Overload. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_OFFSET 0x18104
/* Field SS_BW_CALC - BW calculation: Overhead per packet for SS BW calculations. See white paper. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_SS_BW_CALC_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_SS_BW_CALC_MASK 0xFFF
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_SS_BW_CALC(v) (((v) << 0) & 0xFFF)
/* Field MAX_TT_BW - Max. TT BW allowed. See white paper */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_MAX_TT_BW_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_MAX_TT_BW_MASK 0xFFF000
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_MAX_TT_BW(v) (((v) << 0xC) & 0xFFF000)

/* IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG - High Speed TT Bandwidth Overload. */
typedef union IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_union_t {
    uint32_t R;
    struct {
        uint32_t BW_OV_HS_TT :12;                /* BW calculation: Overhead per packet for HS BW calculations. See white paper. */
        uint32_t BW_OV_HS    :12;                /* BW calculation: Overhead per packet for HS-TT BW calculations. See white paper. */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_t;

/* Register XECP_HOST_BW_OV_HS_REG - High Speed TT Bandwidth Overload. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_OFFSET 0x18108
/* Field BW_OV_HS_TT - BW calculation: Overhead per packet for HS BW calculations. See white paper. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_BW_OV_HS_TT_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_BW_OV_HS_TT_MASK 0xFFF
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_BW_OV_HS_TT(v) (((v) << 0) & 0xFFF)
/* Field BW_OV_HS - BW calculation: Overhead per packet for HS-TT BW calculations. See white paper. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_BW_OV_HS_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_BW_OV_HS_MASK 0xFFF000
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_BW_OV_HS(v) (((v) << 0xC) & 0xFFF000)

/* IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG - Bandwidth Overload Full and Low Speed. */
typedef union IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_union_t {
    uint32_t R;
    struct {
        uint32_t LS_BW_CALC  :12;                /* BW calculation: Overhead per packet for LS BW calculations. See white paper. */
        uint32_t FS_BW_CALC  :12;                /* BW calculation: Overhead per packet for FS BW calculations. See white paper. */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_t;

/* Register XECP_HOST_BW_OV_FS_LS_REG - Bandwidth Overload Full and Low Speed. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_OFFSET 0x1810C
/* Field LS_BW_CALC - BW calculation: Overhead per packet for LS BW calculations. See white paper. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_LS_BW_CALC_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_LS_BW_CALC_MASK 0xFFF
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_LS_BW_CALC(v) (((v) << 0) & 0xFFF)
/* Field FS_BW_CALC - BW calculation: Overhead per packet for FS BW calculations. See white paper. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_FS_BW_CALC_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_FS_BW_CALC_MASK 0xFFF000
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_FS_BW_CALC(v) (((v) << 0xC) & 0xFFF000)

/* IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG - System Bandwidth Overload. */
typedef union IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_union_t {
    uint32_t R;
    struct {
        uint32_t SYS_BW_CALC :12;                /* BW calculation: Overhead per packet for System BW calculations. See white paper. */
        uint32_t BW_OV_SYS_TT :12;               /* BW calculation: Overhead per TT packet for System BW calculations. See white paper. */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_t;

/* Register XECP_HOST_BW_OV_SYS_REG - System Bandwidth Overload. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_OFFSET 0x18110
/* Field SYS_BW_CALC - BW calculation: Overhead per packet for System BW calculations. See white paper. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_SYS_BW_CALC_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_SYS_BW_CALC_MASK 0xFFF
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_SYS_BW_CALC(v) (((v) << 0) & 0xFFF)
/* Field BW_OV_SYS_TT - BW calculation: Overhead per TT packet for System BW calculations. See white paper. */
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_BW_OV_SYS_TT_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_BW_OV_SYS_TT_MASK 0xFFF000
#define IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_BW_OV_SYS_TT(v) (((v) << 0xC) & 0xFFF000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG - Scheduler Async Delay. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_union_t {
    uint32_t R;
    struct {
        uint32_t LS_CTRL_DELAY_DEF :3;           /* Low-Speed Control Delay Default (0=125us,1=250us,2=500us,3=1ms,) */
        uint32_t LS_CTRL_DELAY_EN :1;            /* Low-Speed Control Delay Enable */
        uint32_t FS_CTRL_DELAY_DEF :3;           /* Full-Speed Control Default (0=125us,1=250us,2=500us,3=1ms,) */
        uint32_t FS_CTRL_DELAY_EN :1;            /* Full-Speed Control Delay Enable */
        uint32_t HS_CTRL_DELAY_DEF :3;           /* High-Speed Control Delay Default (0=125us,1=250us,2=500us,3=1ms,) */
        uint32_t HS_CTRL_DELAY_EN :1;            /* High-Speed Control Delay Enable */
        uint32_t FS_BULK_DELAY_DEF :3;           /* Full-Speed Bulk Delay Default (0=125us,1=250us,2=500us,3=1ms,) */
        uint32_t FS_BULK_DELAY_EN :1;            /* Full-Speed Bulk Delay Enable */
        uint32_t HS_BULK_DELAY_DEF :3;           /* High-Speed Bulk Delay Default (0=125us,1=250us,2=500us,3=1ms,) */
        uint32_t HS_BULK_DELAY_EN :1;            /* High-Speed Bulk Delay Enable */
        uint32_t _unused20   :12;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_t;

/* Register XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG - Scheduler Async Delay. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_OFFSET 0x18114
/* Field LS_CTRL_DELAY_DEF - Low-Speed Control Delay Default (0=125us,1=250us,2=500us,3=1ms,) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_LS_CTRL_DELAY_DEF_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_LS_CTRL_DELAY_DEF_MASK 0x7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_LS_CTRL_DELAY_DEF(v) (((v) << 0) & 0x7)
/* Field LS_CTRL_DELAY_EN - Low-Speed Control Delay Enable */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_LS_CTRL_DELAY_EN_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_LS_CTRL_DELAY_EN_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_LS_CTRL_DELAY_EN(v) (((v) << 0x3) & 0x8)
/* Field FS_CTRL_DELAY_DEF - Full-Speed Control Default (0=125us,1=250us,2=500us,3=1ms,) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_CTRL_DELAY_DEF_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_CTRL_DELAY_DEF_MASK 0x70
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_CTRL_DELAY_DEF(v) (((v) << 0x4) & 0x70)
/* Field FS_CTRL_DELAY_EN - Full-Speed Control Delay Enable */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_CTRL_DELAY_EN_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_CTRL_DELAY_EN_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_CTRL_DELAY_EN(v) (((v) << 0x7) & 0x80)
/* Field HS_CTRL_DELAY_DEF - High-Speed Control Delay Default (0=125us,1=250us,2=500us,3=1ms,) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_CTRL_DELAY_DEF_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_CTRL_DELAY_DEF_MASK 0x700
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_CTRL_DELAY_DEF(v) (((v) << 0x8) & 0x700)
/* Field HS_CTRL_DELAY_EN - High-Speed Control Delay Enable */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_CTRL_DELAY_EN_SHIFT 11
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_CTRL_DELAY_EN_MASK 0x800
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_CTRL_DELAY_EN(v) (((v) << 0xB) & 0x800)
/* Field FS_BULK_DELAY_DEF - Full-Speed Bulk Delay Default (0=125us,1=250us,2=500us,3=1ms,) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_BULK_DELAY_DEF_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_BULK_DELAY_DEF_MASK 0x7000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_BULK_DELAY_DEF(v) (((v) << 0xC) & 0x7000)
/* Field FS_BULK_DELAY_EN - Full-Speed Bulk Delay Enable */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_BULK_DELAY_EN_SHIFT 15
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_BULK_DELAY_EN_MASK 0x8000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_FS_BULK_DELAY_EN(v) (((v) << 0xF) & 0x8000)
/* Field HS_BULK_DELAY_DEF - High-Speed Bulk Delay Default (0=125us,1=250us,2=500us,3=1ms,) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_BULK_DELAY_DEF_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_BULK_DELAY_DEF_MASK 0x70000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_BULK_DELAY_DEF(v) (((v) << 0x10) & 0x70000)
/* Field HS_BULK_DELAY_EN - High-Speed Bulk Delay Enable */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_BULK_DELAY_EN_SHIFT 19
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_BULK_DELAY_EN_MASK 0x80000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_HS_BULK_DELAY_EN(v) (((v) << 0x13) & 0x80000)

/* IMX_USB3_USBSS_XECP_UPORTS_PON_RST_REG - AUX Power PHY Reset. */
typedef union IMX_USB3_USBSS_XECP_UPORTS_PON_RST_REG_union_t {
    uint32_t R;
    struct {
        uint32_t USB_PHY_PORT_NUM :4;            /* Indicates the port number of the USB PHY */
        uint32_t _unused4    :28;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_UPORTS_PON_RST_REG_t;

/* Register XECP_UPORTS_PON_RST_REG - AUX Power PHY Reset. */
#define IMX_USB3_USBSS_XECP_UPORTS_PON_RST_REG_OFFSET 0x18118
/* Field USB_PHY_PORT_NUM - Indicates the port number of the USB PHY */
#define IMX_USB3_USBSS_XECP_UPORTS_PON_RST_REG_USB_PHY_PORT_NUM_SHIFT 0
#define IMX_USB3_USBSS_XECP_UPORTS_PON_RST_REG_USB_PHY_PORT_NUM_MASK 0xF
#define IMX_USB3_USBSS_XECP_UPORTS_PON_RST_REG_USB_PHY_PORT_NUM(v) (((v) << 0) & 0xF)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3 - Host Control Transfer Manager (TRM) register. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_union_t {
    uint32_t R;
    struct {
        uint32_t CFG_EN_CACHE :1;                /* '0': Disable cache control, '1': Enable cache control. */
        uint32_t CFG_EN_LOOKAHEAD :1;            /* '0': Disable cache control lookahead, '1': Enable cache control lookahead. */
        uint32_t CFG_EN_HIT_INVALID :1;          /* '0': Disable cache control hit invalid with invalid CS, '1': Enable cache control hit invalid with invalid CS. */
        uint32_t CFG_CACHE_DEBUG :1;             /* cfg_cache_debug. Available when TRB_CACHE_DEBUG_EN is defined */
        uint32_t CFG_EN_LOOK_POS :2;             /* Enable cache control trigger position lookahead. */
        uint32_t CFG_EN_DEFER_BC :1;             /* '0': Disable cache control to defer misses on bulk/control EPs. '1': Enable cache control to defer misses on bulk/control EPs. */
        uint32_t CFG_EN_MISS_DOUBLE :1;          /* '0': Do not enable cache control to double fetch on miss. '1': Enable cache control to double fetch on miss. */
        uint32_t CPL_EXTRA_DB_RANG_EN :1;        /* cpl_extra_db_rang_en */
        uint32_t _unused9    :7;                 /* Reserved field, RW */
        uint32_t _unused16   :16;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_t;

/* Register XECP_HOST_CTRL_TRM_REG3 - Host Control Transfer Manager (TRM) register. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_OFFSET 0x1811C
/* Field CFG_EN_CACHE - '0': Disable cache control, '1': Enable cache control. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_CACHE_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_CACHE_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_CACHE(v) (((v) << 0) & 0x1)
/* Field CFG_EN_LOOKAHEAD - '0': Disable cache control lookahead, '1': Enable cache control lookahead. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_LOOKAHEAD_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_LOOKAHEAD_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_LOOKAHEAD(v) (((v) << 0x1) & 0x2)
/* Field CFG_EN_HIT_INVALID - '0': Disable cache control hit invalid with invalid CS, '1': Enable cache control hit invalid with invalid CS. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_HIT_INVALID_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_HIT_INVALID_MASK 0x4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_HIT_INVALID(v) (((v) << 0x2) & 0x4)
/* Field CFG_CACHE_DEBUG - cfg_cache_debug. Available when TRB_CACHE_DEBUG_EN is defined */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_CACHE_DEBUG_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_CACHE_DEBUG_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_CACHE_DEBUG(v) (((v) << 0x3) & 0x8)
/* Field CFG_EN_LOOK_POS - Enable cache control trigger position lookahead. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_LOOK_POS_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_LOOK_POS_MASK 0x30
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_LOOK_POS(v) (((v) << 0x4) & 0x30)
/* Field CFG_EN_DEFER_BC - '0': Disable cache control to defer misses on bulk/control EPs. '1': Enable cache control to defer misses on bulk/control EPs. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_DEFER_BC_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_DEFER_BC_MASK 0x40
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_DEFER_BC(v) (((v) << 0x6) & 0x40)
/* Field CFG_EN_MISS_DOUBLE - '0': Do not enable cache control to double fetch on miss. '1': Enable cache control to double fetch on miss. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_MISS_DOUBLE_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_MISS_DOUBLE_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CFG_EN_MISS_DOUBLE(v) (((v) << 0x7) & 0x80)
/* Field CPL_EXTRA_DB_RANG_EN - cpl_extra_db_rang_en */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CPL_EXTRA_DB_RANG_EN_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CPL_EXTRA_DB_RANG_EN_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_CPL_EXTRA_DB_RANG_EN(v) (((v) << 0x8) & 0x100)

/* IMX_USB3_USBSS_XECP_AUX_CTRL_REG1 - AUX Power Management Control 1. */
typedef union IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t FORCE_PM_STATE :1;              /* When set to '1' force PM state to go to the state indicated in field pm_state (bits [4:1]). This bit is the force PM state register, it is a pulse only (read by software will always give '0') */
        uint32_t PM_STATE    :4;                 /* Forced power management state can be set here. States encoding: PM_ACTIVE : 4'h0; REQ_CLK_SWITCH_2AUX : 4'h1; DRIVE_PHY_2P2 : 4'h2; WAIT_4WAKE : 4'h3; WAIT_4PERST_DSRT : 4'h4; RATE_CHANGE_2FAST : 4'h5; REQ_CLK_SWITCH_2PCLK : 4'h6; PM_EXIT : 4'h7; WAIT_4PCLK : 4'h8; DRIVE_PHY_STATUS : 4'h9; PM_IDLE : 4'hA; PWRUP_REQ_CLK_SWITCH_2PCLK : 4'hB; RATE_CHANGE_2SLOW : 4'hC; WAIT_4LTSSM_WAIT_DONE : 4'hD; WAIT_4CLK_GATE : 4'hE; IN_P2_TIMEOUT : 4'hF; Those bits have also another functionality: [1]: always_wake_n_en, [2]: timeout_16ms_en, [3]: always_force_clk_sw_en, ![4]: rc_p2_exit_en */
        uint32_t ENABLE_P2_ENTER :1;             /* When set to '1' enables the remote wake function by allowing P2 clock/switching and P2 entering */
        uint32_t P2_OVERWRITE_P1_EN :1;          /* When set to '1' enable P2 overwrite P1 when PCIe core has indicated the transition from P0 to P1. This is to enable entering the even lower power state. */
        uint32_t IGNORE_AUX_PME_EN :1;           /* When set to '1' ignore the aux_pm_en reg from PCIe core to continue the remote wake/clock switching support */
        uint32_t PHYSTATUS_FALL_TIMEOUT_EN :1;   /* When set to '1' enable PHY status timeout function, which is designed to cover the PCIePHY issue that we may have not be able to detect the PHY status toggle. This is a safety feature in case we have gotten into a deadlock during PHY status acknowledgement. */
        uint32_t CCLK_GATE_DISABLE :1;           /* When set to '1' disable core clock gating based on low power state entered. */
        uint32_t NEW_OW_EN   :1;                 /* This bit allows the AUX PM control module to decide whether we entered into P2 overwrite condition based on the power down state of the PCIe core is at P1 or the LTSSM of PCIe core is in L1. What we used to have is based on P1 of the PCIe core mac_phy_powerdown signal. This is not correct because LTSSM can be in RX detect to result a P1 of power down state. To preserve our old function, we add this chicken bit. '0': P2Pverwrite function based on PCIe core PIPE mac_phy_powerdown is in P1, '1': P2OverWrite function based on LTSSM in L1 */
        uint32_t ISOLATION_EN :1;                /* When set to '1' enable isolation function for dual power zone. */
        uint32_t PME_STATUS_EN :1;               /* This bit enables the PCIe status function. '0': xHC as a PCIe device will not generate any PME nor report PME status. '1': xHC as a PCIe device will generate the PME message. */
        uint32_t ELECIDLE_MASK_EN :1;            /* This bit enables the AUX PM control state machine to take over txelecidle signal of the PIPE during several special conditions. '0': Disable the mask. '1': Allow mask to mac_phy_txeleidle of PCIe core. */
        uint32_t CFG_PIPE_RST_EN :1;             /* Cfg_pipe_rst_en_sync. */
        uint32_t CFG_RXDET_P3_EN :1;             /* Cfg_rxdet_p3_en. Enable rxdet U3 mode */
        uint32_t CFG_CLK_GATE_DIS :1;            /* Cfg_clk_gate_dis */
        uint32_t CFG_USB_P2_EN :1;               /* Cfg_Usb_p2_en */
        uint32_t CFG_IOB_DRIVESTRENGTH :2;       /* Controls the drive strength of the IO buffer. Set default IO Strength to 8ma */
        uint32_t CFG_PCIE_TXREG_PD :1;           /* cfg_pcie_txreg_pd */
        uint32_t CLR_SAVE_FLAG :1;
        uint32_t RESERVEDRW  :1;                 /* reserved, RW */
        uint32_t SR_CMD_SAVE_EN :1;
        uint32_t CLR_SSV_EN  :1;                 /* When set to '1' clear the SSV flag */
        uint32_t SET_SSV_EN  :1;                 /* When set to '1' set the SSV flag. */
        uint32_t POWERDOWN_P1_EN :1;             /* This is a test/control bit. This bit is designed to control the lowest powerdown state of the PCIe that AUX PM module signaled to PIPE is P1. '0': drive as normal operation. '1': always drive to P1 instead of P2 */
        uint32_t USE_PERST_4FD_RST :1;           /* Enable AUX reset module to treat every PERST# as a fundamental reset '0': disabled, '1': enabled */
        uint32_t DIRECT_RATE_PASS_EN :1;         /* Disable the overwrite function in AUX PM control module for its initiated rate change. '0': allows AUX PM control module to initiate its PCIE rate change when it needs to enable P2 overwrite P1 function. '1': AUX PM control module will not alter the PCIe rate change function . */
        uint32_t EXTEND_PHYSTATUS_EN :1;         /* This bit is there for a bug fix where we need to ensure that phystatus did not get lost during the rate change where clock switch logic takes some cycles to complete; such that the PCie's core clock is at half of the PCIe PHY pclk. '0': not extended phystatus, '1': extended phystatus assertion */
        uint32_t LOW_PWR_CCLK_GATE_EN :1;        /* This bit enables gate-off the core clock when AUX PM control is in low power state. '0': disable this function, '1': enabled to gate off the core clock. */
        uint32_t D3_HOT_PME_EN :1;               /* d3_hot_pme_en */
    } B;
} IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_t;

/* Register XECP_AUX_CTRL_REG1 - AUX Power Management Control 1. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_OFFSET 0x18120
/* Field FORCE_PM_STATE - When set to '1' force PM state to go to the state indicated in field pm_state (bits [4:1]). This bit is the force PM state register, it is a pulse only (read by software will always give '0') */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_FORCE_PM_STATE_SHIFT 0
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_FORCE_PM_STATE_MASK 0x1
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_FORCE_PM_STATE(v) (((v) << 0) & 0x1)
/* Field PM_STATE - Forced power management state can be set here. States encoding: PM_ACTIVE : 4'h0; REQ_CLK_SWITCH_2AUX : 4'h1; DRIVE_PHY_2P2 : 4'h2; WAIT_4WAKE : 4'h3; WAIT_4PERST_DSRT : 4'h4; RATE_CHANGE_2FAST : 4'h5; REQ_CLK_SWITCH_2PCLK : 4'h6; PM_EXIT : 4'h7; WAIT_4PCLK : 4'h8; DRIVE_PHY_STATUS : 4'h9; PM_IDLE : 4'hA; PWRUP_REQ_CLK_SWITCH_2PCLK : 4'hB; RATE_CHANGE_2SLOW : 4'hC; WAIT_4LTSSM_WAIT_DONE : 4'hD; WAIT_4CLK_GATE : 4'hE; IN_P2_TIMEOUT : 4'hF; Those bits have also another functionality: [1]: always_wake_n_en, [2]: timeout_16ms_en, [3]: always_force_clk_sw_en, ![4]: rc_p2_exit_en */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PM_STATE_SHIFT 1
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PM_STATE_MASK 0x1E
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PM_STATE(v) (((v) << 0x1) & 0x1E)
/* Field ENABLE_P2_ENTER - When set to '1' enables the remote wake function by allowing P2 clock/switching and P2 entering */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ENABLE_P2_ENTER_SHIFT 5
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ENABLE_P2_ENTER_MASK 0x20
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ENABLE_P2_ENTER(v) (((v) << 0x5) & 0x20)
/* Field P2_OVERWRITE_P1_EN - When set to '1' enable P2 overwrite P1 when PCIe core has indicated the transition from P0 to P1. This is to enable entering the even lower power state. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_P2_OVERWRITE_P1_EN_SHIFT 6
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_P2_OVERWRITE_P1_EN_MASK 0x40
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_P2_OVERWRITE_P1_EN(v) (((v) << 0x6) & 0x40)
/* Field IGNORE_AUX_PME_EN - When set to '1' ignore the aux_pm_en reg from PCIe core to continue the remote wake/clock switching support */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_IGNORE_AUX_PME_EN_SHIFT 7
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_IGNORE_AUX_PME_EN_MASK 0x80
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_IGNORE_AUX_PME_EN(v) (((v) << 0x7) & 0x80)
/* Field PHYSTATUS_FALL_TIMEOUT_EN - When set to '1' enable PHY status timeout function, which is designed to cover the PCIePHY issue that we may have not be able to detect the PHY status toggle. This is a safety feature in case we have gotten into a deadlock during PHY status acknowledgement. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PHYSTATUS_FALL_TIMEOUT_EN_SHIFT 8
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PHYSTATUS_FALL_TIMEOUT_EN_MASK 0x100
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PHYSTATUS_FALL_TIMEOUT_EN(v) (((v) << 0x8) & 0x100)
/* Field CCLK_GATE_DISABLE - When set to '1' disable core clock gating based on low power state entered. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CCLK_GATE_DISABLE_SHIFT 9
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CCLK_GATE_DISABLE_MASK 0x200
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CCLK_GATE_DISABLE(v) (((v) << 0x9) & 0x200)
/* Field NEW_OW_EN - This bit allows the AUX PM control module to decide whether we entered into P2 overwrite condition based on the power down state of the PCIe core is at P1 or the LTSSM of PCIe core is in L1. What we used to have is based on P1 of the PCIe core mac_phy_powerdown signal. This is not correct because LTSSM can be in RX detect to result a P1 of power down state. To preserve our old function, we add this chicken bit. '0': P2Pverwrite function based on PCIe core PIPE mac_phy_powerdown is in P1, '1': P2OverWrite function based on LTSSM in L1 */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_NEW_OW_EN_SHIFT 10
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_NEW_OW_EN_MASK 0x400
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_NEW_OW_EN(v) (((v) << 0xA) & 0x400)
/* Field ISOLATION_EN - When set to '1' enable isolation function for dual power zone. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ISOLATION_EN_SHIFT 11
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ISOLATION_EN_MASK 0x800
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ISOLATION_EN(v) (((v) << 0xB) & 0x800)
/* Field PME_STATUS_EN - This bit enables the PCIe status function. '0': xHC as a PCIe device will not generate any PME nor report PME status. '1': xHC as a PCIe device will generate the PME message. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PME_STATUS_EN_SHIFT 12
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PME_STATUS_EN_MASK 0x1000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_PME_STATUS_EN(v) (((v) << 0xC) & 0x1000)
/* Field ELECIDLE_MASK_EN - This bit enables the AUX PM control state machine to take over txelecidle signal of the PIPE during several special conditions. '0': Disable the mask. '1': Allow mask to mac_phy_txeleidle of PCIe core. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ELECIDLE_MASK_EN_SHIFT 13
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ELECIDLE_MASK_EN_MASK 0x2000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_ELECIDLE_MASK_EN(v) (((v) << 0xD) & 0x2000)
/* Field CFG_PIPE_RST_EN - Cfg_pipe_rst_en_sync. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_PIPE_RST_EN_SHIFT 14
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_PIPE_RST_EN_MASK 0x4000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_PIPE_RST_EN(v) (((v) << 0xE) & 0x4000)
/* Field CFG_RXDET_P3_EN - Cfg_rxdet_p3_en. Enable rxdet U3 mode */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_RXDET_P3_EN_SHIFT 15
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_RXDET_P3_EN_MASK 0x8000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_RXDET_P3_EN(v) (((v) << 0xF) & 0x8000)
/* Field CFG_CLK_GATE_DIS - Cfg_clk_gate_dis */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_CLK_GATE_DIS_SHIFT 16
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_CLK_GATE_DIS_MASK 0x10000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_CLK_GATE_DIS(v) (((v) << 0x10) & 0x10000)
/* Field CFG_USB_P2_EN - Cfg_Usb_p2_en */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_USB_P2_EN_SHIFT 17
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_USB_P2_EN_MASK 0x20000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_USB_P2_EN(v) (((v) << 0x11) & 0x20000)
/* Field CFG_IOB_DRIVESTRENGTH - Controls the drive strength of the IO buffer. Set default IO Strength to 8ma */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_IOB_DRIVESTRENGTH_SHIFT 18
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_IOB_DRIVESTRENGTH_MASK 0xC0000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_IOB_DRIVESTRENGTH(v) (((v) << 0x12) & 0xC0000)
/* Field CFG_PCIE_TXREG_PD - cfg_pcie_txreg_pd */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_PCIE_TXREG_PD_SHIFT 20
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_PCIE_TXREG_PD_MASK 0x100000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CFG_PCIE_TXREG_PD(v) (((v) << 0x14) & 0x100000)
/* Field CLR_SAVE_FLAG -  */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CLR_SAVE_FLAG_SHIFT 21
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CLR_SAVE_FLAG_MASK 0x200000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CLR_SAVE_FLAG(v) (((v) << 0x15) & 0x200000)
/* Field RESERVEDRW - reserved, RW */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_RESERVEDRW_SHIFT 22
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_RESERVEDRW_MASK 0x400000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_RESERVEDRW(v) (((v) << 0x16) & 0x400000)
/* Field SR_CMD_SAVE_EN -  */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_SR_CMD_SAVE_EN_SHIFT 23
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_SR_CMD_SAVE_EN_MASK 0x800000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_SR_CMD_SAVE_EN(v) (((v) << 0x17) & 0x800000)
/* Field CLR_SSV_EN - When set to '1' clear the SSV flag */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CLR_SSV_EN_SHIFT 24
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CLR_SSV_EN_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_CLR_SSV_EN(v) (((v) << 0x18) & 0x1000000)
/* Field SET_SSV_EN - When set to '1' set the SSV flag. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_SET_SSV_EN_SHIFT 25
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_SET_SSV_EN_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_SET_SSV_EN(v) (((v) << 0x19) & 0x2000000)
/* Field POWERDOWN_P1_EN - This is a test/control bit. This bit is designed to control the lowest powerdown state of the PCIe that AUX PM module signaled to PIPE is P1. '0': drive as normal operation. '1': always drive to P1 instead of P2 */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_POWERDOWN_P1_EN_SHIFT 26
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_POWERDOWN_P1_EN_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_POWERDOWN_P1_EN(v) (((v) << 0x1A) & 0x4000000)
/* Field USE_PERST_4FD_RST - Enable AUX reset module to treat every PERST# as a fundamental reset '0': disabled, '1': enabled */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_USE_PERST_4FD_RST_SHIFT 27
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_USE_PERST_4FD_RST_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_USE_PERST_4FD_RST(v) (((v) << 0x1B) & 0x8000000)
/* Field DIRECT_RATE_PASS_EN - Disable the overwrite function in AUX PM control module for its initiated rate change. '0': allows AUX PM control module to initiate its PCIE rate change when it needs to enable P2 overwrite P1 function. '1': AUX PM control module will not alter the PCIe rate change function . */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_DIRECT_RATE_PASS_EN_SHIFT 28
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_DIRECT_RATE_PASS_EN_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_DIRECT_RATE_PASS_EN(v) (((v) << 0x1C) & 0x10000000)
/* Field EXTEND_PHYSTATUS_EN - This bit is there for a bug fix where we need to ensure that phystatus did not get lost during the rate change where clock switch logic takes some cycles to complete; such that the PCie's core clock is at half of the PCIe PHY pclk. '0': not extended phystatus, '1': extended phystatus assertion */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_EXTEND_PHYSTATUS_EN_SHIFT 29
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_EXTEND_PHYSTATUS_EN_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_EXTEND_PHYSTATUS_EN(v) (((v) << 0x1D) & 0x20000000)
/* Field LOW_PWR_CCLK_GATE_EN - This bit enables gate-off the core clock when AUX PM control is in low power state. '0': disable this function, '1': enabled to gate off the core clock. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_LOW_PWR_CCLK_GATE_EN_SHIFT 30
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_LOW_PWR_CCLK_GATE_EN_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_LOW_PWR_CCLK_GATE_EN(v) (((v) << 0x1E) & 0x40000000)
/* Field D3_HOT_PME_EN - d3_hot_pme_en */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_D3_HOT_PME_EN_SHIFT 31
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_D3_HOT_PME_EN_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_D3_HOT_PME_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG - Port Watermark. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_union_t {
    uint32_t R;
    struct {
        uint32_t XBUF_WATER_MARK :16;            /* XBUF water mark */
        uint32_t RBUF_WATER_MARK :16;            /* RBUF water mark */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_t;

/* Register XECP_HOST_CTRL_WATERMARK_REG - Port Watermark. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_OFFSET 0x18128
/* Field XBUF_WATER_MARK - XBUF water mark */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_XBUF_WATER_MARK_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_XBUF_WATER_MARK_MASK 0xFFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_XBUF_WATER_MARK(v) (((v) << 0) & 0xFFFF)
/* Field RBUF_WATER_MARK - RBUF water mark */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_RBUF_WATER_MARK_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_RBUF_WATER_MARK_MASK 0xFFFF0000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_RBUF_WATER_MARK(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG - SuperSpeed Port Link Control. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_union_t {
    uint32_t R;
    struct {
        uint32_t CFG_DIS_COMP :1;                /* '0': Enable link compliance mode, '1': Disable link compliance mode. */
        uint32_t CFG_LPBK_MODE :1;               /* '0': Disable link loopback master mode, '1': Enable link loopback master mode. */
        uint32_t CFG_U1_ENABLE :1;               /* '0': Normal operation mode, '1': Direct link to U1 from U0. This bit is for test purpose only. It shall be written '0' in normal operation mode. */
        uint32_t CFG_U2_ENABLE :1;               /* '0': Normal operation mode, '1': Direct link to U2 from U0. This bit is for test purpose only. It shall be written '0' in normal operation mode. */
        uint32_t CFG_SYMBOL_ERR_EN :1;           /* '0': Disable detecting RxData error using RxStatus signal, '1': Enable detecting RxData error using RxStatus signal. */
        uint32_t CFG_DIS_SCRMB :1;               /* '0': Enable link scrambler, '1': Disable link scrambler. */
        uint32_t CFG_FAST_TRAINING :1;           /* '0': Normal operation mode, '1': Link fast training mode. This bit should be written '0' in normal operation. */
        uint32_t CFG_RECOVERY :1;                /* '0': Normal operation mode, '1': Direct link to Recovery from U0. */
        uint32_t CFG_FORCE_PM_ACCEPT :1;         /* '0': Normal operation mode. '1': Force link to accept power management command. */
        uint32_t CFG_U3_RECOV_VAL :3;            /* This value defines the minimum time for the link to stay in Polling.Active and Recovery.Active from U3. The granuity is 128us. */
        uint32_t CFG_NORM_RECOV_VAL :3;          /* This value defines the minimum time for the link to stay in Recovery. Active other than from U3. The granuity is 128us. */
        uint32_t CFG_LOWPOWER_LATENCY :2;        /* cfg_lowpower_latency */
        uint32_t DBG_MODE_SEL :3;                /* Debug mode select: bit[0]: cfg_port_init_ctrl (if set to '1' tPortConfiguration < 21us), bit[1]: cfg_relax_ts2_en, bit[2]: cfg_relax_lfps_en. */
        uint32_t LINK_ERR_CNT_SLV_EN :1;         /* link_err_cnt_slv_en */
        uint32_t FORCE_COMP_PATTERN :4;          /* Compliance pattern to be forced to enter compliance mode. This value is for test purpose only. */
        uint32_t FORCE_LTSSM_U0 :1;              /* '0': Normal operation mode, '1': Direct link to U0 This bit is for test purpose only. It shall be written '0' in normal operation mode. */
        uint32_t FORCE_LTSSM :1;                 /* '0': Normal operation mode, '1': Direct link to a specific state specified by force_ltssm_state field (bits [31:27]). This bit is for test purpose only. It shall be written '0' in normal operation mode. */
        uint32_t FORCE_LTSSM_STATE :5;           /* LTSSM state to be forced. This value is for test purpose only. Setting bit 4 enables: cfg_relax_rxpolarity_en; Setting bit 3 enables: cfg_relax_linkfunc_en; Setting bit 2 enables: cfg_link_func_en; */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_t;

/* Register XECP_HOST_CTRL_PORT_LINK_REG - SuperSpeed Port Link Control. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_OFFSET 0x1812C
/* Field CFG_DIS_COMP - '0': Enable link compliance mode, '1': Disable link compliance mode. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_DIS_COMP_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_DIS_COMP_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_DIS_COMP(v) (((v) << 0) & 0x1)
/* Field CFG_LPBK_MODE - '0': Disable link loopback master mode, '1': Enable link loopback master mode. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_LPBK_MODE_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_LPBK_MODE_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_LPBK_MODE(v) (((v) << 0x1) & 0x2)
/* Field CFG_U1_ENABLE - '0': Normal operation mode, '1': Direct link to U1 from U0. This bit is for test purpose only. It shall be written '0' in normal operation mode. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U1_ENABLE_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U1_ENABLE_MASK 0x4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U1_ENABLE(v) (((v) << 0x2) & 0x4)
/* Field CFG_U2_ENABLE - '0': Normal operation mode, '1': Direct link to U2 from U0. This bit is for test purpose only. It shall be written '0' in normal operation mode. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U2_ENABLE_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U2_ENABLE_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U2_ENABLE(v) (((v) << 0x3) & 0x8)
/* Field CFG_SYMBOL_ERR_EN - '0': Disable detecting RxData error using RxStatus signal, '1': Enable detecting RxData error using RxStatus signal. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_SYMBOL_ERR_EN_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_SYMBOL_ERR_EN_MASK 0x10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_SYMBOL_ERR_EN(v) (((v) << 0x4) & 0x10)
/* Field CFG_DIS_SCRMB - '0': Enable link scrambler, '1': Disable link scrambler. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_DIS_SCRMB_SHIFT 5
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_DIS_SCRMB_MASK 0x20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_DIS_SCRMB(v) (((v) << 0x5) & 0x20)
/* Field CFG_FAST_TRAINING - '0': Normal operation mode, '1': Link fast training mode. This bit should be written '0' in normal operation. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_FAST_TRAINING_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_FAST_TRAINING_MASK 0x40
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_FAST_TRAINING(v) (((v) << 0x6) & 0x40)
/* Field CFG_RECOVERY - '0': Normal operation mode, '1': Direct link to Recovery from U0. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_RECOVERY_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_RECOVERY_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_RECOVERY(v) (((v) << 0x7) & 0x80)
/* Field CFG_FORCE_PM_ACCEPT - '0': Normal operation mode. '1': Force link to accept power management command. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_FORCE_PM_ACCEPT_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_FORCE_PM_ACCEPT_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_FORCE_PM_ACCEPT(v) (((v) << 0x8) & 0x100)
/* Field CFG_U3_RECOV_VAL - This value defines the minimum time for the link to stay in Polling.Active and Recovery.Active from U3. The granuity is 128us. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U3_RECOV_VAL_SHIFT 9
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U3_RECOV_VAL_MASK 0xE00
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_U3_RECOV_VAL(v) (((v) << 0x9) & 0xE00)
/* Field CFG_NORM_RECOV_VAL - This value defines the minimum time for the link to stay in Recovery. Active other than from U3. The granuity is 128us. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_NORM_RECOV_VAL_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_NORM_RECOV_VAL_MASK 0x7000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_NORM_RECOV_VAL(v) (((v) << 0xC) & 0x7000)
/* Field CFG_LOWPOWER_LATENCY - cfg_lowpower_latency */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_LOWPOWER_LATENCY_SHIFT 15
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_LOWPOWER_LATENCY_MASK 0x18000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_CFG_LOWPOWER_LATENCY(v) (((v) << 0xF) & 0x18000)
/* Field DBG_MODE_SEL - Debug mode select: bit[0]: cfg_port_init_ctrl (if set to '1' tPortConfiguration < 21us), bit[1]: cfg_relax_ts2_en, bit[2]: cfg_relax_lfps_en. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_DBG_MODE_SEL_SHIFT 17
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_DBG_MODE_SEL_MASK 0xE0000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_DBG_MODE_SEL(v) (((v) << 0x11) & 0xE0000)
/* Field LINK_ERR_CNT_SLV_EN - link_err_cnt_slv_en */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_LINK_ERR_CNT_SLV_EN_SHIFT 20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_LINK_ERR_CNT_SLV_EN_MASK 0x100000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_LINK_ERR_CNT_SLV_EN(v) (((v) << 0x14) & 0x100000)
/* Field FORCE_COMP_PATTERN - Compliance pattern to be forced to enter compliance mode. This value is for test purpose only. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_COMP_PATTERN_SHIFT 21
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_COMP_PATTERN_MASK 0x1E00000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_COMP_PATTERN(v) (((v) << 0x15) & 0x1E00000)
/* Field FORCE_LTSSM_U0 - '0': Normal operation mode, '1': Direct link to U0 This bit is for test purpose only. It shall be written '0' in normal operation mode. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM_U0_SHIFT 25
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM_U0_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM_U0(v) (((v) << 0x19) & 0x2000000)
/* Field FORCE_LTSSM - '0': Normal operation mode, '1': Direct link to a specific state specified by force_ltssm_state field (bits [31:27]). This bit is for test purpose only. It shall be written '0' in normal operation mode. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM_SHIFT 26
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM(v) (((v) << 0x1A) & 0x4000000)
/* Field FORCE_LTSSM_STATE - LTSSM state to be forced. This value is for test purpose only. Setting bit 4 enables: cfg_relax_rxpolarity_en; Setting bit 3 enables: cfg_relax_linkfunc_en; Setting bit 2 enables: cfg_link_func_en; */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM_STATE_SHIFT 27
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM_STATE_MASK 0xF8000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_FORCE_LTSSM_STATE(v) (((v) << 0x1B) & 0xF8000000)

/* IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1 - USB2 Port Link Control 1,2,3,4. */
typedef union IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t USB2_PM_DEBUG_QUICK_SIM :1;     /* Short Timer Values For Simulation of USB2.0 parameters. Please refer to Integration Guide section on Debug Features */
        uint32_t USB2_PM_DEBUG_PHY_RST :1;       /* Control PHY Reset Directly */
        uint32_t USB2_PM_DEBUG_PHY_RSTDISCON :1; /* Disable Clock Gate */
        uint32_t USB2_PM_DEBUG_PHY_CLKGATEDIS :1; /* Disable PHY suspend during disconnect. */
        uint32_t USB2_PM_DEBUG_PHY_SUSDISALL :1; /* Disable PHY suspend for all states. */
        uint32_t USB2_PM_DEBUG_AUTOPING :1;
        uint32_t USB2_PM_DEBUG_FORCEPING :1;     /* If retry on endpoint that should have PING, force the PING. */
        uint32_t USB2_PM_DEBUG_DROPPING :1;      /* If new ping on endpoint that already had PING, drop the PING. */
        uint32_t USB2_PM_DEBUG_DIRECT_RESUME :1; /* Use FS/LS serial I/F to drive resume. */
        uint32_t USB2_PM_DEBUG_DIS_ISO_PEEK :1;  /* Disable waiting for last indication for USB2 ISO. */
        uint32_t USB2_PM_DEBUG_DIS_PORT_ERR :1;  /* Enable Remote Wake Resume Trap. */
        uint32_t USB2_PM_DEBUG_ENABLE_DISC_WIN :1; /* Enable HS disconnect Window. */
        uint32_t USB2_PM_DEBUG_UTMIRST1 :1;      /* Select UTMI Reset Source 1 */
        uint32_t USB2_PM_DEBUG_UTMIRST2 :1;      /* Select UTMI Reset Source 2 */
        uint32_t USB2_PM_DEBUG_FS_LS_EXT_DISCON :1; /* Use UTMI HostDisconnect input for FS/LS */
        uint32_t USB2_PM_DEBUG_SPLIT_192_LIMITDIS :1; /* Use to disable 192 byte limit checking on. */
        uint32_t USB2_PM_DEBUG_FORCE_FULL_SPEED :1; /* Set to reject device chirp and force full-speed */
        uint32_t USB2_PM_DEBUG_EOP_DETECT :1;    /* Set to enable full length SE0 detect. */
        uint32_t USB2_PM_DEBUG_ENABLE_FLUSH_TO :1; /* Set to enable flush state timeouts. */
        uint32_t USB2_PM_DEBUG_HW_LPM_ERRATA1 :1; /* Set to change the scale of HW LPM timeout to 256us increments. */
        uint32_t USB2_PM_DEBUG_HW_LPM_ERRATA :1; /* Set to switch the HIRD to BESL format. */
        uint32_t USB2_PM_DEBUG_RESUME_DEB_DIS :1; /* Clr to eliminate debounce on remote wake detect. */
        uint32_t USB2_PM_DEBUG_LATENCY_TOL_MSG :1; /* Latency Tolerance Scheme ('0'=when HWLPM is enabled / '1'=when L1 is active). */
        uint32_t USB2_PM_DEBUG :1;               /* USB2_PM_DEBUG. usb2_link_mgr_debug register. */
        uint32_t TIMER_DISCONNECT_DETECT_LO :8;  /* Number of microseconds of SE0 in FS/LS mode to register disconnect had occurred. First 8 MSB. */
    } B;
} IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_t;

/* Register XECP_USB2_LINK_MGR_CTRL_REG1 - USB2 Port Link Control 1,2,3,4. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_OFFSET 0x18130
/* Field USB2_PM_DEBUG_QUICK_SIM - Short Timer Values For Simulation of USB2.0 parameters. Please refer to Integration Guide section on Debug Features */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_QUICK_SIM_SHIFT 0
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_QUICK_SIM_MASK 0x1
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_QUICK_SIM(v) (((v) << 0) & 0x1)
/* Field USB2_PM_DEBUG_PHY_RST - Control PHY Reset Directly */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_RST_SHIFT 1
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_RST_MASK 0x2
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_RST(v) (((v) << 0x1) & 0x2)
/* Field USB2_PM_DEBUG_PHY_RSTDISCON - Disable Clock Gate */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_RSTDISCON_SHIFT 2
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_RSTDISCON_MASK 0x4
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_RSTDISCON(v) (((v) << 0x2) & 0x4)
/* Field USB2_PM_DEBUG_PHY_CLKGATEDIS - Disable PHY suspend during disconnect. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_CLKGATEDIS_SHIFT 3
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_CLKGATEDIS_MASK 0x8
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_CLKGATEDIS(v) (((v) << 0x3) & 0x8)
/* Field USB2_PM_DEBUG_PHY_SUSDISALL - Disable PHY suspend for all states. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_SUSDISALL_SHIFT 4
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_SUSDISALL_MASK 0x10
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_PHY_SUSDISALL(v) (((v) << 0x4) & 0x10)
/* Field USB2_PM_DEBUG_AUTOPING -  */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_AUTOPING_SHIFT 5
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_AUTOPING_MASK 0x20
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_AUTOPING(v) (((v) << 0x5) & 0x20)
/* Field USB2_PM_DEBUG_FORCEPING - If retry on endpoint that should have PING, force the PING. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FORCEPING_SHIFT 6
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FORCEPING_MASK 0x40
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FORCEPING(v) (((v) << 0x6) & 0x40)
/* Field USB2_PM_DEBUG_DROPPING - If new ping on endpoint that already had PING, drop the PING. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DROPPING_SHIFT 7
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DROPPING_MASK 0x80
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DROPPING(v) (((v) << 0x7) & 0x80)
/* Field USB2_PM_DEBUG_DIRECT_RESUME - Use FS/LS serial I/F to drive resume. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIRECT_RESUME_SHIFT 8
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIRECT_RESUME_MASK 0x100
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIRECT_RESUME(v) (((v) << 0x8) & 0x100)
/* Field USB2_PM_DEBUG_DIS_ISO_PEEK - Disable waiting for last indication for USB2 ISO. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIS_ISO_PEEK_SHIFT 9
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIS_ISO_PEEK_MASK 0x200
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIS_ISO_PEEK(v) (((v) << 0x9) & 0x200)
/* Field USB2_PM_DEBUG_DIS_PORT_ERR - Enable Remote Wake Resume Trap. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIS_PORT_ERR_SHIFT 10
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIS_PORT_ERR_MASK 0x400
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_DIS_PORT_ERR(v) (((v) << 0xA) & 0x400)
/* Field USB2_PM_DEBUG_ENABLE_DISC_WIN - Enable HS disconnect Window. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_ENABLE_DISC_WIN_SHIFT 11
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_ENABLE_DISC_WIN_MASK 0x800
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_ENABLE_DISC_WIN(v) (((v) << 0xB) & 0x800)
/* Field USB2_PM_DEBUG_UTMIRST1 - Select UTMI Reset Source 1 */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_UTMIRST1_SHIFT 12
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_UTMIRST1_MASK 0x1000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_UTMIRST1(v) (((v) << 0xC) & 0x1000)
/* Field USB2_PM_DEBUG_UTMIRST2 - Select UTMI Reset Source 2 */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_UTMIRST2_SHIFT 13
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_UTMIRST2_MASK 0x2000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_UTMIRST2(v) (((v) << 0xD) & 0x2000)
/* Field USB2_PM_DEBUG_FS_LS_EXT_DISCON - Use UTMI HostDisconnect input for FS/LS */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FS_LS_EXT_DISCON_SHIFT 14
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FS_LS_EXT_DISCON_MASK 0x4000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FS_LS_EXT_DISCON(v) (((v) << 0xE) & 0x4000)
/* Field USB2_PM_DEBUG_SPLIT_192_LIMITDIS - Use to disable 192 byte limit checking on. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_SPLIT_192_LIMITDIS_SHIFT 15
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_SPLIT_192_LIMITDIS_MASK 0x8000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_SPLIT_192_LIMITDIS(v) (((v) << 0xF) & 0x8000)
/* Field USB2_PM_DEBUG_FORCE_FULL_SPEED - Set to reject device chirp and force full-speed */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FORCE_FULL_SPEED_SHIFT 16
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FORCE_FULL_SPEED_MASK 0x10000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_FORCE_FULL_SPEED(v) (((v) << 0x10) & 0x10000)
/* Field USB2_PM_DEBUG_EOP_DETECT - Set to enable full length SE0 detect. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_EOP_DETECT_SHIFT 17
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_EOP_DETECT_MASK 0x20000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_EOP_DETECT(v) (((v) << 0x11) & 0x20000)
/* Field USB2_PM_DEBUG_ENABLE_FLUSH_TO - Set to enable flush state timeouts. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_ENABLE_FLUSH_TO_SHIFT 18
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_ENABLE_FLUSH_TO_MASK 0x40000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_ENABLE_FLUSH_TO(v) (((v) << 0x12) & 0x40000)
/* Field USB2_PM_DEBUG_HW_LPM_ERRATA1 - Set to change the scale of HW LPM timeout to 256us increments. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_HW_LPM_ERRATA1_SHIFT 19
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_HW_LPM_ERRATA1_MASK 0x80000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_HW_LPM_ERRATA1(v) (((v) << 0x13) & 0x80000)
/* Field USB2_PM_DEBUG_HW_LPM_ERRATA - Set to switch the HIRD to BESL format. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_HW_LPM_ERRATA_SHIFT 20
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_HW_LPM_ERRATA_MASK 0x100000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_HW_LPM_ERRATA(v) (((v) << 0x14) & 0x100000)
/* Field USB2_PM_DEBUG_RESUME_DEB_DIS - Clr to eliminate debounce on remote wake detect. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_RESUME_DEB_DIS_SHIFT 21
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_RESUME_DEB_DIS_MASK 0x200000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_RESUME_DEB_DIS(v) (((v) << 0x15) & 0x200000)
/* Field USB2_PM_DEBUG_LATENCY_TOL_MSG - Latency Tolerance Scheme ('0'=when HWLPM is enabled / '1'=when L1 is active). */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_LATENCY_TOL_MSG_SHIFT 22
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_LATENCY_TOL_MSG_MASK 0x400000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_LATENCY_TOL_MSG(v) (((v) << 0x16) & 0x400000)
/* Field USB2_PM_DEBUG - USB2_PM_DEBUG. usb2_link_mgr_debug register. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_SHIFT 23
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG_MASK 0x800000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_USB2_PM_DEBUG(v) (((v) << 0x17) & 0x800000)
/* Field TIMER_DISCONNECT_DETECT_LO - Number of microseconds of SE0 in FS/LS mode to register disconnect had occurred. First 8 MSB. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_TIMER_DISCONNECT_DETECT_LO_SHIFT 24
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_TIMER_DISCONNECT_DETECT_LO_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_TIMER_DISCONNECT_DETECT_LO(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2 - USB2 Port Link Control 1, 2, 3, 4. */
typedef union IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_union_t {
    uint32_t R;
    struct {
        uint32_t TIMER_DISCONNECT_DETECT_HI :5;  /* Number of microseconds of SE0 in FS/LS mode to register disconnect had occurred. Last 5 LSBs. */
        uint32_t TIMER_CONNECT_DETECT :13;       /* Number of microseconds of K/J in disconnected state to register connect has occurred. Last 5 LSBs. */
        uint32_t TIMER_CHIRP_K_DETECT :13;       /* Number of microseconds of Chirp-K to register that a device is chirping */
        uint32_t TIMER_RESET_0 :1;               /* Number of microseconds for total reset duration */
    } B;
} IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_t;

/* Register XECP_USB2_LINK_MGR_CTRL_REG2 - USB2 Port Link Control 1, 2, 3, 4. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_OFFSET 0x18134
/* Field TIMER_DISCONNECT_DETECT_HI - Number of microseconds of SE0 in FS/LS mode to register disconnect had occurred. Last 5 LSBs. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_DISCONNECT_DETECT_HI_SHIFT 0
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_DISCONNECT_DETECT_HI_MASK 0x1F
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_DISCONNECT_DETECT_HI(v) (((v) << 0) & 0x1F)
/* Field TIMER_CONNECT_DETECT - Number of microseconds of K/J in disconnected state to register connect has occurred. Last 5 LSBs. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_CONNECT_DETECT_SHIFT 5
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_CONNECT_DETECT_MASK 0x3FFE0
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_CONNECT_DETECT(v) (((v) << 0x5) & 0x3FFE0)
/* Field TIMER_CHIRP_K_DETECT - Number of microseconds of Chirp-K to register that a device is chirping */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_CHIRP_K_DETECT_SHIFT 18
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_CHIRP_K_DETECT_MASK 0x7FFC0000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_CHIRP_K_DETECT(v) (((v) << 0x12) & 0x7FFC0000)
/* Field TIMER_RESET_0 - Number of microseconds for total reset duration */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_RESET_0_SHIFT 31
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_RESET_0_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_TIMER_RESET_0(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3 - USB2 Port Link Control 1, 2, 3, 4. */
typedef union IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_union_t {
    uint32_t R;
    struct {
        uint32_t TIMER_RESET :15;                /* Number of microseconds for total reset duration */
        uint32_t TIMER_U3_SETTLE :13;            /* Number of microseconds after entering U3; linestate changes are ignored as bus settles */
        uint32_t TIMER_U2_SETTLE :4;             /* Number of microseconds after entering U2; linestate changes are ignored as bus settles. First 4 LSB. */
    } B;
} IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_t;

/* Register XECP_USB2_LINK_MGR_CTRL_REG3 - USB2 Port Link Control 1, 2, 3, 4. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_OFFSET 0x18138
/* Field TIMER_RESET - Number of microseconds for total reset duration */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_RESET_SHIFT 0
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_RESET_MASK 0x7FFF
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_RESET(v) (((v) << 0) & 0x7FFF)
/* Field TIMER_U3_SETTLE - Number of microseconds after entering U3; linestate changes are ignored as bus settles */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_U3_SETTLE_SHIFT 15
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_U3_SETTLE_MASK 0xFFF8000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_U3_SETTLE(v) (((v) << 0xF) & 0xFFF8000)
/* Field TIMER_U2_SETTLE - Number of microseconds after entering U2; linestate changes are ignored as bus settles. First 4 LSB. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_U2_SETTLE_SHIFT 28
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_U2_SETTLE_MASK 0xF0000000
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_TIMER_U2_SETTLE(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4 - USB2 Port Link Control 1, 2, 3, 4. */
typedef union IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_union_t {
    uint32_t R;
    struct {
        uint32_t TIMER_U2_SETTLE :9;             /* Number of microseconds after entering U2; linestate changes are ignored as bus settles. Last 9 MSB. */
        uint32_t TIMER_RESUME_U2_REFLECT :16;    /* Number of microseconds after detecting U2 remote wake condition to reflect K */
        uint32_t _unused25   :7;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_t;

/* Register XECP_USB2_LINK_MGR_CTRL_REG4 - USB2 Port Link Control 1, 2, 3, 4. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_OFFSET 0x1813C
/* Field TIMER_U2_SETTLE - Number of microseconds after entering U2; linestate changes are ignored as bus settles. Last 9 MSB. */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_TIMER_U2_SETTLE_SHIFT 0
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_TIMER_U2_SETTLE_MASK 0x1FF
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_TIMER_U2_SETTLE(v) (((v) << 0) & 0x1FF)
/* Field TIMER_RESUME_U2_REFLECT - Number of microseconds after detecting U2 remote wake condition to reflect K */
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_TIMER_RESUME_U2_REFLECT_SHIFT 9
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_TIMER_RESUME_U2_REFLECT_MASK 0x1FFFE00
#define IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_TIMER_RESUME_U2_REFLECT(v) (((v) << 0x9) & 0x1FFFE00)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG - USB2 Max Bandwidth Control. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_union_t {
    uint32_t R;
    struct {
        uint32_t FSLS_MAX_BW :8;                 /* Max. Percentage BW allowed for FS/LS (default: 90) */
        uint32_t HS_MAX_BW   :8;                 /* Max. Percentage BW allowed for HS (default: 80) */
        uint32_t SS_MAX_BW   :8;                 /* Max. Percentage BW allowed for SS (default: 80) */
        uint32_t FSLS_BHUB_MAX_BW :8;            /* Max. Percentage BW allowed for FS/LS behind hub (default: 90) */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_t;

/* Register XECP_HOST_CTRL_BW_MAX_REG - USB2 Max Bandwidth Control. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_OFFSET 0x18140
/* Field FSLS_MAX_BW - Max. Percentage BW allowed for FS/LS (default: 90) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_FSLS_MAX_BW_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_FSLS_MAX_BW_MASK 0xFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_FSLS_MAX_BW(v) (((v) << 0) & 0xFF)
/* Field HS_MAX_BW - Max. Percentage BW allowed for HS (default: 80) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_HS_MAX_BW_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_HS_MAX_BW_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_HS_MAX_BW(v) (((v) << 0x8) & 0xFF00)
/* Field SS_MAX_BW - Max. Percentage BW allowed for SS (default: 80) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_SS_MAX_BW_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_SS_MAX_BW_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_SS_MAX_BW(v) (((v) << 0x10) & 0xFF0000)
/* Field FSLS_BHUB_MAX_BW - Max. Percentage BW allowed for FS/LS behind hub (default: 90) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_FSLS_BHUB_MAX_BW_SHIFT 24
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_FSLS_BHUB_MAX_BW_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_FSLS_BHUB_MAX_BW(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_FPGA_REVISION_REG - FPGA_REVISION_REG. */
typedef union IMX_USB3_USBSS_XECP_FPGA_REVISION_REG_union_t {
    uint32_t R;
    struct {
        uint32_t FPGA_REVISION_REG_DEFAULT :32;  /* FPGA_REVISION_REG_DEFAULT */
    } B;
} IMX_USB3_USBSS_XECP_FPGA_REVISION_REG_t;

/* Register XECP_FPGA_REVISION_REG - FPGA_REVISION_REG. */
#define IMX_USB3_USBSS_XECP_FPGA_REVISION_REG_OFFSET 0x18144
/* Field FPGA_REVISION_REG_DEFAULT - FPGA_REVISION_REG_DEFAULT */
#define IMX_USB3_USBSS_XECP_FPGA_REVISION_REG_FPGA_REVISION_REG_DEFAULT_SHIFT 0
#define IMX_USB3_USBSS_XECP_FPGA_REVISION_REG_FPGA_REVISION_REG_DEFAULT_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_FPGA_REVISION_REG_FPGA_REVISION_REG_DEFAULT(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG - Host interface control register. */
typedef union IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_union_t {
    uint32_t R;
    struct {
        uint32_t HOST_ERR_MASK :1;               /* host_err_mask. If set to '1' do not mask the host system error */
        uint32_t HC_HALT_TIMEOUT_EN :1;          /* hc_halt_timeout_en. An internal register bit used to control whether or not to use the hc halt status timer of 15ms */
        uint32_t HOST_INTF_CTRL :4;              /* host_intf_ctrl */
        uint32_t CFG_MAX_NUM_OF_RD :2;           /* cfg_max_num_of_rd. This is to control how many max number of read that we allow ODMA read to issue. '00': can issue 16 reads '10': can issue 8 reads '01': can issue 4 reads */
        uint32_t PROT_HDR_RBUF_OVERFLOW_CCLK :1; /* prot_hdr_rbuf_overflow_cclk. */
        uint32_t _unused9    :23;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_t;

/* Register XECP_HOST_INTF_CTRL_REG - Host interface control register. */
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_OFFSET 0x18148
/* Field HOST_ERR_MASK - host_err_mask. If set to '1' do not mask the host system error */
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HOST_ERR_MASK_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HOST_ERR_MASK_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HOST_ERR_MASK(v) (((v) << 0) & 0x1)
/* Field HC_HALT_TIMEOUT_EN - hc_halt_timeout_en. An internal register bit used to control whether or not to use the hc halt status timer of 15ms */
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HC_HALT_TIMEOUT_EN_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HC_HALT_TIMEOUT_EN_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HC_HALT_TIMEOUT_EN(v) (((v) << 0x1) & 0x2)
/* Field HOST_INTF_CTRL - host_intf_ctrl */
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HOST_INTF_CTRL_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HOST_INTF_CTRL_MASK 0x3C
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_HOST_INTF_CTRL(v) (((v) << 0x2) & 0x3C)
/* Field CFG_MAX_NUM_OF_RD - cfg_max_num_of_rd. This is to control how many max number of read that we allow ODMA read to issue. '00': can issue 16 reads '10': can issue 8 reads '01': can issue 4 reads */
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_CFG_MAX_NUM_OF_RD_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_CFG_MAX_NUM_OF_RD_MASK 0xC0
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_CFG_MAX_NUM_OF_RD(v) (((v) << 0x6) & 0xC0)
/* Field PROT_HDR_RBUF_OVERFLOW_CCLK - prot_hdr_rbuf_overflow_cclk. */
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_PROT_HDR_RBUF_OVERFLOW_CCLK_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_PROT_HDR_RBUF_OVERFLOW_CCLK_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_PROT_HDR_RBUF_OVERFLOW_CCLK(v) (((v) << 0x8) & 0x100)

/* IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG - BW_OV_SS_BURST_REG. */
typedef union IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_union_t {
    uint32_t R;
    struct {
        uint32_t BW_OV_SS_BURST :12;             /* bw_ov_ss_burst */
        uint32_t BW_OV_SYS_BURST :12;            /* bw_ov_sys_burst */
        uint32_t _unused24   :8;                 /* Reserved. For Hardware Bandwidth Calculation Only */
    } B;
} IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_t;

/* Register XECP_BW_OV_SS_BURST_REG - BW_OV_SS_BURST_REG. */
#define IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_OFFSET 0x1814C
/* Field BW_OV_SS_BURST - bw_ov_ss_burst */
#define IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_BW_OV_SS_BURST_SHIFT 0
#define IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_BW_OV_SS_BURST_MASK 0xFFF
#define IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_BW_OV_SS_BURST(v) (((v) << 0) & 0xFFF)
/* Field BW_OV_SYS_BURST - bw_ov_sys_burst */
#define IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_BW_OV_SYS_BURST_SHIFT 12
#define IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_BW_OV_SYS_BURST_MASK 0xFFF000
#define IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_BW_OV_SYS_BURST(v) (((v) << 0xC) & 0xFFF000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2 - Host Control Transfer Manager (TRM) register. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_union_t {
    uint32_t R;
    struct {
        uint32_t RESERVE_TRB_EN :1;              /* '0': report TRB ERR for reserved TRB type, '1': enable XFER engine to process a reserved TRB type as a NO-OP TRB. */
        uint32_t ISO_CNT_2NODMA_EN :1;           /* '0': Disable this non DMA TRB detect function '1': Enable the function where XFER engine uses the remaining burst count as an indication that the next TRB on the transfer ring for an ISO TD is either link TRB or event data TRB. */
        uint32_t UPORT_CRD_UPD_EN :1;            /* '0': Disable the credit redeem, '1': Enable the credit redeem when a port is in NC state. */
        uint32_t CNTX_1ST_TD_EN :1;              /* '0': disable the context storage, '1': enable the context storage for a flag to identify a DMA request as the first of TD DMA request. */
        uint32_t USE_EMPTY_4TTE_OVERLAP :1;      /* '0': Enable XFER engine to use a no-pending response flag as a way of identifying a TTE overlap condition, '1': Enable XFER engine to use context empty flag not assert as a way of identifying a TTE overlap condition. */
        uint32_t SETADDR_OVERRIDE :1;            /* '0': Disable the address device command to query a port credit before it is executed in ODMA engine, '1': Enable the address device command to query a port credit before it is executed in ODMA engine. */
        uint32_t FC_ON_2INCOMPLET_EN :1;         /* '0': do not enable this function. '1': assert the sch_req_incomplete signal in XFER engine when a context FC is ON. This is an internal safety feature for XFER engine. */
        uint32_t PKT_BNDRY_2IGNORE_NTRB_EN :1;   /* '0': Disable this function. '1': Enable a packet pace function under a special condition. This is an internal feature of XFER engine. It is not expected to be used other than default. */
        uint32_t SUPPORT_0LEN_TTE_EN :1;         /* '0': Disable this function. '1': Enable the function to support 0length TTE second phase request from TTE module. */
        uint32_t TRM_ADV_DETECT_EN :1;           /* '0': Disable this function in XFER engine. '1': Enable the XFER engine to auto detecting a missing service interval function when there is a long delay such that we missed a service interval due to the pending response. Note: Only value of '0' is validated. */
        uint32_t STREAM_ID_MATCH_EN :1;          /* stream_id_match_en */
        uint32_t STREAM_IDLE2PRIME_EN :1;        /* Enable the host to transfer to the prime-pipe state (and transmit a prime pipe) on each transfer back to the IDLE state. '0': Feature disabled, '1': Feature enabled. Note: Used only when an endpoint is configured for stream operation. */
        uint32_t DISABLE_CPL_SST_IDEQ0_ERR :1;   /* '0': Report received stream ID of 0x0000 as an error. '1': Disable the error reporting for a received stream ID value of 0x0000. Note: only used when an endpoint is configured for stream operation. */
        uint32_t RPORT_CRD_CHECK_DIS :1;         /* The xHC engine has a feature that can check with Receive Port Credit per root port to whether or not allow the next schedule onto this port (disable the RPORT credit check for IDMA). This is for performance enhancement. '0': Enables this feature, '1': Disables this feature. */
        uint32_t ODMA_CRD_CAL_EN :1;             /* New feature added to prevent the back-pressure from ODMA due to the fact that it ran out of ODMA timeout timer resources. This is for performance enhancement. We have put into the ODMA credit is part of resource calculation before TRM allows the next scheduling for OUT EP. '0': Disables this feature, '1': Enables this feature. */
        uint32_t SKIP_INTR_4RESP_EN :1;          /* This bit enables a feature where xHC engine will skip a service interval when an Interrupt EP has missed its service interval. '0': Disables this feature, '1': Enables to skip a service interval. */
        uint32_t MSI_CNT_EN  :1;                 /* This bit enables the new Missing service interval detection mechanism. xHC engine will count how many service interval that it missed, and skip over that many TDs. '0': Disables this feature, '1': Enables this feature. */
        uint32_t ENT_AT_END_OF_TD_EN :1;         /* This bit enables xHC engine to evaluate the next TRB even if the EP is at the end of a TD. '0': Disables this feature, '1': Enables this feature. */
        uint32_t MULTI_NON0_CTRL_EP_EN :1;       /* This bit enables the xHC engine to fully support the non-0 control EP. This bit allows the xHC TRM to keep track of on non-0 control EP per port so that the responses can be routed to the correct DMA engine. '0': Disables this feature, '1': Enables this feature. */
        uint32_t DEADLOCK_TRB_ERR_EN :1;         /* This bit enables an internally detected deadlock situation being treated as an TRB_ERR when reports the event. This is an internal debug function. '0': Disables this feature, '1': Enables this feature. */
        uint32_t DEV_MBS_CAP_EN :1;              /* This bit enables a new feature where the completion engine of TRM can check the credit returned from remote device to not excceed its max burst size. If it does, we will keep the internal credits in the context to the max burst size so that xHC engine will not transmit more than max burst size. Note: CB has this bit default set to '0'; PPT B0 and LPT will have this bit set to'1'. '0': Disables this feature, '1': Enables this feature. */
        uint32_t SECOND_EVENT_FOR_ISP_EN :1;     /* This bit enables xHC engine TRM to report the second or more events on an ISP flush on a second or more TRBs with ISP bit set that are flushed for a short packet response received. '0': Disables this feature, '1': Enables this feature. */
        uint32_t STOP_2MS_4TTE_EN :1;            /* This bit enables a 2ms timeout for all TTE related EP stop endpoint command. The xHC engine will not check whether there is a pending response in context. It will only wait for 2ms and indicates that EP has been stopped. '0': Disabled, '1': Enabled. */
        uint32_t DOUBLE_CLR_MASK_DIS :1;         /* This bit is added for bug FR2283. This is to ensure only one clear pulse generated when a completion has received (disable CPL engine from sending multiple clear). '0': Disabled, '1': Enabled. */
        uint32_t IGNORE_NPKT_4PRDC :1;           /* This bit is added for bug FR2333 where the xHC engine has always ignored the credit returned from device for its OUT EP buffers when the EP is a periodic EP. '0': Enable the xHC engine to follow the flow control, '1': Disable this feature. */
        uint32_t TTE_IN_EP_BLOCK_EN :1;          /* This bit is added for bug FR2395. It disables the single IN EP for TTE function. '0': Disabled, '1': Allow only single IN EP per port for TTE. */
        uint32_t TTE_PKT_BNDRY_EXIT :1;          /* This bit is added for bug FR2446. It is to enable TRM to only send one IN request for TTE 1st phase request even if it has not reached the packet boundary. '0': Disabled, '1': Enabled */
        uint32_t TRM_ODMA_FIFO_DISABLE :1;       /* This bit disables a new feature where xHC engine will have an ODMA FIFO added for the commands between TRM and ODMA; so that we can avoid the back-pressure situation due to the number of outstanding PCIe read limitation. This is for performance enhancement. '0': Enables this feature, '1': Disables this feature. */
        uint32_t ERR_CPL_CODE_STORE_EN :1;       /* This bit is added for bug FR2495. It enables that error completion code of the first error condition detected within an TD; so that we can report the same error completion codes for all other TRBs within this TD. '0': disabled '1': enables the feature */
        uint32_t NON_DMA_IMD_EN :1;              /* This bit is added for bug FR2639. It enables the internal functions where xHC engine needs to immediately serve the EP again. '0': disabled '1': enabled */
        uint32_t PKT_BNDRY_BLOCK_HALT_EN :1;     /* This bit is added for bug FR2642. It is to delay the completion engine to generate an event due to internal error conditions that halted an EP until XFER engine has reached a packet boundary. '0': Disabled '1': Enabled */
        uint32_t INSERT_CPL_IDMA_WAIT_EN :1;     /* This bit is added for bug FR2601. It is for cache invalidate case where xHC engine needs to insert wait states for completion engine when the completion has received a short packet before XFER engine has finished the TRB fetch for this packet at its packet boundary. '0': Disables the feature, '1': Enables the feature */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_t;

/* Register XECP_HOST_CTRL_TRM_REG2 - Host Control Transfer Manager (TRM) register. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_OFFSET 0x18150
/* Field RESERVE_TRB_EN - '0': report TRB ERR for reserved TRB type, '1': enable XFER engine to process a reserved TRB type as a NO-OP TRB. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_RESERVE_TRB_EN_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_RESERVE_TRB_EN_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_RESERVE_TRB_EN(v) (((v) << 0) & 0x1)
/* Field ISO_CNT_2NODMA_EN - '0': Disable this non DMA TRB detect function '1': Enable the function where XFER engine uses the remaining burst count as an indication that the next TRB on the transfer ring for an ISO TD is either link TRB or event data TRB. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ISO_CNT_2NODMA_EN_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ISO_CNT_2NODMA_EN_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ISO_CNT_2NODMA_EN(v) (((v) << 0x1) & 0x2)
/* Field UPORT_CRD_UPD_EN - '0': Disable the credit redeem, '1': Enable the credit redeem when a port is in NC state. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_UPORT_CRD_UPD_EN_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_UPORT_CRD_UPD_EN_MASK 0x4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_UPORT_CRD_UPD_EN(v) (((v) << 0x2) & 0x4)
/* Field CNTX_1ST_TD_EN - '0': disable the context storage, '1': enable the context storage for a flag to identify a DMA request as the first of TD DMA request. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_CNTX_1ST_TD_EN_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_CNTX_1ST_TD_EN_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_CNTX_1ST_TD_EN(v) (((v) << 0x3) & 0x8)
/* Field USE_EMPTY_4TTE_OVERLAP - '0': Enable XFER engine to use a no-pending response flag as a way of identifying a TTE overlap condition, '1': Enable XFER engine to use context empty flag not assert as a way of identifying a TTE overlap condition. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_USE_EMPTY_4TTE_OVERLAP_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_USE_EMPTY_4TTE_OVERLAP_MASK 0x10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_USE_EMPTY_4TTE_OVERLAP(v) (((v) << 0x4) & 0x10)
/* Field SETADDR_OVERRIDE - '0': Disable the address device command to query a port credit before it is executed in ODMA engine, '1': Enable the address device command to query a port credit before it is executed in ODMA engine. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SETADDR_OVERRIDE_SHIFT 5
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SETADDR_OVERRIDE_MASK 0x20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SETADDR_OVERRIDE(v) (((v) << 0x5) & 0x20)
/* Field FC_ON_2INCOMPLET_EN - '0': do not enable this function. '1': assert the sch_req_incomplete signal in XFER engine when a context FC is ON. This is an internal safety feature for XFER engine. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_FC_ON_2INCOMPLET_EN_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_FC_ON_2INCOMPLET_EN_MASK 0x40
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_FC_ON_2INCOMPLET_EN(v) (((v) << 0x6) & 0x40)
/* Field PKT_BNDRY_2IGNORE_NTRB_EN - '0': Disable this function. '1': Enable a packet pace function under a special condition. This is an internal feature of XFER engine. It is not expected to be used other than default. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_PKT_BNDRY_2IGNORE_NTRB_EN_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_PKT_BNDRY_2IGNORE_NTRB_EN_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_PKT_BNDRY_2IGNORE_NTRB_EN(v) (((v) << 0x7) & 0x80)
/* Field SUPPORT_0LEN_TTE_EN - '0': Disable this function. '1': Enable the function to support 0length TTE second phase request from TTE module. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SUPPORT_0LEN_TTE_EN_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SUPPORT_0LEN_TTE_EN_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SUPPORT_0LEN_TTE_EN(v) (((v) << 0x8) & 0x100)
/* Field TRM_ADV_DETECT_EN - '0': Disable this function in XFER engine. '1': Enable the XFER engine to auto detecting a missing service interval function when there is a long delay such that we missed a service interval due to the pending response. Note: Only value of '0' is validated. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TRM_ADV_DETECT_EN_SHIFT 9
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TRM_ADV_DETECT_EN_MASK 0x200
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TRM_ADV_DETECT_EN(v) (((v) << 0x9) & 0x200)
/* Field STREAM_ID_MATCH_EN - stream_id_match_en */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STREAM_ID_MATCH_EN_SHIFT 10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STREAM_ID_MATCH_EN_MASK 0x400
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STREAM_ID_MATCH_EN(v) (((v) << 0xA) & 0x400)
/* Field STREAM_IDLE2PRIME_EN - Enable the host to transfer to the prime-pipe state (and transmit a prime pipe) on each transfer back to the IDLE state. '0': Feature disabled, '1': Feature enabled. Note: Used only when an endpoint is configured for stream operation. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STREAM_IDLE2PRIME_EN_SHIFT 11
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STREAM_IDLE2PRIME_EN_MASK 0x800
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STREAM_IDLE2PRIME_EN(v) (((v) << 0xB) & 0x800)
/* Field DISABLE_CPL_SST_IDEQ0_ERR - '0': Report received stream ID of 0x0000 as an error. '1': Disable the error reporting for a received stream ID value of 0x0000. Note: only used when an endpoint is configured for stream operation. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DISABLE_CPL_SST_IDEQ0_ERR_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DISABLE_CPL_SST_IDEQ0_ERR_MASK 0x1000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DISABLE_CPL_SST_IDEQ0_ERR(v) (((v) << 0xC) & 0x1000)
/* Field RPORT_CRD_CHECK_DIS - The xHC engine has a feature that can check with Receive Port Credit per root port to whether or not allow the next schedule onto this port (disable the RPORT credit check for IDMA). This is for performance enhancement. '0': Enables this feature, '1': Disables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_RPORT_CRD_CHECK_DIS_SHIFT 13
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_RPORT_CRD_CHECK_DIS_MASK 0x2000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_RPORT_CRD_CHECK_DIS(v) (((v) << 0xD) & 0x2000)
/* Field ODMA_CRD_CAL_EN - New feature added to prevent the back-pressure from ODMA due to the fact that it ran out of ODMA timeout timer resources. This is for performance enhancement. We have put into the ODMA credit is part of resource calculation before TRM allows the next scheduling for OUT EP. '0': Disables this feature, '1': Enables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ODMA_CRD_CAL_EN_SHIFT 14
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ODMA_CRD_CAL_EN_MASK 0x4000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ODMA_CRD_CAL_EN(v) (((v) << 0xE) & 0x4000)
/* Field SKIP_INTR_4RESP_EN - This bit enables a feature where xHC engine will skip a service interval when an Interrupt EP has missed its service interval. '0': Disables this feature, '1': Enables to skip a service interval. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SKIP_INTR_4RESP_EN_SHIFT 15
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SKIP_INTR_4RESP_EN_MASK 0x8000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SKIP_INTR_4RESP_EN(v) (((v) << 0xF) & 0x8000)
/* Field MSI_CNT_EN - This bit enables the new Missing service interval detection mechanism. xHC engine will count how many service interval that it missed, and skip over that many TDs. '0': Disables this feature, '1': Enables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_MSI_CNT_EN_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_MSI_CNT_EN_MASK 0x10000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_MSI_CNT_EN(v) (((v) << 0x10) & 0x10000)
/* Field ENT_AT_END_OF_TD_EN - This bit enables xHC engine to evaluate the next TRB even if the EP is at the end of a TD. '0': Disables this feature, '1': Enables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ENT_AT_END_OF_TD_EN_SHIFT 17
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ENT_AT_END_OF_TD_EN_MASK 0x20000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ENT_AT_END_OF_TD_EN(v) (((v) << 0x11) & 0x20000)
/* Field MULTI_NON0_CTRL_EP_EN - This bit enables the xHC engine to fully support the non-0 control EP. This bit allows the xHC TRM to keep track of on non-0 control EP per port so that the responses can be routed to the correct DMA engine. '0': Disables this feature, '1': Enables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_MULTI_NON0_CTRL_EP_EN_SHIFT 18
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_MULTI_NON0_CTRL_EP_EN_MASK 0x40000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_MULTI_NON0_CTRL_EP_EN(v) (((v) << 0x12) & 0x40000)
/* Field DEADLOCK_TRB_ERR_EN - This bit enables an internally detected deadlock situation being treated as an TRB_ERR when reports the event. This is an internal debug function. '0': Disables this feature, '1': Enables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DEADLOCK_TRB_ERR_EN_SHIFT 19
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DEADLOCK_TRB_ERR_EN_MASK 0x80000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DEADLOCK_TRB_ERR_EN(v) (((v) << 0x13) & 0x80000)
/* Field DEV_MBS_CAP_EN - This bit enables a new feature where the completion engine of TRM can check the credit returned from remote device to not excceed its max burst size. If it does, we will keep the internal credits in the context to the max burst size so that xHC engine will not transmit more than max burst size. Note: CB has this bit default set to '0'; PPT B0 and LPT will have this bit set to'1'. '0': Disables this feature, '1': Enables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DEV_MBS_CAP_EN_SHIFT 20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DEV_MBS_CAP_EN_MASK 0x100000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DEV_MBS_CAP_EN(v) (((v) << 0x14) & 0x100000)
/* Field SECOND_EVENT_FOR_ISP_EN - This bit enables xHC engine TRM to report the second or more events on an ISP flush on a second or more TRBs with ISP bit set that are flushed for a short packet response received. '0': Disables this feature, '1': Enables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SECOND_EVENT_FOR_ISP_EN_SHIFT 21
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SECOND_EVENT_FOR_ISP_EN_MASK 0x200000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_SECOND_EVENT_FOR_ISP_EN(v) (((v) << 0x15) & 0x200000)
/* Field STOP_2MS_4TTE_EN - This bit enables a 2ms timeout for all TTE related EP stop endpoint command. The xHC engine will not check whether there is a pending response in context. It will only wait for 2ms and indicates that EP has been stopped. '0': Disabled, '1': Enabled. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STOP_2MS_4TTE_EN_SHIFT 22
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STOP_2MS_4TTE_EN_MASK 0x400000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_STOP_2MS_4TTE_EN(v) (((v) << 0x16) & 0x400000)
/* Field DOUBLE_CLR_MASK_DIS - This bit is added for bug FR2283. This is to ensure only one clear pulse generated when a completion has received (disable CPL engine from sending multiple clear). '0': Disabled, '1': Enabled. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DOUBLE_CLR_MASK_DIS_SHIFT 23
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DOUBLE_CLR_MASK_DIS_MASK 0x800000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_DOUBLE_CLR_MASK_DIS(v) (((v) << 0x17) & 0x800000)
/* Field IGNORE_NPKT_4PRDC - This bit is added for bug FR2333 where the xHC engine has always ignored the credit returned from device for its OUT EP buffers when the EP is a periodic EP. '0': Enable the xHC engine to follow the flow control, '1': Disable this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_IGNORE_NPKT_4PRDC_SHIFT 24
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_IGNORE_NPKT_4PRDC_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_IGNORE_NPKT_4PRDC(v) (((v) << 0x18) & 0x1000000)
/* Field TTE_IN_EP_BLOCK_EN - This bit is added for bug FR2395. It disables the single IN EP for TTE function. '0': Disabled, '1': Allow only single IN EP per port for TTE. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TTE_IN_EP_BLOCK_EN_SHIFT 25
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TTE_IN_EP_BLOCK_EN_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TTE_IN_EP_BLOCK_EN(v) (((v) << 0x19) & 0x2000000)
/* Field TTE_PKT_BNDRY_EXIT - This bit is added for bug FR2446. It is to enable TRM to only send one IN request for TTE 1st phase request even if it has not reached the packet boundary. '0': Disabled, '1': Enabled */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TTE_PKT_BNDRY_EXIT_SHIFT 26
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TTE_PKT_BNDRY_EXIT_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TTE_PKT_BNDRY_EXIT(v) (((v) << 0x1A) & 0x4000000)
/* Field TRM_ODMA_FIFO_DISABLE - This bit disables a new feature where xHC engine will have an ODMA FIFO added for the commands between TRM and ODMA; so that we can avoid the back-pressure situation due to the number of outstanding PCIe read limitation. This is for performance enhancement. '0': Enables this feature, '1': Disables this feature. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TRM_ODMA_FIFO_DISABLE_SHIFT 27
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TRM_ODMA_FIFO_DISABLE_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_TRM_ODMA_FIFO_DISABLE(v) (((v) << 0x1B) & 0x8000000)
/* Field ERR_CPL_CODE_STORE_EN - This bit is added for bug FR2495. It enables that error completion code of the first error condition detected within an TD; so that we can report the same error completion codes for all other TRBs within this TD. '0': disabled '1': enables the feature */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ERR_CPL_CODE_STORE_EN_SHIFT 28
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ERR_CPL_CODE_STORE_EN_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_ERR_CPL_CODE_STORE_EN(v) (((v) << 0x1C) & 0x10000000)
/* Field NON_DMA_IMD_EN - This bit is added for bug FR2639. It enables the internal functions where xHC engine needs to immediately serve the EP again. '0': disabled '1': enabled */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_NON_DMA_IMD_EN_SHIFT 29
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_NON_DMA_IMD_EN_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_NON_DMA_IMD_EN(v) (((v) << 0x1D) & 0x20000000)
/* Field PKT_BNDRY_BLOCK_HALT_EN - This bit is added for bug FR2642. It is to delay the completion engine to generate an event due to internal error conditions that halted an EP until XFER engine has reached a packet boundary. '0': Disabled '1': Enabled */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_PKT_BNDRY_BLOCK_HALT_EN_SHIFT 30
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_PKT_BNDRY_BLOCK_HALT_EN_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_PKT_BNDRY_BLOCK_HALT_EN(v) (((v) << 0x1E) & 0x40000000)
/* Field INSERT_CPL_IDMA_WAIT_EN - This bit is added for bug FR2601. It is for cache invalidate case where xHC engine needs to insert wait states for completion engine when the completion has received a short packet before XFER engine has finished the TRB fetch for this packet at its packet boundary. '0': Disables the feature, '1': Enables the feature */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_INSERT_CPL_IDMA_WAIT_EN_SHIFT 31
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_INSERT_CPL_IDMA_WAIT_EN_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_INSERT_CPL_IDMA_WAIT_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX1_REG - HOST_CTRL_BW_MAX1_REG. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX1_REG_union_t {
    uint32_t R;
    struct {
        uint32_t BW_MAX_REG31_0 :32;             /* bw_max_reg[31:0] */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX1_REG_t;

/* Register XECP_HOST_CTRL_BW_MAX1_REG - HOST_CTRL_BW_MAX1_REG. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX1_REG_OFFSET 0x18168
/* Field BW_MAX_REG31_0 - bw_max_reg[31:0] */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX1_REG_BW_MAX_REG31_0_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX1_REG_BW_MAX_REG31_0_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX1_REG_BW_MAX_REG31_0(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX2_REG - HOST_CTRL_BW_MAX2_REG. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX2_REG_union_t {
    uint32_t R;
    struct {
        uint32_t BW_MAX_REG59_32 :28;            /* bw_max_reg[59:32] */
        uint32_t _unused28   :4;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX2_REG_t;

/* Register XECP_HOST_CTRL_BW_MAX2_REG - HOST_CTRL_BW_MAX2_REG. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX2_REG_OFFSET 0x1816C
/* Field BW_MAX_REG59_32 - bw_max_reg[59:32] */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX2_REG_BW_MAX_REG59_32_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX2_REG_BW_MAX_REG59_32_MASK 0xFFFFFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX2_REG_BW_MAX_REG59_32(v) (((v) << 0) & 0xFFFFFFF)

/* IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG - USB2_LINESTATE_REG. */
typedef union IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_union_t {
    uint32_t R;
    struct {
        uint32_t UTMI_LINESTATE :8;              /* utmi_linestate */
        uint32_t PDOWN_STATUS :16;               /* pdown_status */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_t;

/* Register XECP_USB2_LINESTATE_REG - USB2_LINESTATE_REG. */
#define IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_OFFSET 0x18170
/* Field UTMI_LINESTATE - utmi_linestate */
#define IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_UTMI_LINESTATE_SHIFT 0
#define IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_UTMI_LINESTATE_MASK 0xFF
#define IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_UTMI_LINESTATE(v) (((v) << 0) & 0xFF)
/* Field PDOWN_STATUS - pdown_status */
#define IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_PDOWN_STATUS_SHIFT 8
#define IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_PDOWN_STATUS_MASK 0xFFFF00
#define IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_PDOWN_STATUS(v) (((v) << 0x8) & 0xFFFF00)

/* IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG - HOST_PROTO_GAP_TIMER1_REG. */
typedef union IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_union_t {
    uint32_t R;
    struct {
        uint32_t USB2_PROTO_PKT_GAP_HS :8;       /* USB2_PROTO_PKT_GAP_HS */
        uint32_t USB2_PROTO_PKT_GAP_HS_SOF :8;   /* USB2_PROTO_PKT_GAP_HS_SOF */
        uint32_t USB2_PROTO_PKT_GAP_HS_RX :8;    /* USB2_PROTO_PKT_GAP_HS_RX */
        uint32_t USB2_PROTO_PKT_GAP_FS :8;       /* USB2_PROTO_PKT_GAP_FS */
    } B;
} IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_t;

/* Register XECP_HOST_PROTO_GAP_TIMER1_REG - HOST_PROTO_GAP_TIMER1_REG. */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_OFFSET 0x18174
/* Field USB2_PROTO_PKT_GAP_HS - USB2_PROTO_PKT_GAP_HS */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS_MASK 0xFF
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS(v) (((v) << 0) & 0xFF)
/* Field USB2_PROTO_PKT_GAP_HS_SOF - USB2_PROTO_PKT_GAP_HS_SOF */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS_SOF_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS_SOF_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS_SOF(v) (((v) << 0x8) & 0xFF00)
/* Field USB2_PROTO_PKT_GAP_HS_RX - USB2_PROTO_PKT_GAP_HS_RX */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS_RX_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS_RX_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_HS_RX(v) (((v) << 0x10) & 0xFF0000)
/* Field USB2_PROTO_PKT_GAP_FS - USB2_PROTO_PKT_GAP_FS */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_FS_SHIFT 24
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_FS_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_USB2_PROTO_PKT_GAP_FS(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG - HOST_PROTO_GAP_TIMER2_REG. */
typedef union IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_union_t {
    uint32_t R;
    struct {
        uint32_t USB2_PROTO_PKT_GAP_LS :8;       /* USB2_PROTO_PKT_GAP_LS */
        uint32_t USB2_PROTO_PKT_GAP_LS_HRX :8;   /* USB2_PROTO_PKT_GAP_LS_HRX */
        uint32_t USB2_PROTO_PKT_GAP_LS_HTX :8;   /* USB2_PROTO_PKT_GAP_LS_HTX */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_t;

/* Register XECP_HOST_PROTO_GAP_TIMER2_REG - HOST_PROTO_GAP_TIMER2_REG. */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_OFFSET 0x18178
/* Field USB2_PROTO_PKT_GAP_LS - USB2_PROTO_PKT_GAP_LS */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS_MASK 0xFF
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS(v) (((v) << 0) & 0xFF)
/* Field USB2_PROTO_PKT_GAP_LS_HRX - USB2_PROTO_PKT_GAP_LS_HRX */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS_HRX_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS_HRX_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS_HRX(v) (((v) << 0x8) & 0xFF00)
/* Field USB2_PROTO_PKT_GAP_LS_HTX - USB2_PROTO_PKT_GAP_LS_HTX */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS_HTX_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS_HTX_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_USB2_PROTO_PKT_GAP_LS_HTX(v) (((v) << 0x10) & 0xFF0000)

/* IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG - HOST_PROTO_BTO_TIMER_REG. */
typedef union IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_union_t {
    uint32_t R;
    struct {
        uint32_t USB2_PROTO_BTO_HS :10;          /* USB2_PROTO_BTO_HS */
        uint32_t USB2_PROTO_BTO_FS :11;          /* USB2_PROTO_BTO_FS */
        uint32_t USB2_PROTO_BTO_LS :11;          /* USB2_PROTO_BTO_LS */
    } B;
} IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_t;

/* Register XECP_HOST_PROTO_BTO_TIMER_REG - HOST_PROTO_BTO_TIMER_REG. */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_OFFSET 0x1817C
/* Field USB2_PROTO_BTO_HS - USB2_PROTO_BTO_HS */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_HS_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_HS_MASK 0x3FF
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_HS(v) (((v) << 0) & 0x3FF)
/* Field USB2_PROTO_BTO_FS - USB2_PROTO_BTO_FS */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_FS_SHIFT 10
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_FS_MASK 0x1FFC00
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_FS(v) (((v) << 0xA) & 0x1FFC00)
/* Field USB2_PROTO_BTO_LS - USB2_PROTO_BTO_LS */
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_LS_SHIFT 21
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_LS_MASK 0xFFE00000
#define IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_USB2_PROTO_BTO_LS(v) (((v) << 0x15) & 0xFFE00000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH_REG - HOST_CTRL_PSCH_REG. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH_REG_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :24;                /* Reserved field, RW */
        uint32_t PSCH_HOST_CTRL_REG_I_31_24 :8;  /* PSCH_HOST_CTRL_REG_I_31_24 */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH_REG_t;

/* Register XECP_HOST_CTRL_PSCH_REG - HOST_CTRL_PSCH_REG. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH_REG_OFFSET 0x18180
/* Field PSCH_HOST_CTRL_REG_I_31_24 - PSCH_HOST_CTRL_REG_I_31_24 */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH_REG_PSCH_HOST_CTRL_REG_I_31_24_SHIFT 24
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH_REG_PSCH_HOST_CTRL_REG_I_31_24_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH_REG_PSCH_HOST_CTRL_REG_I_31_24(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH1_REG - HOST_CTRL_PSCH1_REG. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH1_REG_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :10;                /* Reserved field, RW */
        uint32_t IDLE_SCALE  :2;                 /* PSCH_HOST_CTRL_REG_I_43_42. idle_scale. 0=1c ; 1=1us; 2=125us */
        uint32_t _unused12   :4;                 /* Reserved field, RW */
        uint32_t _unused16   :16;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH1_REG_t;

/* Register XECP_HOST_CTRL_PSCH1_REG - HOST_CTRL_PSCH1_REG. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH1_REG_OFFSET 0x18184
/* Field IDLE_SCALE - PSCH_HOST_CTRL_REG_I_43_42. idle_scale. 0=1c ; 1=1us; 2=125us */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH1_REG_IDLE_SCALE_SHIFT 10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH1_REG_IDLE_SCALE_MASK 0xC00
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH1_REG_IDLE_SCALE(v) (((v) << 0xA) & 0xC00)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG - HOST_CTRL_LTM_REG. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG_union_t {
    uint32_t R;
    struct {
        uint32_t BELT_SELECTED :12;              /* Reports several of the latencies depending on the last programmed belt_select value: 0: LTV value programmed, 1: Lowest BELT received, 2: Last received LTM per Slot, 3: Last received LTM per Port. */
        uint32_t _unused12   :20;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG_t;

/* Register XECP_HOST_CTRL_LTM_REG - HOST_CTRL_LTM_REG. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG_OFFSET 0x18190
/* Field BELT_SELECTED - Reports several of the latencies depending on the last programmed belt_select value: 0: LTV value programmed, 1: Lowest BELT received, 2: Last received LTM per Slot, 3: Last received LTM per Port. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG_BELT_SELECTED_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG_BELT_SELECTED_MASK 0xFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG_BELT_SELECTED(v) (((v) << 0) & 0xFFF)

/* IMX_USB3_USBSS_XECP_AUX_CTRL_REG2 - AUX Power Management Control 1. */
typedef union IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_union_t {
    uint32_t R;
    struct {
        uint32_t AUTO_P2_OW_EN_REG :1;           /* This bit enables a feature where we can get P2 overwrite to automatically turned on when there is no pending traffic in the engine. '0': feature disabled, '1': feature enabled. */
        uint32_t CFG_FAST_SIMS :1;               /* This bit is for simulation modes only. It enables further reductions to simulation timings in addition to cfg_fast_training. Please refer to Integration Guide Debug Features section '0': Normal timings '1': Enable fast simulation timing modes */
        uint32_t P0_DRIVE_DIS :1;                /* This bit ensures the P1 drive during PERST#. '0': feature disabled, '1': feature enabled. */
        uint32_t IDLE_WAKEUP_EN :1;              /* This bit enables the AUX PM module to automatically wakeup from deep power down when engine has detected non-idle condition. '0': feature disabled '1': feature enabled */
        uint32_t _unused4    :5;                 /* Reserved field, RW */
        uint32_t CFG_PSCEG_SEL :1;               /* This bit selects the port status change event generation mode. '0': port status change event is only blocked by the individual status change bit. '1': port status change event is blocked until all status change bit are cleared. */
        uint32_t PRDC_PREVENT_L1_EN :1;          /* This bit enables a function that the SPNS PCIe core is controlled by xHCI engine internal periodic EP traffic conditions. '0': Disabled this function '1': Enables the xHC engine to request an exit of L1 when the service time has reached for an periodic EP. */
        uint32_t _unused11   :2;                 /* Reserved field, RW */
        uint32_t CFG_U2_P3_EN :1;                /* '0': disables PHY P3 mode in U2. '1': enables PHY P3 mode in U2. */
        uint32_t CFG_U2_P3_TIMEOUT :2;           /* This field defines the timeout value to enter P3 mode in U2. 00: 7us - 8us, 01: 511us - 512us, 10: disables the timer (0us), 11: disables the timer (0us). */
        uint32_t WAKE_EXIT_USE_LVL_EN :1;        /* This bit enables a function that AUX PM module exits from the deep sleep state due to the USB ports wakeup level signal. We have added this feature where USB ports will generate a wakeup level signal to wakeup the AUX PM module if it is in deep sleep state and this level signal will be cleared if the change bits are updated by software. '0': Disables this function, which means that a wakeup pulse generated from each USB PortSC event will wake up the AUX PM module from deep sleep if the D3 state is programmed. '1': Enables this function. */
        uint32_t CFG_U2_P3_LFPS_TIME :1;         /* This bit selects U2 exit LFPS timer value. '0': 320ns - 400ns in 25MHz domain, '1': 240ns - 320ns in 25MHz domain. */
        uint32_t U0_WAKE_TIMEOUT_EN :1;          /* This bit enables a feature in AUX PM module where if PCIe core LTSSM is in P0 for a duration of time, we will exit the deep sleep state. This is for failure control in case. '0': disable this feature, '1': enables this feature. */
        uint32_t PDOWN_2LINK_RST_EN_REG :1;      /* pdown_2link_rst_en */
        uint32_t CFG_U3_AUTO :1;                 /* '0': Disables the port to enter U3 automatically when in U1/U2, '1': Enables the port to enter U3 automatically when in U1/U2. */
        uint32_t P2_OVERWRITE_WHENL1_EN :1;      /* We have added a feature where if PCIe core LTSSM enters L1 due to the D3hot, the aux PM control will not start a P2 overwrite function in anticipating for the next L23 enter. '0': enables P2 overwrite even if we are in D3Hot. '1': disables P2 overwrite due to the D3HOT where PCIe core enters the L1. */
        uint32_t CFG_LTSSM_IDLE2TS2 :1;          /* This bit enables a feature in PCie core LTSSM to treat IDLE received as TS2 when LTSSM is in wait for TS2 receive state. This is a function requested from PHY where it is possible to not able to receive TS2 without error. '0': Disable this feature. '1': Treat Logic IDLE as TS2 received when in some PCIe LTSSM state. */
        uint32_t CFG_PSCEG_DIS_SEL :1;           /* '0': Assert PLC for disconnection, '1': Do not assert PLC for disconnection */
        uint32_t AUTO_PM_EXIT_L1_EN :1;          /* This bit enables a L1 exit notification to SNPS PCIe core. There is a case where USB ports have waked up and AUX PM module has started the wakeup process. The AUX PM control state got into a wait for P0 state because it needs to wait until PCie core to signal powerdown state change. Due to the fact that the core is in D3Hot, there is no run_stop bit set such that no internal interrupt will be fired. This causes the LTSSM of PCIe stayed in L1 even though AUX PM has known that it needs an L1 exit. This bit works together with bit 21 of this register. '0': Disables this feature. '1': Enables this feature */
        uint32_t CFG_DBGP_DIS_AUTO :1;           /* cfg_dbgp_dis_auto */
        uint32_t CFG_DEBOUNCE_EN :1;             /* cfg_debounce_en */
        uint32_t BATT_CHARGE_D3_EN :1;           /* batt_charge_d3_en */
        uint32_t SHADOW_DECODE_DIS :1;           /* shadow_decode_dis */
        uint32_t SNPS_PHYSTATUS_DONE_L1_DIS :1;  /* snps_phystatus_done_l1_dis */
        uint32_t SNPS_PHYSTATUS_DONE_L23_DIS :1; /* snps_phystatus_done_l23_dis */
        uint32_t UPORTS_CHANGE_DETECT_EN :1;     /* uports_change_detect_en */
    } B;
} IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_t;

/* Register XECP_AUX_CTRL_REG2 - AUX Power Management Control 1. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_OFFSET 0x18194
/* Field AUTO_P2_OW_EN_REG - This bit enables a feature where we can get P2 overwrite to automatically turned on when there is no pending traffic in the engine. '0': feature disabled, '1': feature enabled. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_AUTO_P2_OW_EN_REG_SHIFT 0
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_AUTO_P2_OW_EN_REG_MASK 0x1
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_AUTO_P2_OW_EN_REG(v) (((v) << 0) & 0x1)
/* Field CFG_FAST_SIMS - This bit is for simulation modes only. It enables further reductions to simulation timings in addition to cfg_fast_training. Please refer to Integration Guide Debug Features section '0': Normal timings '1': Enable fast simulation timing modes */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_FAST_SIMS_SHIFT 1
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_FAST_SIMS_MASK 0x2
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_FAST_SIMS(v) (((v) << 0x1) & 0x2)
/* Field P0_DRIVE_DIS - This bit ensures the P1 drive during PERST#. '0': feature disabled, '1': feature enabled. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_P0_DRIVE_DIS_SHIFT 2
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_P0_DRIVE_DIS_MASK 0x4
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_P0_DRIVE_DIS(v) (((v) << 0x2) & 0x4)
/* Field IDLE_WAKEUP_EN - This bit enables the AUX PM module to automatically wakeup from deep power down when engine has detected non-idle condition. '0': feature disabled '1': feature enabled */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_IDLE_WAKEUP_EN_SHIFT 3
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_IDLE_WAKEUP_EN_MASK 0x8
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_IDLE_WAKEUP_EN(v) (((v) << 0x3) & 0x8)
/* Field CFG_PSCEG_SEL - This bit selects the port status change event generation mode. '0': port status change event is only blocked by the individual status change bit. '1': port status change event is blocked until all status change bit are cleared. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_PSCEG_SEL_SHIFT 9
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_PSCEG_SEL_MASK 0x200
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_PSCEG_SEL(v) (((v) << 0x9) & 0x200)
/* Field PRDC_PREVENT_L1_EN - This bit enables a function that the SPNS PCIe core is controlled by xHCI engine internal periodic EP traffic conditions. '0': Disabled this function '1': Enables the xHC engine to request an exit of L1 when the service time has reached for an periodic EP. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_PRDC_PREVENT_L1_EN_SHIFT 10
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_PRDC_PREVENT_L1_EN_MASK 0x400
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_PRDC_PREVENT_L1_EN(v) (((v) << 0xA) & 0x400)
/* Field CFG_U2_P3_EN - '0': disables PHY P3 mode in U2. '1': enables PHY P3 mode in U2. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_EN_SHIFT 13
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_EN_MASK 0x2000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_EN(v) (((v) << 0xD) & 0x2000)
/* Field CFG_U2_P3_TIMEOUT - This field defines the timeout value to enter P3 mode in U2. 00: 7us - 8us, 01: 511us - 512us, 10: disables the timer (0us), 11: disables the timer (0us). */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_TIMEOUT_SHIFT 14
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_TIMEOUT_MASK 0xC000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_TIMEOUT(v) (((v) << 0xE) & 0xC000)
/* Field WAKE_EXIT_USE_LVL_EN - This bit enables a function that AUX PM module exits from the deep sleep state due to the USB ports wakeup level signal. We have added this feature where USB ports will generate a wakeup level signal to wakeup the AUX PM module if it is in deep sleep state and this level signal will be cleared if the change bits are updated by software. '0': Disables this function, which means that a wakeup pulse generated from each USB PortSC event will wake up the AUX PM module from deep sleep if the D3 state is programmed. '1': Enables this function. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_WAKE_EXIT_USE_LVL_EN_SHIFT 16
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_WAKE_EXIT_USE_LVL_EN_MASK 0x10000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_WAKE_EXIT_USE_LVL_EN(v) (((v) << 0x10) & 0x10000)
/* Field CFG_U2_P3_LFPS_TIME - This bit selects U2 exit LFPS timer value. '0': 320ns - 400ns in 25MHz domain, '1': 240ns - 320ns in 25MHz domain. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_LFPS_TIME_SHIFT 17
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_LFPS_TIME_MASK 0x20000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U2_P3_LFPS_TIME(v) (((v) << 0x11) & 0x20000)
/* Field U0_WAKE_TIMEOUT_EN - This bit enables a feature in AUX PM module where if PCIe core LTSSM is in P0 for a duration of time, we will exit the deep sleep state. This is for failure control in case. '0': disable this feature, '1': enables this feature. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_U0_WAKE_TIMEOUT_EN_SHIFT 18
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_U0_WAKE_TIMEOUT_EN_MASK 0x40000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_U0_WAKE_TIMEOUT_EN(v) (((v) << 0x12) & 0x40000)
/* Field PDOWN_2LINK_RST_EN_REG - pdown_2link_rst_en */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_PDOWN_2LINK_RST_EN_REG_SHIFT 19
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_PDOWN_2LINK_RST_EN_REG_MASK 0x80000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_PDOWN_2LINK_RST_EN_REG(v) (((v) << 0x13) & 0x80000)
/* Field CFG_U3_AUTO - '0': Disables the port to enter U3 automatically when in U1/U2, '1': Enables the port to enter U3 automatically when in U1/U2. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U3_AUTO_SHIFT 20
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U3_AUTO_MASK 0x100000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_U3_AUTO(v) (((v) << 0x14) & 0x100000)
/* Field P2_OVERWRITE_WHENL1_EN - We have added a feature where if PCIe core LTSSM enters L1 due to the D3hot, the aux PM control will not start a P2 overwrite function in anticipating for the next L23 enter. '0': enables P2 overwrite even if we are in D3Hot. '1': disables P2 overwrite due to the D3HOT where PCIe core enters the L1. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_P2_OVERWRITE_WHENL1_EN_SHIFT 21
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_P2_OVERWRITE_WHENL1_EN_MASK 0x200000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_P2_OVERWRITE_WHENL1_EN(v) (((v) << 0x15) & 0x200000)
/* Field CFG_LTSSM_IDLE2TS2 - This bit enables a feature in PCie core LTSSM to treat IDLE received as TS2 when LTSSM is in wait for TS2 receive state. This is a function requested from PHY where it is possible to not able to receive TS2 without error. '0': Disable this feature. '1': Treat Logic IDLE as TS2 received when in some PCIe LTSSM state. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_LTSSM_IDLE2TS2_SHIFT 22
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_LTSSM_IDLE2TS2_MASK 0x400000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_LTSSM_IDLE2TS2(v) (((v) << 0x16) & 0x400000)
/* Field CFG_PSCEG_DIS_SEL - '0': Assert PLC for disconnection, '1': Do not assert PLC for disconnection */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_PSCEG_DIS_SEL_SHIFT 23
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_PSCEG_DIS_SEL_MASK 0x800000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_PSCEG_DIS_SEL(v) (((v) << 0x17) & 0x800000)
/* Field AUTO_PM_EXIT_L1_EN - This bit enables a L1 exit notification to SNPS PCIe core. There is a case where USB ports have waked up and AUX PM module has started the wakeup process. The AUX PM control state got into a wait for P0 state because it needs to wait until PCie core to signal powerdown state change. Due to the fact that the core is in D3Hot, there is no run_stop bit set such that no internal interrupt will be fired. This causes the LTSSM of PCIe stayed in L1 even though AUX PM has known that it needs an L1 exit. This bit works together with bit 21 of this register. '0': Disables this feature. '1': Enables this feature */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_AUTO_PM_EXIT_L1_EN_SHIFT 24
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_AUTO_PM_EXIT_L1_EN_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_AUTO_PM_EXIT_L1_EN(v) (((v) << 0x18) & 0x1000000)
/* Field CFG_DBGP_DIS_AUTO - cfg_dbgp_dis_auto */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_DBGP_DIS_AUTO_SHIFT 25
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_DBGP_DIS_AUTO_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_DBGP_DIS_AUTO(v) (((v) << 0x19) & 0x2000000)
/* Field CFG_DEBOUNCE_EN - cfg_debounce_en */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_DEBOUNCE_EN_SHIFT 26
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_DEBOUNCE_EN_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_CFG_DEBOUNCE_EN(v) (((v) << 0x1A) & 0x4000000)
/* Field BATT_CHARGE_D3_EN - batt_charge_d3_en */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_BATT_CHARGE_D3_EN_SHIFT 27
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_BATT_CHARGE_D3_EN_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_BATT_CHARGE_D3_EN(v) (((v) << 0x1B) & 0x8000000)
/* Field SHADOW_DECODE_DIS - shadow_decode_dis */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SHADOW_DECODE_DIS_SHIFT 28
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SHADOW_DECODE_DIS_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SHADOW_DECODE_DIS(v) (((v) << 0x1C) & 0x10000000)
/* Field SNPS_PHYSTATUS_DONE_L1_DIS - snps_phystatus_done_l1_dis */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SNPS_PHYSTATUS_DONE_L1_DIS_SHIFT 29
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SNPS_PHYSTATUS_DONE_L1_DIS_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SNPS_PHYSTATUS_DONE_L1_DIS(v) (((v) << 0x1D) & 0x20000000)
/* Field SNPS_PHYSTATUS_DONE_L23_DIS - snps_phystatus_done_l23_dis */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SNPS_PHYSTATUS_DONE_L23_DIS_SHIFT 30
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SNPS_PHYSTATUS_DONE_L23_DIS_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_SNPS_PHYSTATUS_DONE_L23_DIS(v) (((v) << 0x1E) & 0x40000000)
/* Field UPORTS_CHANGE_DETECT_EN - uports_change_detect_en */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_UPORTS_CHANGE_DETECT_EN_SHIFT 31
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_UPORTS_CHANGE_DETECT_EN_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_UPORTS_CHANGE_DETECT_EN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_AUX_CTRL_REG3 - Configuration bits for USB2 PHY. */
typedef union IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_union_t {
    uint32_t R;
    struct {
        uint32_t PHY_MISC_CTRL_REG_1_0 :2;       /* phy_misc_ctrl_reg[1:0] */
        uint32_t PHY_MISC_CTRL_REG_4_2 :3;       /* phy_misc_ctrl_reg[4:2] */
        uint32_t STA         :3;                 /* Squelch Threshold Adjustment */
        uint32_t TRANS_HS_CROSS_ADJ :2;          /* Transmitter High-Speed Crossover Adjustment */
        uint32_t HS_TRANS_RS_TIME_ADJ :1;        /* HS Transmitter Rise/Fall Time Adjustment */
        uint32_t HS_TRANS_PRE_EMPH_EN :1;        /* HS Transmitter Pre-Emphasis Enable */
        uint32_t FSLS_SRC_IMPD_ADJ :4;           /* FS/LS Source Impedance Adjustment */
        uint32_t HS_DC_V_LVL_ADJ :4;             /* HS DC Voltage Level Adjustment */
        uint32_t _unused20   :12;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_t;

/* Register XECP_AUX_CTRL_REG3 - Configuration bits for USB2 PHY. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_OFFSET 0x18198
/* Field PHY_MISC_CTRL_REG_1_0 - phy_misc_ctrl_reg[1:0] */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_PHY_MISC_CTRL_REG_1_0_SHIFT 0
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_PHY_MISC_CTRL_REG_1_0_MASK 0x3
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_PHY_MISC_CTRL_REG_1_0(v) (((v) << 0) & 0x3)
/* Field PHY_MISC_CTRL_REG_4_2 - phy_misc_ctrl_reg[4:2] */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_PHY_MISC_CTRL_REG_4_2_SHIFT 2
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_PHY_MISC_CTRL_REG_4_2_MASK 0x1C
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_PHY_MISC_CTRL_REG_4_2(v) (((v) << 0x2) & 0x1C)
/* Field STA - Squelch Threshold Adjustment */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_STA_SHIFT 5
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_STA_MASK 0xE0
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_STA(v) (((v) << 0x5) & 0xE0)
/* Field TRANS_HS_CROSS_ADJ - Transmitter High-Speed Crossover Adjustment */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_TRANS_HS_CROSS_ADJ_SHIFT 8
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_TRANS_HS_CROSS_ADJ_MASK 0x300
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_TRANS_HS_CROSS_ADJ(v) (((v) << 0x8) & 0x300)
/* Field HS_TRANS_RS_TIME_ADJ - HS Transmitter Rise/Fall Time Adjustment */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_TRANS_RS_TIME_ADJ_SHIFT 10
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_TRANS_RS_TIME_ADJ_MASK 0x400
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_TRANS_RS_TIME_ADJ(v) (((v) << 0xA) & 0x400)
/* Field HS_TRANS_PRE_EMPH_EN - HS Transmitter Pre-Emphasis Enable */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_TRANS_PRE_EMPH_EN_SHIFT 11
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_TRANS_PRE_EMPH_EN_MASK 0x800
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_TRANS_PRE_EMPH_EN(v) (((v) << 0xB) & 0x800)
/* Field FSLS_SRC_IMPD_ADJ - FS/LS Source Impedance Adjustment */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_FSLS_SRC_IMPD_ADJ_SHIFT 12
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_FSLS_SRC_IMPD_ADJ_MASK 0xF000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_FSLS_SRC_IMPD_ADJ(v) (((v) << 0xC) & 0xF000)
/* Field HS_DC_V_LVL_ADJ - HS DC Voltage Level Adjustment */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_DC_V_LVL_ADJ_SHIFT 16
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_DC_V_LVL_ADJ_MASK 0xF0000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_HS_DC_V_LVL_ADJ(v) (((v) << 0x10) & 0xF0000)

/* IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG - DEBUG_CTRL_REG. */
typedef union IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_union_t {
    uint32_t R;
    struct {
        uint32_t DEBUG_MODE_SEL :5;              /* debug_mode_sel */
        uint32_t DEBUG_FINE_MODE_SEL :2;         /* debug_fine_mode_sel */
        uint32_t DEBUG_EN_TOGGLE :1;             /* debug control for CoosBay: debug_en_toggle */
        uint32_t PORT_PWR_CTRL_TOGGLE :1;        /* debug control for CoosBay: port_pwr_ctrl_toggle */
        uint32_t SW_EEPROM_EN :1;                /* debug control for CoosBay: sw_eeprom_en */
        uint32_t _unused10   :4;                 /* Reserved field, RW */
        uint32_t CFG_RESUME_TIMER_EN :1;         /* cfg_resume_timer_en */
        uint32_t CFG_RESUME_WAKE_DIS :1;         /* cfg_resume_wake_dis */
        uint32_t CFG_PM_DEBUG_CTRL :4;           /* cfg_pm_debug_ctrl. Used in aux_power_logic.v for debug. */
        uint32_t NEW_NB_CTRL_REG :5;             /* new_nb_ctrl_reg. Used in aux_pm module to keep old NB behavior. */
        uint32_t CFG_L1_L0S_CTRL :4;             /* cfg_l1_l0s_ctrl[3:0] */
        uint32_t CFG_PCIE_GASKET_CTRL :3;        /* cfg_pcie_gasket_ctrl[2:0] */
    } B;
} IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_t;

/* Register XECP_DEBUG_CTRL_REG - DEBUG_CTRL_REG. */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_OFFSET 0x1819C
/* Field DEBUG_MODE_SEL - debug_mode_sel */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_MODE_SEL_SHIFT 0
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_MODE_SEL_MASK 0x1F
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_MODE_SEL(v) (((v) << 0) & 0x1F)
/* Field DEBUG_FINE_MODE_SEL - debug_fine_mode_sel */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_FINE_MODE_SEL_SHIFT 5
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_FINE_MODE_SEL_MASK 0x60
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_FINE_MODE_SEL(v) (((v) << 0x5) & 0x60)
/* Field DEBUG_EN_TOGGLE - debug control for CoosBay: debug_en_toggle */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_EN_TOGGLE_SHIFT 7
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_EN_TOGGLE_MASK 0x80
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_DEBUG_EN_TOGGLE(v) (((v) << 0x7) & 0x80)
/* Field PORT_PWR_CTRL_TOGGLE - debug control for CoosBay: port_pwr_ctrl_toggle */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_PORT_PWR_CTRL_TOGGLE_SHIFT 8
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_PORT_PWR_CTRL_TOGGLE_MASK 0x100
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_PORT_PWR_CTRL_TOGGLE(v) (((v) << 0x8) & 0x100)
/* Field SW_EEPROM_EN - debug control for CoosBay: sw_eeprom_en */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_SW_EEPROM_EN_SHIFT 9
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_SW_EEPROM_EN_MASK 0x200
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_SW_EEPROM_EN(v) (((v) << 0x9) & 0x200)
/* Field CFG_RESUME_TIMER_EN - cfg_resume_timer_en */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_RESUME_TIMER_EN_SHIFT 14
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_RESUME_TIMER_EN_MASK 0x4000
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_RESUME_TIMER_EN(v) (((v) << 0xE) & 0x4000)
/* Field CFG_RESUME_WAKE_DIS - cfg_resume_wake_dis */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_RESUME_WAKE_DIS_SHIFT 15
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_RESUME_WAKE_DIS_MASK 0x8000
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_RESUME_WAKE_DIS(v) (((v) << 0xF) & 0x8000)
/* Field CFG_PM_DEBUG_CTRL - cfg_pm_debug_ctrl. Used in aux_power_logic.v for debug. */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_PM_DEBUG_CTRL_SHIFT 16
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_PM_DEBUG_CTRL_MASK 0xF0000
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_PM_DEBUG_CTRL(v) (((v) << 0x10) & 0xF0000)
/* Field NEW_NB_CTRL_REG - new_nb_ctrl_reg. Used in aux_pm module to keep old NB behavior. */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_NEW_NB_CTRL_REG_SHIFT 20
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_NEW_NB_CTRL_REG_MASK 0x1F00000
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_NEW_NB_CTRL_REG(v) (((v) << 0x14) & 0x1F00000)
/* Field CFG_L1_L0S_CTRL - cfg_l1_l0s_ctrl[3:0] */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_L1_L0S_CTRL_SHIFT 25
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_L1_L0S_CTRL_MASK 0x1E000000
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_L1_L0S_CTRL(v) (((v) << 0x19) & 0x1E000000)
/* Field CFG_PCIE_GASKET_CTRL - cfg_pcie_gasket_ctrl[2:0] */
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_PCIE_GASKET_CTRL_SHIFT 29
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_PCIE_GASKET_CTRL_MASK 0xE0000000
#define IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_CFG_PCIE_GASKET_CTRL(v) (((v) << 0x1D) & 0xE0000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2 - Host Control Scheduler. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_union_t {
    uint32_t R;
    struct {
        uint32_t SCH_PRDC_RETRY_USB2_DIS :1;     /* Host Control Scheduler: sch_prdc_retry_usb2_dis */
        uint32_t SCH_POLL_RESERVATION_DIS :1;    /* Host Control Scheduler: sch_poll_reservation_dis */
        uint32_t SCH_ALWAYS_RESERVE_DIS :1;      /* Host Control Scheduler: sch_always_reserve_dis */
        uint32_t SCH_POLL_DBRANG_DIS :1;         /* Host Control Scheduler: sch_poll_dbrang_dis */
        uint32_t _unused4    :4;                 /* Reserved field, RW */
        uint32_t SERVICE_TIME_WATERMARK :7;      /* service_time_watermark */
        uint32_t _unused15   :9;                 /* Reserved field, RW */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_t;

/* Register XECP_HOST_CTRL_SCH_REG2 - Host Control Scheduler. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_OFFSET 0x181A0
/* Field SCH_PRDC_RETRY_USB2_DIS - Host Control Scheduler: sch_prdc_retry_usb2_dis */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_PRDC_RETRY_USB2_DIS_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_PRDC_RETRY_USB2_DIS_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_PRDC_RETRY_USB2_DIS(v) (((v) << 0) & 0x1)
/* Field SCH_POLL_RESERVATION_DIS - Host Control Scheduler: sch_poll_reservation_dis */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_POLL_RESERVATION_DIS_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_POLL_RESERVATION_DIS_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_POLL_RESERVATION_DIS(v) (((v) << 0x1) & 0x2)
/* Field SCH_ALWAYS_RESERVE_DIS - Host Control Scheduler: sch_always_reserve_dis */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_ALWAYS_RESERVE_DIS_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_ALWAYS_RESERVE_DIS_MASK 0x4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_ALWAYS_RESERVE_DIS(v) (((v) << 0x2) & 0x4)
/* Field SCH_POLL_DBRANG_DIS - Host Control Scheduler: sch_poll_dbrang_dis */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_POLL_DBRANG_DIS_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_POLL_DBRANG_DIS_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SCH_POLL_DBRANG_DIS(v) (((v) << 0x3) & 0x8)
/* Field SERVICE_TIME_WATERMARK - service_time_watermark */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SERVICE_TIME_WATERMARK_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SERVICE_TIME_WATERMARK_MASK 0x7F00
#define IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_SERVICE_TIME_WATERMARK(v) (((v) << 0x8) & 0x7F00)

/* IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY - AUX_DEBUG_READ_ONLY. */
typedef union IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_union_t {
    uint32_t R;
    struct {
        uint32_t ALL_UPORTS_IN_U3NC :1;          /* all_uports_in_u3nc. If set all ports are in U3NC state. */
        uint32_t P2_OVERWRITE_ENTER :1;          /* p2_overwrite_enter, sticky bit */
        uint32_t _unused2    :30;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_t;

/* Register XECP_AUX_DEBUG_READ_ONLY - AUX_DEBUG_READ_ONLY. */
#define IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_OFFSET 0x181A4
/* Field ALL_UPORTS_IN_U3NC - all_uports_in_u3nc. If set all ports are in U3NC state. */
#define IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_ALL_UPORTS_IN_U3NC_SHIFT 0
#define IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_ALL_UPORTS_IN_U3NC_MASK 0x1
#define IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_ALL_UPORTS_IN_U3NC(v) (((v) << 0) & 0x1)
/* Field P2_OVERWRITE_ENTER - p2_overwrite_enter, sticky bit */
#define IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_P2_OVERWRITE_ENTER_SHIFT 1
#define IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_P2_OVERWRITE_ENTER_MASK 0x2
#define IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_P2_OVERWRITE_ENTER(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG - AUX_CTRL_PORTNUM_REG. */
typedef union IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_union_t {
    uint32_t R;
    struct {
        uint32_t LIMIT_NPORTS_USB2 :8;           /* Limit USB2 ports to fewer then synthesized (strap) */
        uint32_t LIMIT_NPORTS_USB3 :8;           /* Limit USB3 ports to fewer then synthesized (strap) */
        uint32_t LIMIT_MAX_NPORTS :8;            /* Limit Max ports to fewer then synthesized (strap) */
        uint32_t LIMIT_MAX_SLOTS :8;             /* Limit Max slots to fewer then synthesized (strap) */
    } B;
} IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_t;

/* Register XECP_AUX_CTRL_PORTNUM_REG - AUX_CTRL_PORTNUM_REG. */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_OFFSET 0x181A8
/* Field LIMIT_NPORTS_USB2 - Limit USB2 ports to fewer then synthesized (strap) */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_NPORTS_USB2_SHIFT 0
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_NPORTS_USB2_MASK 0xFF
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_NPORTS_USB2(v) (((v) << 0) & 0xFF)
/* Field LIMIT_NPORTS_USB3 - Limit USB3 ports to fewer then synthesized (strap) */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_NPORTS_USB3_SHIFT 8
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_NPORTS_USB3_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_NPORTS_USB3(v) (((v) << 0x8) & 0xFF00)
/* Field LIMIT_MAX_NPORTS - Limit Max ports to fewer then synthesized (strap) */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_MAX_NPORTS_SHIFT 16
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_MAX_NPORTS_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_MAX_NPORTS(v) (((v) << 0x10) & 0xFF0000)
/* Field LIMIT_MAX_SLOTS - Limit Max slots to fewer then synthesized (strap) */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_MAX_SLOTS_SHIFT 24
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_MAX_SLOTS_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_LIMIT_MAX_SLOTS(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG - Feature #3002 (Device Removable in PORTSC). */
typedef union IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_union_t {
    uint32_t R;
    struct {
        uint32_t DEVICE_REMOVABLE_USB2 :8;       /* Set to 1 if port has non-removable device (strap to 0/1) */
        uint32_t DEVICE_REMOVABLE_USB3 :8;       /* Set to 1 if port has non-removable device (strap to 0/1) */
        uint32_t _unused16   :16;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_t;

/* Register XECP_AUX_CTRL_DEV_REMOVE_REG - Feature #3002 (Device Removable in PORTSC). */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_OFFSET 0x181AC
/* Field DEVICE_REMOVABLE_USB2 - Set to 1 if port has non-removable device (strap to 0/1) */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_DEVICE_REMOVABLE_USB2_SHIFT 0
#define IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_DEVICE_REMOVABLE_USB2_MASK 0xFF
#define IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_DEVICE_REMOVABLE_USB2(v) (((v) << 0) & 0xFF)
/* Field DEVICE_REMOVABLE_USB3 - Set to 1 if port has non-removable device (strap to 0/1) */
#define IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_DEVICE_REMOVABLE_USB3_SHIFT 8
#define IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_DEVICE_REMOVABLE_USB3_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_DEVICE_REMOVABLE_USB3(v) (((v) << 0x8) & 0xFF00)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC - dbgp_desc_ctrl_reg. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_union_t {
    uint32_t R;
    struct {
        uint32_t DEBUG_PORT_CAP_U1_EXIT_LAT :4;  /* DEBUG_PORT_CAP_U1_EXIT_LAT */
        uint32_t DEBUG_PORT_CAP_U2_EXIT_LAT :11; /* DEBUG_PORT_CAP_U2_EXIT_LAT */
        uint32_t _unused15   :1;                 /* Reserved field, RO */
        uint32_t DEBUG_PORT_MAX_POWER :8;        /* DEBUG_PORT_MAX_POWER */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_t;

/* Register XECP_HOST_CTRL_DEBUG_PORT_DESC - dbgp_desc_ctrl_reg. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_OFFSET 0x181B0
/* Field DEBUG_PORT_CAP_U1_EXIT_LAT - DEBUG_PORT_CAP_U1_EXIT_LAT */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_CAP_U1_EXIT_LAT_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_CAP_U1_EXIT_LAT_MASK 0xF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_CAP_U1_EXIT_LAT(v) (((v) << 0) & 0xF)
/* Field DEBUG_PORT_CAP_U2_EXIT_LAT - DEBUG_PORT_CAP_U2_EXIT_LAT */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_CAP_U2_EXIT_LAT_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_CAP_U2_EXIT_LAT_MASK 0x7FF0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_CAP_U2_EXIT_LAT(v) (((v) << 0x4) & 0x7FF0)
/* Field DEBUG_PORT_MAX_POWER - DEBUG_PORT_MAX_POWER */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_MAX_POWER_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_MAX_POWER_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_DEBUG_PORT_MAX_POWER(v) (((v) << 0x10) & 0xFF0000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM - dbgp_trm_ctrl_reg. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_union_t {
    uint32_t R;
    struct {
        uint32_t DISABLE_STALL_EVENT :1;         /* Prevent generating STALL_ERR events when we halt. */
        uint32_t ENABLE_TYPE0_IS_NORM :1;        /* Treat all TRB_TYPE=0 fields as NORMAL. '0' is usually a reserved value. Note from rtl: this is an attempt to work-around a driver issue seen in lab testing. */
        uint32_t RESET_TX_BUFFER_CREDITS :1;     /* Returns the Tx debug credit value to '2' */
        uint32_t RESET_TX_DBG_XFER_ST :1;        /* Returns the Tx transfer state to IDLE */
        uint32_t RESET_RX_DBG_XFER_ST :1;        /* Returns the Rx transfer state to IDLE */
        uint32_t DISABLE_TIMEOUT_TIMER :1;       /* Disable trb_err and deadlock timeouts */
        uint32_t DISABLE_ACK_EQ_DB :1;           /* Disable treating Tx ACKs the same as a doorbell ring */
        uint32_t DISABLE_REREAD_TRB_ON_NONIDLE_DB :1; /* Disable re-reading the TRB when a doorbell arrives during non-idle state */
        uint32_t DISABLE_STOP_REQ_DONE_CLR_EP_ACTIVE :1; /* Disable clearing EP valid for all stop request done assertions */
        uint32_t DISABLE_CLEAR_PENDING_ON_DQPTR_LOAD :1; /* Disable clearing the pending trb length when dqptr is loaded */
        uint32_t DISABLE_MASK_STOP_ON_PKT_BNDRY :1; /* Disable prevent xfer_is_serve_stop when not at a packet boundary */
        uint32_t DISABLE_ADV_DQPTR_ON_STALL :1;  /* Disable advancing the length and dqptr field when stalling */
        uint32_t DISABLE_MASK_EXTRA_EVENT :1;    /* Disable prevention of extra event generation when stalling (for packets that do not hit the wire) */
        uint32_t INT_DBGP_TRM_CTRL_REG :19;      /* int_dbgp_trm_ctrl_reg */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_t;

/* Register XECP_HOST_CTRL_DEBUG_PORT_TRM - dbgp_trm_ctrl_reg. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_OFFSET 0x181B4
/* Field DISABLE_STALL_EVENT - Prevent generating STALL_ERR events when we halt. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_STALL_EVENT_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_STALL_EVENT_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_STALL_EVENT(v) (((v) << 0) & 0x1)
/* Field ENABLE_TYPE0_IS_NORM - Treat all TRB_TYPE=0 fields as NORMAL. '0' is usually a reserved value. Note from rtl: this is an attempt to work-around a driver issue seen in lab testing. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_ENABLE_TYPE0_IS_NORM_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_ENABLE_TYPE0_IS_NORM_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_ENABLE_TYPE0_IS_NORM(v) (((v) << 0x1) & 0x2)
/* Field RESET_TX_BUFFER_CREDITS - Returns the Tx debug credit value to '2' */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_TX_BUFFER_CREDITS_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_TX_BUFFER_CREDITS_MASK 0x4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_TX_BUFFER_CREDITS(v) (((v) << 0x2) & 0x4)
/* Field RESET_TX_DBG_XFER_ST - Returns the Tx transfer state to IDLE */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_TX_DBG_XFER_ST_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_TX_DBG_XFER_ST_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_TX_DBG_XFER_ST(v) (((v) << 0x3) & 0x8)
/* Field RESET_RX_DBG_XFER_ST - Returns the Rx transfer state to IDLE */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_RX_DBG_XFER_ST_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_RX_DBG_XFER_ST_MASK 0x10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_RESET_RX_DBG_XFER_ST(v) (((v) << 0x4) & 0x10)
/* Field DISABLE_TIMEOUT_TIMER - Disable trb_err and deadlock timeouts */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_TIMEOUT_TIMER_SHIFT 5
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_TIMEOUT_TIMER_MASK 0x20
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_TIMEOUT_TIMER(v) (((v) << 0x5) & 0x20)
/* Field DISABLE_ACK_EQ_DB - Disable treating Tx ACKs the same as a doorbell ring */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_ACK_EQ_DB_SHIFT 6
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_ACK_EQ_DB_MASK 0x40
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_ACK_EQ_DB(v) (((v) << 0x6) & 0x40)
/* Field DISABLE_REREAD_TRB_ON_NONIDLE_DB - Disable re-reading the TRB when a doorbell arrives during non-idle state */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_REREAD_TRB_ON_NONIDLE_DB_SHIFT 7
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_REREAD_TRB_ON_NONIDLE_DB_MASK 0x80
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_REREAD_TRB_ON_NONIDLE_DB(v) (((v) << 0x7) & 0x80)
/* Field DISABLE_STOP_REQ_DONE_CLR_EP_ACTIVE - Disable clearing EP valid for all stop request done assertions */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_STOP_REQ_DONE_CLR_EP_ACTIVE_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_STOP_REQ_DONE_CLR_EP_ACTIVE_MASK 0x100
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_STOP_REQ_DONE_CLR_EP_ACTIVE(v) (((v) << 0x8) & 0x100)
/* Field DISABLE_CLEAR_PENDING_ON_DQPTR_LOAD - Disable clearing the pending trb length when dqptr is loaded */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_CLEAR_PENDING_ON_DQPTR_LOAD_SHIFT 9
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_CLEAR_PENDING_ON_DQPTR_LOAD_MASK 0x200
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_CLEAR_PENDING_ON_DQPTR_LOAD(v) (((v) << 0x9) & 0x200)
/* Field DISABLE_MASK_STOP_ON_PKT_BNDRY - Disable prevent xfer_is_serve_stop when not at a packet boundary */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_MASK_STOP_ON_PKT_BNDRY_SHIFT 10
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_MASK_STOP_ON_PKT_BNDRY_MASK 0x400
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_MASK_STOP_ON_PKT_BNDRY(v) (((v) << 0xA) & 0x400)
/* Field DISABLE_ADV_DQPTR_ON_STALL - Disable advancing the length and dqptr field when stalling */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_ADV_DQPTR_ON_STALL_SHIFT 11
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_ADV_DQPTR_ON_STALL_MASK 0x800
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_ADV_DQPTR_ON_STALL(v) (((v) << 0xB) & 0x800)
/* Field DISABLE_MASK_EXTRA_EVENT - Disable prevention of extra event generation when stalling (for packets that do not hit the wire) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_MASK_EXTRA_EVENT_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_MASK_EXTRA_EVENT_MASK 0x1000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_DISABLE_MASK_EXTRA_EVENT(v) (((v) << 0xC) & 0x1000)
/* Field INT_DBGP_TRM_CTRL_REG - int_dbgp_trm_ctrl_reg */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_INT_DBGP_TRM_CTRL_REG_SHIFT 13
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_INT_DBGP_TRM_CTRL_REG_MASK 0xFFFFE000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_INT_DBGP_TRM_CTRL_REG(v) (((v) << 0xD) & 0xFFFFE000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_IDMA - dbgp_idma_ctrl_reg. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_IDMA_union_t {
    uint32_t R;
    struct {
        uint32_t INT_DBGP_IDMA_CTRL_REG :32;     /* int_dbgp_idma_ctrl_reg */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_IDMA_t;

/* Register XECP_HOST_CTRL_DEBUG_PORT_IDMA - dbgp_idma_ctrl_reg. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_IDMA_OFFSET 0x181B8
/* Field INT_DBGP_IDMA_CTRL_REG - int_dbgp_idma_ctrl_reg */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_IDMA_INT_DBGP_IDMA_CTRL_REG_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_IDMA_INT_DBGP_IDMA_CTRL_REG_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_IDMA_INT_DBGP_IDMA_CTRL_REG(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_ODMA - dbgp_odma_ctrl_reg. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_ODMA_union_t {
    uint32_t R;
    struct {
        uint32_t INT_DBGP_ODMA_CTRL_REG :32;     /* int_dbgp_odma_ctrl_reg */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_ODMA_t;

/* Register XECP_HOST_CTRL_DEBUG_PORT_ODMA - dbgp_odma_ctrl_reg. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_ODMA_OFFSET 0x181BC
/* Field INT_DBGP_ODMA_CTRL_REG - int_dbgp_odma_ctrl_reg */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_ODMA_INT_DBGP_ODMA_CTRL_REG_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_ODMA_INT_DBGP_ODMA_CTRL_REG_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_ODMA_INT_DBGP_ODMA_CTRL_REG(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC - dbgp_misc_ctrl_reg. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_union_t {
    uint32_t R;
    struct {
        uint32_t DBGP_CLK_GATE_DIS :1;           /* dbgp_clk_gate_dis */
        uint32_t DBGP_STRING_DIS :1;             /* dbgp_string_dis */
        uint32_t DBGP_ACKZERO_DIS :1;            /* dbgp_ackzero_dis */
        uint32_t DBGP_INTR_EN :1;                /* debug port interrupt enable bit */
        uint32_t DBGP_INTR_TRGT :3;              /* Debug port interrupt target selection (0-7, default = 0). */
        uint32_t _unused7    :25;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_t;

/* Register XECP_HOST_CTRL_DEBUG_PORT_MISC - dbgp_misc_ctrl_reg. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_OFFSET 0x181C0
/* Field DBGP_CLK_GATE_DIS - dbgp_clk_gate_dis */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_CLK_GATE_DIS_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_CLK_GATE_DIS_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_CLK_GATE_DIS(v) (((v) << 0) & 0x1)
/* Field DBGP_STRING_DIS - dbgp_string_dis */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_STRING_DIS_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_STRING_DIS_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_STRING_DIS(v) (((v) << 0x1) & 0x2)
/* Field DBGP_ACKZERO_DIS - dbgp_ackzero_dis */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_ACKZERO_DIS_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_ACKZERO_DIS_MASK 0x4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_ACKZERO_DIS(v) (((v) << 0x2) & 0x4)
/* Field DBGP_INTR_EN - debug port interrupt enable bit */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_INTR_EN_SHIFT 3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_INTR_EN_MASK 0x8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_INTR_EN(v) (((v) << 0x3) & 0x8)
/* Field DBGP_INTR_TRGT - Debug port interrupt target selection (0-7, default = 0). */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_INTR_TRGT_SHIFT 4
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_INTR_TRGT_MASK 0x70
#define IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_DBGP_INTR_TRGT(v) (((v) << 0x4) & 0x70)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1 - Specific control register for SCH. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t EOB_ISO_DIS :1;                 /* Disable end of burst workaround ISO (0 length on final MDATA) */
        uint32_t EOB_INT_DIS :1;                 /* Disable end of burst workaround INT (0 length on final MDATA) */
        uint32_t _unused2    :6;                 /* Reserved field, RW */
        uint32_t _unused8    :24;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_t;

/* Register XECP_HOST_CTRL_TTE_REG1 - Specific control register for SCH. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_OFFSET 0x181E0
/* Field EOB_ISO_DIS - Disable end of burst workaround ISO (0 length on final MDATA) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_EOB_ISO_DIS_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_EOB_ISO_DIS_MASK 0x1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_EOB_ISO_DIS(v) (((v) << 0) & 0x1)
/* Field EOB_INT_DIS - Disable end of burst workaround INT (0 length on final MDATA) */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_EOB_INT_DIS_SHIFT 1
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_EOB_INT_DIS_MASK 0x2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_EOB_INT_DIS(v) (((v) << 0x1) & 0x2)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1 - HOST_CTRL_LTM_REG1. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t BELT_SLOT_SELECT :16;           /* Slot-ID for BELT reported on the belt_selected field when belt_select is 2 */
        uint32_t BELT_PORT_SELECT :8;            /* Port Number for the BELT reported on the belt_selected field when belt_select is 3 */
        uint32_t BELT_FORCE_DISABLESLOT :1;      /* belt_force_disable_slot */
        uint32_t BELT_FORCE_DISABLEALL :1;       /* belt_force_disable_all */
        uint32_t BELT_FORCE_RECOMPUTE :1;        /* belt_force_recompute */
        uint32_t BELT_PCIE_EN :1;                /* belt_pcie_en, default disabled */
        uint32_t BELT_USB3_EN :1;                /* belt_usb3_en, active '0', default enabled */
        uint32_t BELT_USB2_EN :1;                /* belt_usb2_en, active '0', default enabled */
        uint32_t BELT_SELECT :2;                 /* Selects which BELT value should be reported on the belt_selected field when the register is read. 0 - LTV value programmed, 1 - Lowest BELT received, 2 - Last received LTM per Slot, 3 - Last received LTM per Port. */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_t;

/* Register XECP_HOST_CTRL_LTM_REG1 - HOST_CTRL_LTM_REG1. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_OFFSET 0x181E4
/* Field BELT_SLOT_SELECT - Slot-ID for BELT reported on the belt_selected field when belt_select is 2 */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_SLOT_SELECT_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_SLOT_SELECT_MASK 0xFFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_SLOT_SELECT(v) (((v) << 0) & 0xFFFF)
/* Field BELT_PORT_SELECT - Port Number for the BELT reported on the belt_selected field when belt_select is 3 */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_PORT_SELECT_SHIFT 16
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_PORT_SELECT_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_PORT_SELECT(v) (((v) << 0x10) & 0xFF0000)
/* Field BELT_FORCE_DISABLESLOT - belt_force_disable_slot */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_DISABLESLOT_SHIFT 24
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_DISABLESLOT_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_DISABLESLOT(v) (((v) << 0x18) & 0x1000000)
/* Field BELT_FORCE_DISABLEALL - belt_force_disable_all */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_DISABLEALL_SHIFT 25
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_DISABLEALL_MASK 0x2000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_DISABLEALL(v) (((v) << 0x19) & 0x2000000)
/* Field BELT_FORCE_RECOMPUTE - belt_force_recompute */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_RECOMPUTE_SHIFT 26
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_RECOMPUTE_MASK 0x4000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_FORCE_RECOMPUTE(v) (((v) << 0x1A) & 0x4000000)
/* Field BELT_PCIE_EN - belt_pcie_en, default disabled */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_PCIE_EN_SHIFT 27
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_PCIE_EN_MASK 0x8000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_PCIE_EN(v) (((v) << 0x1B) & 0x8000000)
/* Field BELT_USB3_EN - belt_usb3_en, active '0', default enabled */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_USB3_EN_SHIFT 28
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_USB3_EN_MASK 0x10000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_USB3_EN(v) (((v) << 0x1C) & 0x10000000)
/* Field BELT_USB2_EN - belt_usb2_en, active '0', default enabled */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_USB2_EN_SHIFT 29
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_USB2_EN_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_USB2_EN(v) (((v) << 0x1D) & 0x20000000)
/* Field BELT_SELECT - Selects which BELT value should be reported on the belt_selected field when the register is read. 0 - LTV value programmed, 1 - Lowest BELT received, 2 - Last received LTM per Slot, 3 - Last received LTM per Port. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_SELECT_SHIFT 30
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_SELECT_MASK 0xC0000000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_BELT_SELECT(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG2 - HOST_CTRL_LTM_REG2. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG2_union_t {
    uint32_t R;
    struct {
        uint32_t DEFAULT_PCIE_LTM :12;           /* DEFAULT_PCIE_LTM converted from ns with convert_ns2belt */
        uint32_t _unused12   :20;                /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG2_t;

/* Register XECP_HOST_CTRL_LTM_REG2 - HOST_CTRL_LTM_REG2. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG2_OFFSET 0x181E8
/* Field DEFAULT_PCIE_LTM - DEFAULT_PCIE_LTM converted from ns with convert_ns2belt */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG2_DEFAULT_PCIE_LTM_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG2_DEFAULT_PCIE_LTM_MASK 0xFFF
#define IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG2_DEFAULT_PCIE_LTM(v) (((v) << 0) & 0xFFF)

/* IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_0 - For internal use. */
typedef union IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_0_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved field, RW */
    } B;
} IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_0_t;

/* Register XECP_AUX_SCRATCHPAD_0 - For internal use. */
#define IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_0_OFFSET 0x18200

/* IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_1 - For internal use. */
typedef union IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_1_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved field, RW */
    } B;
} IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_1_t;

/* Register XECP_AUX_SCRATCHPAD_1 - For internal use. */
#define IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_1_OFFSET 0x18204

/* IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG - Battery charge mode and enable register. */
typedef union IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_union_t {
    uint32_t R;
    struct {
        uint32_t BATTERY_CHARGE_MODE_REG :1;     /* The register allows setting battery charge mode for each USB2 port. */
        uint32_t RESERVEDR   :24;                /* Reserved field, RO. */
        uint32_t BATTERY_CHARGE_MODE_EN_REG :7;  /* The register allows enabling battery charge mode for each USB2 port. */
    } B;
} IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_t;

/* Register XECP_BATTERY_CHARGE_REG - Battery charge mode and enable register. */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_OFFSET 0x18210
/* Field BATTERY_CHARGE_MODE_REG - The register allows setting battery charge mode for each USB2 port. */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_BATTERY_CHARGE_MODE_REG_SHIFT 0
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_BATTERY_CHARGE_MODE_REG_MASK 0x1
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_BATTERY_CHARGE_MODE_REG(v) (((v) << 0) & 0x1)
/* Field RESERVEDR - Reserved field, RO. */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_RESERVEDR_SHIFT 1
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_RESERVEDR_MASK 0x1FFFFFE
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_RESERVEDR(v) (((v) << 0x1) & 0x1FFFFFE)
/* Field BATTERY_CHARGE_MODE_EN_REG - The register allows enabling battery charge mode for each USB2 port. */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_BATTERY_CHARGE_MODE_EN_REG_SHIFT 25
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_BATTERY_CHARGE_MODE_EN_REG_MASK 0xFE000000
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_BATTERY_CHARGE_MODE_EN_REG(v) (((v) << 0x19) & 0xFE000000)

/* IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG1 - Battery charge control register 1. */
typedef union IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t BATTERY_CHARGE_CTRL_REG1_DEFAULT :31; /* BATTERY_CHARGE_CTRL_REG1_DEFAULT */
        uint32_t _unused31   :1;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG1_t;

/* Register XECP_BATTERY_CHARGE_REG1 - Battery charge control register 1. */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG1_OFFSET 0x18214
/* Field BATTERY_CHARGE_CTRL_REG1_DEFAULT - BATTERY_CHARGE_CTRL_REG1_DEFAULT */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG1_BATTERY_CHARGE_CTRL_REG1_DEFAULT_SHIFT 0
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG1_BATTERY_CHARGE_CTRL_REG1_DEFAULT_MASK 0x7FFFFFFF
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG1_BATTERY_CHARGE_CTRL_REG1_DEFAULT(v) (((v) << 0) & 0x7FFFFFFF)

/* IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG2 - Battery charge control register 2. */
typedef union IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG2_union_t {
    uint32_t R;
    struct {
        uint32_t BATTERY_CHARGE_CTRL_REG2_DEFAULT :24; /* BATTERY_CHARGE_CTRL_REG2_DEFAULT */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG2_t;

/* Register XECP_BATTERY_CHARGE_REG2 - Battery charge control register 2. */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG2_OFFSET 0x18218
/* Field BATTERY_CHARGE_CTRL_REG2_DEFAULT - BATTERY_CHARGE_CTRL_REG2_DEFAULT */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG2_BATTERY_CHARGE_CTRL_REG2_DEFAULT_SHIFT 0
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG2_BATTERY_CHARGE_CTRL_REG2_DEFAULT_MASK 0xFFFFFF
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG2_BATTERY_CHARGE_CTRL_REG2_DEFAULT(v) (((v) << 0) & 0xFFFFFF)

/* IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG3 - Battery charge debug register. */
typedef union IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG3_union_t {
    uint32_t R;
    struct {
        uint32_t BATTERY_CHARGE_DEBUG :24;       /* Battery charge debug */
        uint32_t _unused24   :8;                 /* Reserved field, RO */
    } B;
} IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG3_t;

/* Register XECP_BATTERY_CHARGE_REG3 - Battery charge debug register. */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG3_OFFSET 0x1821C
/* Field BATTERY_CHARGE_DEBUG - Battery charge debug */
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG3_BATTERY_CHARGE_DEBUG_SHIFT 0
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG3_BATTERY_CHARGE_DEBUG_MASK 0xFFFFFF
#define IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG3_BATTERY_CHARGE_DEBUG(v) (((v) << 0) & 0xFFFFFF)

/* IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1 - Feature #581. */
typedef union IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t LINK_8B_DEBUG_CTRL :2;          /* link_debug_ctrl register:.link_8b_debug_ctrl; bit[0]: xmt_d102, bit[1]: xmt_comma. */
        uint32_t LINK_LTSSM_DEBUG_CTRL :6;       /* link_debug_ctrl register:.link_ltssm_debug_ctrl. Possible values: stay_in_idle : bit 0 set; stay_in_ts1 : bit 1 set; stay_in_ts2 : bit 2 set; stay_in_tseq : bit 3 set; stay_in_lfps : bit 4 set; timeout_jumpover_en : bit 5 set; */
        uint32_t CFG_TIEBREAK_VAL :4;            /* cfg_tiebreak_val */
        uint32_t CFG_TIEBREAK_MODE :2;           /* cfg_tiebreak_mode */
        uint32_t _unused14   :18;                /* Reserved field, RW */
    } B;
} IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_t;

/* Register XECP_HOST_CTRL_PORT_LINK_REG1 - Feature #581. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_OFFSET 0x18220
/* Field LINK_8B_DEBUG_CTRL - link_debug_ctrl register:.link_8b_debug_ctrl; bit[0]: xmt_d102, bit[1]: xmt_comma. */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_LINK_8B_DEBUG_CTRL_SHIFT 0
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_LINK_8B_DEBUG_CTRL_MASK 0x3
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_LINK_8B_DEBUG_CTRL(v) (((v) << 0) & 0x3)
/* Field LINK_LTSSM_DEBUG_CTRL - link_debug_ctrl register:.link_ltssm_debug_ctrl. Possible values: stay_in_idle : bit 0 set; stay_in_ts1 : bit 1 set; stay_in_ts2 : bit 2 set; stay_in_tseq : bit 3 set; stay_in_lfps : bit 4 set; timeout_jumpover_en : bit 5 set; */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_LINK_LTSSM_DEBUG_CTRL_SHIFT 2
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_LINK_LTSSM_DEBUG_CTRL_MASK 0xFC
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_LINK_LTSSM_DEBUG_CTRL(v) (((v) << 0x2) & 0xFC)
/* Field CFG_TIEBREAK_VAL - cfg_tiebreak_val */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_CFG_TIEBREAK_VAL_SHIFT 8
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_CFG_TIEBREAK_VAL_MASK 0xF00
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_CFG_TIEBREAK_VAL(v) (((v) << 0x8) & 0xF00)
/* Field CFG_TIEBREAK_MODE - cfg_tiebreak_mode */
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_CFG_TIEBREAK_MODE_SHIFT 12
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_CFG_TIEBREAK_MODE_MASK 0x3000
#define IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_CFG_TIEBREAK_MODE(v) (((v) << 0xC) & 0x3000)

/* IMX_USB3_USBSS_XECP_USBLEGSUP - USB Legacy Support Capability. */
typedef union IMX_USB3_USBSS_XECP_USBLEGSUP_union_t {
    uint32_t R;
    struct {
        uint32_t CID         :8;                 /* USB Legacy Support Capability ID, RO. This capability provides the xHCI Pre-OS to OS Handoff Synchronization support capability. */
        uint32_t NEXTCP      :8;                 /* Next Capability Pointer, RO. This field indicates the location of the next capability with respect to the effective address of this capability. A non-zero value in this register indicates a relative offset, in Dwords, from this Dword to the beginning of the next extended capability. */
        uint32_t HCBIOSOS    :1;                 /* HC BIOS Owned Semaphore (HCBIOSOS), RW. Default = '0'. The BIOS sets this bit to establish ownership of the xHC. System BIOS will set this bit to '0' in response to a request for ownership of the xHC by system software. */
        uint32_t _unused17   :7;
        uint32_t HCOSOS      :1;                 /* HC OS Owned Semaphore, RW. Default = '0'. System software sets this bit to request ownership of the xHC. Ownership is obtained when this bit reads as '1' and the HC BIOS Owned Semaphore bit (HCBIOSOS) reads as '0'. */
        uint32_t _unused25   :7;
    } B;
} IMX_USB3_USBSS_XECP_USBLEGSUP_t;

/* Register XECP_USBLEGSUP - USB Legacy Support Capability. */
#define IMX_USB3_USBSS_XECP_USBLEGSUP_OFFSET 0x18370
/* Field CID - USB Legacy Support Capability ID, RO. This capability provides the xHCI Pre-OS to OS Handoff Synchronization support capability. */
#define IMX_USB3_USBSS_XECP_USBLEGSUP_CID_SHIFT 0
#define IMX_USB3_USBSS_XECP_USBLEGSUP_CID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_USBLEGSUP_CID(v) (((v) << 0) & 0xFF)
/* Field NEXTCP - Next Capability Pointer, RO. This field indicates the location of the next capability with respect to the effective address of this capability. A non-zero value in this register indicates a relative offset, in Dwords, from this Dword to the beginning of the next extended capability. */
#define IMX_USB3_USBSS_XECP_USBLEGSUP_NEXTCP_SHIFT 8
#define IMX_USB3_USBSS_XECP_USBLEGSUP_NEXTCP_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_USBLEGSUP_NEXTCP(v) (((v) << 0x8) & 0xFF00)
/* Field HCBIOSOS - HC BIOS Owned Semaphore (HCBIOSOS), RW. Default = '0'. The BIOS sets this bit to establish ownership of the xHC. System BIOS will set this bit to '0' in response to a request for ownership of the xHC by system software. */
#define IMX_USB3_USBSS_XECP_USBLEGSUP_HCBIOSOS_SHIFT 16
#define IMX_USB3_USBSS_XECP_USBLEGSUP_HCBIOSOS_MASK 0x10000
#define IMX_USB3_USBSS_XECP_USBLEGSUP_HCBIOSOS(v) (((v) << 0x10) & 0x10000)
/* Field HCOSOS - HC OS Owned Semaphore, RW. Default = '0'. System software sets this bit to request ownership of the xHC. Ownership is obtained when this bit reads as '1' and the HC BIOS Owned Semaphore bit (HCBIOSOS) reads as '0'. */
#define IMX_USB3_USBSS_XECP_USBLEGSUP_HCOSOS_SHIFT 24
#define IMX_USB3_USBSS_XECP_USBLEGSUP_HCOSOS_MASK 0x1000000
#define IMX_USB3_USBSS_XECP_USBLEGSUP_HCOSOS(v) (((v) << 0x18) & 0x1000000)

/* IMX_USB3_USBSS_XECP_USBLEGCTLSTS - USB Legacy Support Control Status. */
typedef union IMX_USB3_USBSS_XECP_USBLEGCTLSTS_union_t {
    uint32_t R;
    struct {
        uint32_t USBSMIE     :1;                 /* USB SMI Enable, RW. Default = '0'. When this bit is a '1', and the SMI on Event Interrupt bit (below) in this register is a '1', the host controller will issue an SMI immediately. */
        uint32_t _unused1    :3;                 /* Reserved */
        uint32_t SMIHSEE     :1;                 /* SMI on Host System Error Enable, RW. Default = '0'. When this bit is a '1', and the SMI on Host System Error bit (below) in this register is a '1', the host controller will issue an SMI immediately. */
        uint32_t _unused5    :8;                 /* Reserved */
        uint32_t SMIOSOE     :1;                 /* SMI on OS Ownership Enable, RW. Default = '0'. When this bit is a '1' AND the OS Ownership Change bit is '1', the host controller will issue an SMI. */
        uint32_t SMIPCICE    :1;                 /* SMI on PCI Command Enable, RW. Default = '0'. When this bit is '1' and SMI on PCI Command is '1', then the host controller will issue an SMI. */
        uint32_t SMIBARE     :1;                 /* SMI on BAR Enable, RW. Default = '0'. When this bit is '1' and SMI on BAR is '1', then the host controller will issue an SMI. */
        uint32_t SMIEI       :1;                 /* SMI on Event Interrupt, RO. Default = '0'. Shadow bit of Event Interrupt (EINT) bit in the USBSTS register. Refer to Section 5.4.2 of xHCI specification for definition. This bit follows the state the Event Interrupt (EINT) bit in the USBSTS register, e.g. it automatically clears when EINT clears or set when EINT is set. */
        uint32_t _unused17   :3;                 /* Reserved */
        uint32_t SMIHSE      :1;                 /* SMI on Host System Error, RO. Default = '0'. Shadow bit of Host System Error (HSE) bit in the USBSTS register. Refer to Section 5.4.2 of xHCI specification for definition and effects of the events associated with this bit being set to '1'. To clear this bit to a '0', system software shall write a '1' to the Host System Error (HSE) bit in the USBSTS register. */
        uint32_t _unused21   :8;                 /* Reserved */
        uint32_t SMIOSOC     :1;                 /* SMI on OS Ownership Change, RW1C. Default = '0'. This bit is set to '1' whenever the HC OS Owned Semaphore bit in the USBLEGSUP register transitions from '1' to a '0' or '0' to a '1'. */
        uint32_t SMIPCIC     :1;                 /* SMI on PCI Command, RW1C. Default = '0'. This bit is set to '1' whenever the PCI Command Register is written. */
        uint32_t SMIBAR      :1;                 /* SMI on BAR, RW1C. Default = '0'. This bit is set to '1' whenever the Base Address Register (BAR) is written. */
    } B;
} IMX_USB3_USBSS_XECP_USBLEGCTLSTS_t;

/* Register XECP_USBLEGCTLSTS - USB Legacy Support Control Status. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_OFFSET 0x18374
/* Field USBSMIE - USB SMI Enable, RW. Default = '0'. When this bit is a '1', and the SMI on Event Interrupt bit (below) in this register is a '1', the host controller will issue an SMI immediately. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_USBSMIE_SHIFT 0
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_USBSMIE_MASK 0x1
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_USBSMIE(v) (((v) << 0) & 0x1)
/* Field SMIHSEE - SMI on Host System Error Enable, RW. Default = '0'. When this bit is a '1', and the SMI on Host System Error bit (below) in this register is a '1', the host controller will issue an SMI immediately. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIHSEE_SHIFT 4
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIHSEE_MASK 0x10
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIHSEE(v) (((v) << 0x4) & 0x10)
/* Field SMIOSOE - SMI on OS Ownership Enable, RW. Default = '0'. When this bit is a '1' AND the OS Ownership Change bit is '1', the host controller will issue an SMI. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIOSOE_SHIFT 13
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIOSOE_MASK 0x2000
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIOSOE(v) (((v) << 0xD) & 0x2000)
/* Field SMIPCICE - SMI on PCI Command Enable, RW. Default = '0'. When this bit is '1' and SMI on PCI Command is '1', then the host controller will issue an SMI. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIPCICE_SHIFT 14
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIPCICE_MASK 0x4000
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIPCICE(v) (((v) << 0xE) & 0x4000)
/* Field SMIBARE - SMI on BAR Enable, RW. Default = '0'. When this bit is '1' and SMI on BAR is '1', then the host controller will issue an SMI. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIBARE_SHIFT 15
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIBARE_MASK 0x8000
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIBARE(v) (((v) << 0xF) & 0x8000)
/* Field SMIEI - SMI on Event Interrupt, RO. Default = '0'. Shadow bit of Event Interrupt (EINT) bit in the USBSTS register. Refer to Section 5.4.2 of xHCI specification for definition. This bit follows the state the Event Interrupt (EINT) bit in the USBSTS register, e.g. it automatically clears when EINT clears or set when EINT is set. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIEI_SHIFT 16
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIEI_MASK 0x10000
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIEI(v) (((v) << 0x10) & 0x10000)
/* Field SMIHSE - SMI on Host System Error, RO. Default = '0'. Shadow bit of Host System Error (HSE) bit in the USBSTS register. Refer to Section 5.4.2 of xHCI specification for definition and effects of the events associated with this bit being set to '1'. To clear this bit to a '0', system software shall write a '1' to the Host System Error (HSE) bit in the USBSTS register. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIHSE_SHIFT 20
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIHSE_MASK 0x100000
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIHSE(v) (((v) << 0x14) & 0x100000)
/* Field SMIOSOC - SMI on OS Ownership Change, RW1C. Default = '0'. This bit is set to '1' whenever the HC OS Owned Semaphore bit in the USBLEGSUP register transitions from '1' to a '0' or '0' to a '1'. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIOSOC_SHIFT 29
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIOSOC_MASK 0x20000000
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIOSOC(v) (((v) << 0x1D) & 0x20000000)
/* Field SMIPCIC - SMI on PCI Command, RW1C. Default = '0'. This bit is set to '1' whenever the PCI Command Register is written. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIPCIC_SHIFT 30
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIPCIC_MASK 0x40000000
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIPCIC(v) (((v) << 0x1E) & 0x40000000)
/* Field SMIBAR - SMI on BAR, RW1C. Default = '0'. This bit is set to '1' whenever the Base Address Register (BAR) is written. */
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIBAR_SHIFT 31
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIBAR_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_USBLEGCTLSTS_SMIBAR(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_DCID - The Debug Capability ID Register links the USB Debug Capability into the xHCI list of Extended Capabilities and defines its basic capabilities. */
typedef union IMX_USB3_USBSS_XECP_DCID_union_t {
    uint32_t R;
    struct {
        uint32_t CAPID       :8;                 /* Debug capability ID, RO. */
        uint32_t NEXTCAPID   :8;                 /* Next Capability Pointer, RO. Default = 0. This field indicates the location of the next capability with respect to the effective address of this capability. A non-zero value in this register indicates a relative offset, in Dwords, from this Dword to the beginning of the next extended capability. */
        uint32_t DCERST_MAX  :5;                 /* Debug Capability Event Ring Segment Table Max (DCERST Max), RO. Default = 3. Valid values are 0 to 15. This field determines the maximum value supported by the Debug Capability Event Ring Segment Table Base Size registers, where: The maximum number of Event Ring Segment Table entries = 2^DCERST_Max; e.g. if DCERST_Max = 7, then the Debug Capability Event Ring Segment Table(s) supports up to 128 entries, 15 then 32K entries, etc. */
        uint32_t _unused21   :11;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_DCID_t;

/* Register XECP_DCID - The Debug Capability ID Register links the USB Debug Capability into the xHCI list of Extended Capabilities and defines its basic capabilities. */
#define IMX_USB3_USBSS_XECP_DCID_OFFSET 0x18380
/* Field CAPID - Debug capability ID, RO. */
#define IMX_USB3_USBSS_XECP_DCID_CAPID_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCID_CAPID_MASK 0xFF
#define IMX_USB3_USBSS_XECP_DCID_CAPID(v) (((v) << 0) & 0xFF)
/* Field NEXTCAPID - Next Capability Pointer, RO. Default = 0. This field indicates the location of the next capability with respect to the effective address of this capability. A non-zero value in this register indicates a relative offset, in Dwords, from this Dword to the beginning of the next extended capability. */
#define IMX_USB3_USBSS_XECP_DCID_NEXTCAPID_SHIFT 8
#define IMX_USB3_USBSS_XECP_DCID_NEXTCAPID_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_DCID_NEXTCAPID(v) (((v) << 0x8) & 0xFF00)
/* Field DCERST_MAX - Debug Capability Event Ring Segment Table Max (DCERST Max), RO. Default = 3. Valid values are 0 to 15. This field determines the maximum value supported by the Debug Capability Event Ring Segment Table Base Size registers, where: The maximum number of Event Ring Segment Table entries = 2^DCERST_Max; e.g. if DCERST_Max = 7, then the Debug Capability Event Ring Segment Table(s) supports up to 128 entries, 15 then 32K entries, etc. */
#define IMX_USB3_USBSS_XECP_DCID_DCERST_MAX_SHIFT 16
#define IMX_USB3_USBSS_XECP_DCID_DCERST_MAX_MASK 0x1F0000
#define IMX_USB3_USBSS_XECP_DCID_DCERST_MAX(v) (((v) << 0x10) & 0x1F0000)

/* IMX_USB3_USBSS_XECP_DCDB - Debug Capability Doorbell Register */
typedef union IMX_USB3_USBSS_XECP_DCDB_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :8;                 /* Reserved */
        uint32_t DB_TARGET   :8;                 /* Doorbell Target (DB Target), RW. This field defines the target of the doorbell reference. Debug Capability notifications generated by ringing the doorbell: 0: Data EP 1 OUT Enqueue Pointer Update 1: Data EP 1 IN Enqueue Pointer Update 2: 255 Reserved; This field returns zero when read and it should be treated as undefined by software. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_DCDB_t;

/* Register XECP_DCDB - Debug Capability Doorbell Register */
#define IMX_USB3_USBSS_XECP_DCDB_OFFSET 0x18384
/* Field DB_TARGET - Doorbell Target (DB Target), RW. This field defines the target of the doorbell reference. Debug Capability notifications generated by ringing the doorbell: 0: Data EP 1 OUT Enqueue Pointer Update 1: Data EP 1 IN Enqueue Pointer Update 2: 255 Reserved; This field returns zero when read and it should be treated as undefined by software. */
#define IMX_USB3_USBSS_XECP_DCDB_DB_TARGET_SHIFT 8
#define IMX_USB3_USBSS_XECP_DCDB_DB_TARGET_MASK 0xFF00
#define IMX_USB3_USBSS_XECP_DCDB_DB_TARGET(v) (((v) << 0x8) & 0xFF00)

/* IMX_USB3_USBSS_XECP_DCERSTSZ - The Debug Capability Event Ring Segment Table Size Register defines the number of segments supported by the Debug Capability Event Ring Segment Table. */
typedef union IMX_USB3_USBSS_XECP_DCERSTSZ_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTSZ      :16;                /* Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Debug Capability Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the DCERST_Max field in the DCID register. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
        uint32_t _unused16   :16;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_DCERSTSZ_t;

/* Register XECP_DCERSTSZ - The Debug Capability Event Ring Segment Table Size Register defines the number of segments supported by the Debug Capability Event Ring Segment Table. */
#define IMX_USB3_USBSS_XECP_DCERSTSZ_OFFSET 0x18388
/* Field ERSTSZ - Event Ring Segment Table Size, RW. Default = 0. This field identifies the number of valid Event Ring Segment Table entries in the Event Ring Segment Table pointed to by the Debug Capability Event Ring Segment Table Base Address register. The maximum value supported by an xHC implementation for this register is defined by the DCERST_Max field in the DCID register. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
#define IMX_USB3_USBSS_XECP_DCERSTSZ_ERSTSZ_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCERSTSZ_ERSTSZ_MASK 0xFFFF
#define IMX_USB3_USBSS_XECP_DCERSTSZ_ERSTSZ(v) (((v) << 0) & 0xFFFF)

/* IMX_USB3_USBSS_XECP_RSVD_0C - XECP_RSVD_0C, RsvdZ. */
typedef union IMX_USB3_USBSS_XECP_RSVD_0C_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_RSVD_0C_t;

/* Register XECP_RSVD_0C - XECP_RSVD_0C, RsvdZ. */
#define IMX_USB3_USBSS_XECP_RSVD_0C_OFFSET 0x1838C

/* IMX_USB3_USBSS_XECP_DCERSTBA_LOW - Debug Capability Event Ring Segment Table Base Address Register (DCERSTBA). */
typedef union IMX_USB3_USBSS_XECP_DCERSTBA_LOW_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :4;                 /* Reserved */
        uint32_t ERSTBA_L    :28;                /* Event Ring Segment Table Base Address Register RW. Default = 0. This field defines the high order bits of the start address of the Debug Capability Event Ring Segment Table. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
    } B;
} IMX_USB3_USBSS_XECP_DCERSTBA_LOW_t;

/* Register XECP_DCERSTBA_LOW - Debug Capability Event Ring Segment Table Base Address Register (DCERSTBA). */
#define IMX_USB3_USBSS_XECP_DCERSTBA_LOW_OFFSET 0x18390
/* Field ERSTBA_L - Event Ring Segment Table Base Address Register RW. Default = 0. This field defines the high order bits of the start address of the Debug Capability Event Ring Segment Table. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
#define IMX_USB3_USBSS_XECP_DCERSTBA_LOW_ERSTBA_L_SHIFT 4
#define IMX_USB3_USBSS_XECP_DCERSTBA_LOW_ERSTBA_L_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_XECP_DCERSTBA_LOW_ERSTBA_L(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_XECP_DCERSTBA_HIGH - Debug Capability Event Ring Segment Table Base Address Register (DCERSTBA). */
typedef union IMX_USB3_USBSS_XECP_DCERSTBA_HIGH_union_t {
    uint32_t R;
    struct {
        uint32_t ERSTBA_H    :32;                /* Event Ring Segment Table Base Address Register RW. Default = 0. This field defines the high order bits of the start address of the Debug Capability Event Ring Segment Table. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
    } B;
} IMX_USB3_USBSS_XECP_DCERSTBA_HIGH_t;

/* Register XECP_DCERSTBA_HIGH - Debug Capability Event Ring Segment Table Base Address Register (DCERSTBA). */
#define IMX_USB3_USBSS_XECP_DCERSTBA_HIGH_OFFSET 0x18394
/* Field ERSTBA_H - Event Ring Segment Table Base Address Register RW. Default = 0. This field defines the high order bits of the start address of the Debug Capability Event Ring Segment Table. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
#define IMX_USB3_USBSS_XECP_DCERSTBA_HIGH_ERSTBA_H_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCERSTBA_HIGH_ERSTBA_H_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_DCERSTBA_HIGH_ERSTBA_H(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_DCERDP_LOW - Debug Capability Event Ring Dequeue Pointer Register (DCERDP). */
typedef union IMX_USB3_USBSS_XECP_DCERDP_LOW_union_t {
    uint32_t R;
    struct {
        uint32_t DESI        :3;                 /* Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
        uint32_t _unused3    :1;                 /* Reserved */
        uint32_t DEQ_PTR_L   :28;                /* Dequeue Pointer, RW. Default = 0. This field defines the high order bits of the 64-bit address of the current Debug Capability Event Ring Dequeue Pointer. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
    } B;
} IMX_USB3_USBSS_XECP_DCERDP_LOW_t;

/* Register XECP_DCERDP_LOW - Debug Capability Event Ring Dequeue Pointer Register (DCERDP). */
#define IMX_USB3_USBSS_XECP_DCERDP_LOW_OFFSET 0x18398
/* Field DESI - Dequeue ERST Segment Index (DESI). Default = 0. This field may be used by the xHC to accelerate checking the Event Ring full condition. This field is written with the low order 3 bits of the offset of the ERST entry which defines the Event Ring segment that the Event Ring Dequeue Pointer resides in. */
#define IMX_USB3_USBSS_XECP_DCERDP_LOW_DESI_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCERDP_LOW_DESI_MASK 0x7
#define IMX_USB3_USBSS_XECP_DCERDP_LOW_DESI(v) (((v) << 0) & 0x7)
/* Field DEQ_PTR_L - Dequeue Pointer, RW. Default = 0. This field defines the high order bits of the 64-bit address of the current Debug Capability Event Ring Dequeue Pointer. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
#define IMX_USB3_USBSS_XECP_DCERDP_LOW_DEQ_PTR_L_SHIFT 4
#define IMX_USB3_USBSS_XECP_DCERDP_LOW_DEQ_PTR_L_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_XECP_DCERDP_LOW_DEQ_PTR_L(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_XECP_DCERDP_HIGH - Debug Capability Event Ring Dequeue Pointer Register (DCERDP). */
typedef union IMX_USB3_USBSS_XECP_DCERDP_HIGH_union_t {
    uint32_t R;
    struct {
        uint32_t DEQ_PTR_H   :32;                /* Dequeue Pointer, RW. Default = 0. This field defines the high order bits of the 64-bit address of the current Debug Capability Event Ring Dequeue Pointer. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
    } B;
} IMX_USB3_USBSS_XECP_DCERDP_HIGH_t;

/* Register XECP_DCERDP_HIGH - Debug Capability Event Ring Dequeue Pointer Register (DCERDP). */
#define IMX_USB3_USBSS_XECP_DCERDP_HIGH_OFFSET 0x1839C
/* Field DEQ_PTR_H - Dequeue Pointer, RW. Default = 0. This field defines the high order bits of the 64-bit address of the current Debug Capability Event Ring Dequeue Pointer. Software shall initialize this register before setting the Debug Capability Enable field in the DCCTRL register to '1'. */
#define IMX_USB3_USBSS_XECP_DCERDP_HIGH_DEQ_PTR_H_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCERDP_HIGH_DEQ_PTR_H_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_DCERDP_HIGH_DEQ_PTR_H(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_DCCTRL - The Debug Capability Control Register is used to manage the Debug Capability. */
typedef union IMX_USB3_USBSS_XECP_DCCTRL_union_t {
    uint32_t R;
    struct {
        uint32_t DCR         :1;                 /* DbC Run (DCR), RO. Default = '0'. When '0', Debug Device is not in the Configured state. When '1', Debug Device is in the Configured state and bulk Data pipe transactions are accepted by Debug Capability and routed to the IN and OUT Transfer Rings. A '0' to '1' transition of the Port Reset (DCPORTSC:PR) bit will clear this bit to '0'. */
        uint32_t LSE         :1;                 /* Link Status Event Enable (LSE), RW. Default = '0'. Setting this bit to a '1' enables the Debug Capability to generate Port Status Change Events due the Port Link Status Change bit transitioning from a '0' to a '1'. Refer to section 4.19.2 of xHCI specification for more information. */
        uint32_t HOT         :1;                 /* Halt OUT TR (HOT), RW1S. Default = '0'. While this bit is '1' the Debug Capability shall generate STALL TPs for all IN TPs received for the OUT TR. The Debug Capability shall clear this bit when a ClearFeature(ENDPOINT_HALT) request is received for the endpoint. This field is valid only when the Debug Capability is in Run Mode (DCR = 1). When not in Run Mode, this field shall return '0' when read, and writes will have no effect. Refer to section 7.6.4.3 of xHCI specification. */
        uint32_t HIT         :1;                 /* Halt IN TR (HIT), RW1S. Default = '0'. While this bit is '1' the Debug Capability shall generate STALL TPs for all OUT DPs received for the IN TR. The Debug Capability shall clear this bit when a ClearFeature(ENDPOINT_HALT) request is received for the endpoint. This field is valid only when the Debug Capability is in Run Mode (DCR = '1'). When not in Run Mode, this field shall return '0' when read, and writes will have no effect. Refer to section 7.6.4.3 of xHCI specification. */
        uint32_t DRC         :1;                 /* DbC Run Change (DRC), RW1C. Default = '0'. This bit shall be set to '1' when DCR bit is cleared to '0', i.e. by any DbC Port State transition that exits the DbC-Configured state. While this bit is '1' the Debug Capability Doorbell Register (DCDB) is disabled. Software shall clear this bit to re-enable the DCDB. */
        uint32_t _unused5    :11;                /* Reserved */
        uint32_t DMAXBSIZE   :8;                 /* Debug Max Burst Size, RO. Default = xHC.Vendor defined. This field identifies the maximum burst size supported by the bulk endpoints of this DbC implementation. */
        uint32_t DEV_ADDR    :7;                 /* Device Address, RO. Default = 0. This field reports the USB device address assigned to the Debug Device during the enumeration process. This field is valid when the DbC Run bit is '1'. */
        uint32_t DCE         :1;                 /* Debug Capability Enable, RW. Default = '0'. Setting this bit to a '1' enables xHCI USB Debug Capability operation. This bit is a '0' if the USB Debug Capability is disabled. Clearing this bit releases the Root Hub port assigned to the Debug Capability, and terminates any Debug Capability Transfer or Event Ring activity. */
    } B;
} IMX_USB3_USBSS_XECP_DCCTRL_t;

/* Register XECP_DCCTRL - The Debug Capability Control Register is used to manage the Debug Capability. */
#define IMX_USB3_USBSS_XECP_DCCTRL_OFFSET 0x183A0
/* Field DCR - DbC Run (DCR), RO. Default = '0'. When '0', Debug Device is not in the Configured state. When '1', Debug Device is in the Configured state and bulk Data pipe transactions are accepted by Debug Capability and routed to the IN and OUT Transfer Rings. A '0' to '1' transition of the Port Reset (DCPORTSC:PR) bit will clear this bit to '0'. */
#define IMX_USB3_USBSS_XECP_DCCTRL_DCR_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCCTRL_DCR_MASK 0x1
#define IMX_USB3_USBSS_XECP_DCCTRL_DCR(v) (((v) << 0) & 0x1)
/* Field LSE - Link Status Event Enable (LSE), RW. Default = '0'. Setting this bit to a '1' enables the Debug Capability to generate Port Status Change Events due the Port Link Status Change bit transitioning from a '0' to a '1'. Refer to section 4.19.2 of xHCI specification for more information. */
#define IMX_USB3_USBSS_XECP_DCCTRL_LSE_SHIFT 1
#define IMX_USB3_USBSS_XECP_DCCTRL_LSE_MASK 0x2
#define IMX_USB3_USBSS_XECP_DCCTRL_LSE(v) (((v) << 0x1) & 0x2)
/* Field HOT - Halt OUT TR (HOT), RW1S. Default = '0'. While this bit is '1' the Debug Capability shall generate STALL TPs for all IN TPs received for the OUT TR. The Debug Capability shall clear this bit when a ClearFeature(ENDPOINT_HALT) request is received for the endpoint. This field is valid only when the Debug Capability is in Run Mode (DCR = 1). When not in Run Mode, this field shall return '0' when read, and writes will have no effect. Refer to section 7.6.4.3 of xHCI specification. */
#define IMX_USB3_USBSS_XECP_DCCTRL_HOT_SHIFT 2
#define IMX_USB3_USBSS_XECP_DCCTRL_HOT_MASK 0x4
#define IMX_USB3_USBSS_XECP_DCCTRL_HOT(v) (((v) << 0x2) & 0x4)
/* Field HIT - Halt IN TR (HIT), RW1S. Default = '0'. While this bit is '1' the Debug Capability shall generate STALL TPs for all OUT DPs received for the IN TR. The Debug Capability shall clear this bit when a ClearFeature(ENDPOINT_HALT) request is received for the endpoint. This field is valid only when the Debug Capability is in Run Mode (DCR = '1'). When not in Run Mode, this field shall return '0' when read, and writes will have no effect. Refer to section 7.6.4.3 of xHCI specification. */
#define IMX_USB3_USBSS_XECP_DCCTRL_HIT_SHIFT 3
#define IMX_USB3_USBSS_XECP_DCCTRL_HIT_MASK 0x8
#define IMX_USB3_USBSS_XECP_DCCTRL_HIT(v) (((v) << 0x3) & 0x8)
/* Field DRC - DbC Run Change (DRC), RW1C. Default = '0'. This bit shall be set to '1' when DCR bit is cleared to '0', i.e. by any DbC Port State transition that exits the DbC-Configured state. While this bit is '1' the Debug Capability Doorbell Register (DCDB) is disabled. Software shall clear this bit to re-enable the DCDB. */
#define IMX_USB3_USBSS_XECP_DCCTRL_DRC_SHIFT 4
#define IMX_USB3_USBSS_XECP_DCCTRL_DRC_MASK 0x10
#define IMX_USB3_USBSS_XECP_DCCTRL_DRC(v) (((v) << 0x4) & 0x10)
/* Field DMAXBSIZE - Debug Max Burst Size, RO. Default = xHC.Vendor defined. This field identifies the maximum burst size supported by the bulk endpoints of this DbC implementation. */
#define IMX_USB3_USBSS_XECP_DCCTRL_DMAXBSIZE_SHIFT 16
#define IMX_USB3_USBSS_XECP_DCCTRL_DMAXBSIZE_MASK 0xFF0000
#define IMX_USB3_USBSS_XECP_DCCTRL_DMAXBSIZE(v) (((v) << 0x10) & 0xFF0000)
/* Field DEV_ADDR - Device Address, RO. Default = 0. This field reports the USB device address assigned to the Debug Device during the enumeration process. This field is valid when the DbC Run bit is '1'. */
#define IMX_USB3_USBSS_XECP_DCCTRL_DEV_ADDR_SHIFT 24
#define IMX_USB3_USBSS_XECP_DCCTRL_DEV_ADDR_MASK 0x7F000000
#define IMX_USB3_USBSS_XECP_DCCTRL_DEV_ADDR(v) (((v) << 0x18) & 0x7F000000)
/* Field DCE - Debug Capability Enable, RW. Default = '0'. Setting this bit to a '1' enables xHCI USB Debug Capability operation. This bit is a '0' if the USB Debug Capability is disabled. Clearing this bit releases the Root Hub port assigned to the Debug Capability, and terminates any Debug Capability Transfer or Event Ring activity. */
#define IMX_USB3_USBSS_XECP_DCCTRL_DCE_SHIFT 31
#define IMX_USB3_USBSS_XECP_DCCTRL_DCE_MASK 0x80000000
#define IMX_USB3_USBSS_XECP_DCCTRL_DCE(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_XECP_DCST - The Debug Capability Status Register reports capability related status information to software. */
typedef union IMX_USB3_USBSS_XECP_DCST_union_t {
    uint32_t R;
    struct {
        uint32_t ER          :1;                 /* Event Ring Not Empty, RO. Default = '0'. When '1', this field indicates that the Debug Capability Event Ring has a Transfer Event on it. It is automatically cleared to '0' by the xHC when the Debug Capability Event Ring is empty, i.e. the Debug Capability Enqueue Pointer is equal to the Debug Capability Event Ring Dequeue Pointer register. */
        uint32_t _unused1    :23;                /* Reserved */
        uint32_t DBGP_NUM    :8;                 /* Debug Port Number, RO. Default = 0. This field provides the ID of the Root Hub port that the Debug Capability has been automatically attached to. The value is 0 when the Debug Capability is not attached to a Root Hub port. */
    } B;
} IMX_USB3_USBSS_XECP_DCST_t;

/* Register XECP_DCST - The Debug Capability Status Register reports capability related status information to software. */
#define IMX_USB3_USBSS_XECP_DCST_OFFSET 0x183A4
/* Field ER - Event Ring Not Empty, RO. Default = '0'. When '1', this field indicates that the Debug Capability Event Ring has a Transfer Event on it. It is automatically cleared to '0' by the xHC when the Debug Capability Event Ring is empty, i.e. the Debug Capability Enqueue Pointer is equal to the Debug Capability Event Ring Dequeue Pointer register. */
#define IMX_USB3_USBSS_XECP_DCST_ER_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCST_ER_MASK 0x1
#define IMX_USB3_USBSS_XECP_DCST_ER(v) (((v) << 0) & 0x1)
/* Field DBGP_NUM - Debug Port Number, RO. Default = 0. This field provides the ID of the Root Hub port that the Debug Capability has been automatically attached to. The value is 0 when the Debug Capability is not attached to a Root Hub port. */
#define IMX_USB3_USBSS_XECP_DCST_DBGP_NUM_SHIFT 24
#define IMX_USB3_USBSS_XECP_DCST_DBGP_NUM_MASK 0xFF000000
#define IMX_USB3_USBSS_XECP_DCST_DBGP_NUM(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_XECP_DCPORTSC - Debug Capability Port Status and Control Register (DCPORTSC). */
typedef union IMX_USB3_USBSS_XECP_DCPORTSC_union_t {
    uint32_t R;
    struct {
        uint32_t CCS         :1;                 /* Current Connect Status, RO. Default = '0'. '1' = A Root Hub port is connected to a Debug Host and assigned to the Debug Capability. '0' = No Debug Host is present. This value reflects the current state of the port, and may not correspond to the value reported by the Connect Status Change (CSC) field in the Port Status Change Event that was generated by a '0' to '1' transition of this bit. This flag is '0' if Debug Capability Enable (DCE) is '0'. */
        uint32_t PED         :1;                 /* Port Enabled/Disabled, RW. Default = '0'. '1' = Debug Capability Root Hub port is enabled. '0' = Debug Capability Root Hub port is disabled. This flag shall be set to '1' by a '0' to '1' transition of CCS or a '1' to '0' transition of the PR. When PED transitions from '1' to '0' due to the assertion of PR, the port's link shall transition to the Rx.Detect state. This flag may be used by software to enable or disable the operation of the Root Hub port assigned to the Debug Capability. The Debug Capability Root Hub port operation may be disabled by a fault condition (disconnect event or other fault condition, e.g. a LTSSM Polling substate timeout, tPortConfiguration timeout error, etc.), the assertion of DCPORTSC PR, or by software. When the port is disabled (PED = '0') the ports link shall enter the SS.Disabled state and remain there until PED is reasserted ('1') or DCE is negated ('0'). Note that the Root Hub port remains mapped to Debug Capability while PED = '0'. While PED = '0' the Debug Capability will appear to be disconnected to the Debug Host. Note, this bit is not affected by PORTSC PR bit transitions. This field is '0' if DCE or CCS are '0'. */
        uint32_t _unused2    :2;                 /* Reserved */
        uint32_t PR          :1;                 /* Port Reset, RO. Default = '0'. '1' = Port is in Reset. '0' = Port is not in Reset. This bit is set to '1' when the bus reset sequence as defined in the USB Specification is detected on the Root Hub port assigned to the Debug capability. It is cleared when the bus reset sequence is completed by the Debug Host, and the DbC shall transition to the USB Default state. A '0' to '1' transition of this bit shall clear DCPORTSC PED (0). This field is '0' if DCE or CCS are '0'. */
        uint32_t PLS         :4;                 /* Port Link State, RO. Default = RxDetect. This field reflects its current link state. This field is only relevant when a Debug Host is attached (Debug Port Number > 0). Possible values: 0: Link is in the U0 State 1: Link is in the U1 State 2: Link is in the U2 State 3: Link is in the U3 State (Device Suspended) 4: Link is in the Disabled State 5: Link is in the RxDetect State 6: Link is in the Inactive State 7: Link is in the Polling State 8: Link is in the Recovery State 9: Link is in the Hot Reset State 10-15: Reserved Note: Transitions between different states are not reflected until the transition is complete. */
        uint32_t _unused9    :1;                 /* Reserved */
        uint32_t PORTSPEED   :4;                 /* Port Speed, RO. Default = '0'. This field identifies the speed of the port. This field is only relevant when a Debug Host is attached (CCS = '1') in all other cases this field shall indicate Undefined Speed. Possible values: 0: Undefined Speed 1-15: Protocol Speed ID (PSI), refer to section 7.2.1 of xHCI specification for the definition of PSIs. Note: The Debug Capability does not support LS, FS, or HS operation. */
        uint32_t _unused14   :3;                 /* Reserved */
        uint32_t CSC         :1;                 /* Connect Status Change, RW1C. Default = '0'. '1' = Change in CCS. '0' = No change. Indicates a change has occurred in the ports Current Connect Status. The xHC sets this bit to '1' for all changes to the Debug Device connect status, even if system software has not cleared an existing DbC Connect Status Change. For example, the insertion status changes twice before system software has cleared the changed condition, hardware will be setting an already-set bit (i.e., the bit will remain '1'). Software shall clear this bit by writing a '1' to it. This field is '0' if DCE is '0'. */
        uint32_t _unused18   :3;                 /* Reserved */
        uint32_t PRC         :1;                 /* Port Reset Change, RW1C. Default = '0'. This bit is set when reset processing on this port is complete (i.e. a '1' to '0' transition of PR). '0' = No change. '1' = Reset complete. Software shall clear this bit by writing a '1' to it. This field is '0' if DCE is '0'. */
        uint32_t PLC         :1;                 /* Port Link State Change, RW1C. Default = '0'. This flag is set to '1' due to the following PLS transitions: U0 -> U3 (Suspend signaling detected from Debug Host) U3 -> U0 (Resume complete) Polling -> Disabled (Training Error) Ux or Recovery -> Inactive (Error) Software shall clear this bit by writing a '1' to it. This field is '0' if DCE is '0'. */
        uint32_t CEC         :1;                 /* Port Config Error Change, RW1C. Default = '0'. This flag indicates that the port failed to configure its link partner. '0' = No change. '1' = Port Config Error detected. Software shall clear this bit by writing a '1' to it. */
        uint32_t _unused24   :8;                 /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_DCPORTSC_t;

/* Register XECP_DCPORTSC - Debug Capability Port Status and Control Register (DCPORTSC). */
#define IMX_USB3_USBSS_XECP_DCPORTSC_OFFSET 0x183A8
/* Field CCS - Current Connect Status, RO. Default = '0'. '1' = A Root Hub port is connected to a Debug Host and assigned to the Debug Capability. '0' = No Debug Host is present. This value reflects the current state of the port, and may not correspond to the value reported by the Connect Status Change (CSC) field in the Port Status Change Event that was generated by a '0' to '1' transition of this bit. This flag is '0' if Debug Capability Enable (DCE) is '0'. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_CCS_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCPORTSC_CCS_MASK 0x1
#define IMX_USB3_USBSS_XECP_DCPORTSC_CCS(v) (((v) << 0) & 0x1)
/* Field PED - Port Enabled/Disabled, RW. Default = '0'. '1' = Debug Capability Root Hub port is enabled. '0' = Debug Capability Root Hub port is disabled. This flag shall be set to '1' by a '0' to '1' transition of CCS or a '1' to '0' transition of the PR. When PED transitions from '1' to '0' due to the assertion of PR, the port's link shall transition to the Rx.Detect state. This flag may be used by software to enable or disable the operation of the Root Hub port assigned to the Debug Capability. The Debug Capability Root Hub port operation may be disabled by a fault condition (disconnect event or other fault condition, e.g. a LTSSM Polling substate timeout, tPortConfiguration timeout error, etc.), the assertion of DCPORTSC PR, or by software. When the port is disabled (PED = '0') the ports link shall enter the SS.Disabled state and remain there until PED is reasserted ('1') or DCE is negated ('0'). Note that the Root Hub port remains mapped to Debug Capability while PED = '0'. While PED = '0' the Debug Capability will appear to be disconnected to the Debug Host. Note, this bit is not affected by PORTSC PR bit transitions. This field is '0' if DCE or CCS are '0'. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_PED_SHIFT 1
#define IMX_USB3_USBSS_XECP_DCPORTSC_PED_MASK 0x2
#define IMX_USB3_USBSS_XECP_DCPORTSC_PED(v) (((v) << 0x1) & 0x2)
/* Field PR - Port Reset, RO. Default = '0'. '1' = Port is in Reset. '0' = Port is not in Reset. This bit is set to '1' when the bus reset sequence as defined in the USB Specification is detected on the Root Hub port assigned to the Debug capability. It is cleared when the bus reset sequence is completed by the Debug Host, and the DbC shall transition to the USB Default state. A '0' to '1' transition of this bit shall clear DCPORTSC PED (0). This field is '0' if DCE or CCS are '0'. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_PR_SHIFT 4
#define IMX_USB3_USBSS_XECP_DCPORTSC_PR_MASK 0x10
#define IMX_USB3_USBSS_XECP_DCPORTSC_PR(v) (((v) << 0x4) & 0x10)
/* Field PLS - Port Link State, RO. Default = RxDetect. This field reflects its current link state. This field is only relevant when a Debug Host is attached (Debug Port Number > 0). Possible values: 0: Link is in the U0 State 1: Link is in the U1 State 2: Link is in the U2 State 3: Link is in the U3 State (Device Suspended) 4: Link is in the Disabled State 5: Link is in the RxDetect State 6: Link is in the Inactive State 7: Link is in the Polling State 8: Link is in the Recovery State 9: Link is in the Hot Reset State 10-15: Reserved Note: Transitions between different states are not reflected until the transition is complete. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_PLS_SHIFT 5
#define IMX_USB3_USBSS_XECP_DCPORTSC_PLS_MASK 0x1E0
#define IMX_USB3_USBSS_XECP_DCPORTSC_PLS(v) (((v) << 0x5) & 0x1E0)
/* Field PORTSPEED - Port Speed, RO. Default = '0'. This field identifies the speed of the port. This field is only relevant when a Debug Host is attached (CCS = '1') in all other cases this field shall indicate Undefined Speed. Possible values: 0: Undefined Speed 1-15: Protocol Speed ID (PSI), refer to section 7.2.1 of xHCI specification for the definition of PSIs. Note: The Debug Capability does not support LS, FS, or HS operation. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_PORTSPEED_SHIFT 10
#define IMX_USB3_USBSS_XECP_DCPORTSC_PORTSPEED_MASK 0x3C00
#define IMX_USB3_USBSS_XECP_DCPORTSC_PORTSPEED(v) (((v) << 0xA) & 0x3C00)
/* Field CSC - Connect Status Change, RW1C. Default = '0'. '1' = Change in CCS. '0' = No change. Indicates a change has occurred in the ports Current Connect Status. The xHC sets this bit to '1' for all changes to the Debug Device connect status, even if system software has not cleared an existing DbC Connect Status Change. For example, the insertion status changes twice before system software has cleared the changed condition, hardware will be setting an already-set bit (i.e., the bit will remain '1'). Software shall clear this bit by writing a '1' to it. This field is '0' if DCE is '0'. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_CSC_SHIFT 17
#define IMX_USB3_USBSS_XECP_DCPORTSC_CSC_MASK 0x20000
#define IMX_USB3_USBSS_XECP_DCPORTSC_CSC(v) (((v) << 0x11) & 0x20000)
/* Field PRC - Port Reset Change, RW1C. Default = '0'. This bit is set when reset processing on this port is complete (i.e. a '1' to '0' transition of PR). '0' = No change. '1' = Reset complete. Software shall clear this bit by writing a '1' to it. This field is '0' if DCE is '0'. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_PRC_SHIFT 21
#define IMX_USB3_USBSS_XECP_DCPORTSC_PRC_MASK 0x200000
#define IMX_USB3_USBSS_XECP_DCPORTSC_PRC(v) (((v) << 0x15) & 0x200000)
/* Field PLC - Port Link State Change, RW1C. Default = '0'. This flag is set to '1' due to the following PLS transitions: U0 -> U3 (Suspend signaling detected from Debug Host) U3 -> U0 (Resume complete) Polling -> Disabled (Training Error) Ux or Recovery -> Inactive (Error) Software shall clear this bit by writing a '1' to it. This field is '0' if DCE is '0'. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_PLC_SHIFT 22
#define IMX_USB3_USBSS_XECP_DCPORTSC_PLC_MASK 0x400000
#define IMX_USB3_USBSS_XECP_DCPORTSC_PLC(v) (((v) << 0x16) & 0x400000)
/* Field CEC - Port Config Error Change, RW1C. Default = '0'. This flag indicates that the port failed to configure its link partner. '0' = No change. '1' = Port Config Error detected. Software shall clear this bit by writing a '1' to it. */
#define IMX_USB3_USBSS_XECP_DCPORTSC_CEC_SHIFT 23
#define IMX_USB3_USBSS_XECP_DCPORTSC_CEC_MASK 0x800000
#define IMX_USB3_USBSS_XECP_DCPORTSC_CEC(v) (((v) << 0x17) & 0x800000)

/* IMX_USB3_USBSS_XECP_RSVD_2C - XECP_RSVD_2C, RsvdZ. */
typedef union IMX_USB3_USBSS_XECP_RSVD_2C_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :32;                /* Reserved */
    } B;
} IMX_USB3_USBSS_XECP_RSVD_2C_t;

/* Register XECP_RSVD_2C - XECP_RSVD_2C, RsvdZ. */
#define IMX_USB3_USBSS_XECP_RSVD_2C_OFFSET 0x183AC

/* IMX_USB3_USBSS_XECP_DCCP_LOW - Debug Capability Context Pointer Register (DCCP). */
typedef union IMX_USB3_USBSS_XECP_DCCP_LOW_union_t {
    uint32_t R;
    struct {
        uint32_t _unused0    :4;                 /* Reserved */
        uint32_t DBGP_CNTX_PTR_L :28;            /* Debug Capability Context Pointer Register, RW. Default = 0. This field defines the high order bits of the start address of the Debug Capability Context data structure (refer to section 7.6.9 of xHCI specification) associated with the Debug Capability. Software shall initialize this register before setting the Debug Capability Enable bit in the Debug Capability Control Register to '1'. */
    } B;
} IMX_USB3_USBSS_XECP_DCCP_LOW_t;

/* Register XECP_DCCP_LOW - Debug Capability Context Pointer Register (DCCP). */
#define IMX_USB3_USBSS_XECP_DCCP_LOW_OFFSET 0x183B0
/* Field DBGP_CNTX_PTR_L - Debug Capability Context Pointer Register, RW. Default = 0. This field defines the high order bits of the start address of the Debug Capability Context data structure (refer to section 7.6.9 of xHCI specification) associated with the Debug Capability. Software shall initialize this register before setting the Debug Capability Enable bit in the Debug Capability Control Register to '1'. */
#define IMX_USB3_USBSS_XECP_DCCP_LOW_DBGP_CNTX_PTR_L_SHIFT 4
#define IMX_USB3_USBSS_XECP_DCCP_LOW_DBGP_CNTX_PTR_L_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_XECP_DCCP_LOW_DBGP_CNTX_PTR_L(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_XECP_DCCP_HIGH - Debug Capability Context Pointer Register (DCCP). */
typedef union IMX_USB3_USBSS_XECP_DCCP_HIGH_union_t {
    uint32_t R;
    struct {
        uint32_t DBGP_CNTX_PTR_H :32;            /* Debug Capability Context Pointer Register, RW. Default = 0. This field defines the high order bits of the start address of the Debug Capability Context data structure (refer to section 7.6.9 of xHCI specification) associated with the Debug Capability. Software shall initialize this register before setting the Debug Capability Enable bit in the Debug Capability Control Register to '1'. */
    } B;
} IMX_USB3_USBSS_XECP_DCCP_HIGH_t;

/* Register XECP_DCCP_HIGH - Debug Capability Context Pointer Register (DCCP). */
#define IMX_USB3_USBSS_XECP_DCCP_HIGH_OFFSET 0x183B4
/* Field DBGP_CNTX_PTR_H - Debug Capability Context Pointer Register, RW. Default = 0. This field defines the high order bits of the start address of the Debug Capability Context data structure (refer to section 7.6.9 of xHCI specification) associated with the Debug Capability. Software shall initialize this register before setting the Debug Capability Enable bit in the Debug Capability Control Register to '1'. */
#define IMX_USB3_USBSS_XECP_DCCP_HIGH_DBGP_CNTX_PTR_H_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCCP_HIGH_DBGP_CNTX_PTR_H_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_XECP_DCCP_HIGH_DBGP_CNTX_PTR_H(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_XECP_DCDDI1 - Debug Capability Device Descriptor Info Register 1 (DCDDI1). */
typedef union IMX_USB3_USBSS_XECP_DCDDI1_union_t {
    uint32_t R;
    struct {
        uint32_t DBC_PROT    :8;                 /* DbC Protocol, RW. This field is presented by the Debug Device in the USB Interface Descriptor bInterfaceProtocol field. 0: Debug Target vendor defined. 1: GNU Remote Debug Command Set supported. 2-255: Reserved. */
        uint32_t _unused8    :8;                 /* Reserved */
        uint32_t VID         :16;                /* Vendor ID, RW. This field is presented by the Debug Device in the USB Device Descriptor idVendor field. */
    } B;
} IMX_USB3_USBSS_XECP_DCDDI1_t;

/* Register XECP_DCDDI1 - Debug Capability Device Descriptor Info Register 1 (DCDDI1). */
#define IMX_USB3_USBSS_XECP_DCDDI1_OFFSET 0x183B8
/* Field DBC_PROT - DbC Protocol, RW. This field is presented by the Debug Device in the USB Interface Descriptor bInterfaceProtocol field. 0: Debug Target vendor defined. 1: GNU Remote Debug Command Set supported. 2-255: Reserved. */
#define IMX_USB3_USBSS_XECP_DCDDI1_DBC_PROT_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCDDI1_DBC_PROT_MASK 0xFF
#define IMX_USB3_USBSS_XECP_DCDDI1_DBC_PROT(v) (((v) << 0) & 0xFF)
/* Field VID - Vendor ID, RW. This field is presented by the Debug Device in the USB Device Descriptor idVendor field. */
#define IMX_USB3_USBSS_XECP_DCDDI1_VID_SHIFT 16
#define IMX_USB3_USBSS_XECP_DCDDI1_VID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_XECP_DCDDI1_VID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_XECP_DCDDI2 - The Debug Capability Device Descriptor Register 2 identifies the Device Revision and Product ID values that shall be reported by DbC in its Device Descriptor when it is enumerated by a Debug Host. */
typedef union IMX_USB3_USBSS_XECP_DCDDI2_union_t {
    uint32_t R;
    struct {
        uint32_t PROD_ID     :16;                /* Product ID, RW. This field is presented by the Debug Device in the USB Device Descriptor idProduct field. */
        uint32_t DEV_REV     :16;                /* Device Revision, RW. This field is presented by the Debug Device in the USB Device Descriptor bcdDevice field. */
    } B;
} IMX_USB3_USBSS_XECP_DCDDI2_t;

/* Register XECP_DCDDI2 - The Debug Capability Device Descriptor Register 2 identifies the Device Revision and Product ID values that shall be reported by DbC in its Device Descriptor when it is enumerated by a Debug Host. */
#define IMX_USB3_USBSS_XECP_DCDDI2_OFFSET 0x183BC
/* Field PROD_ID - Product ID, RW. This field is presented by the Debug Device in the USB Device Descriptor idProduct field. */
#define IMX_USB3_USBSS_XECP_DCDDI2_PROD_ID_SHIFT 0
#define IMX_USB3_USBSS_XECP_DCDDI2_PROD_ID_MASK 0xFFFF
#define IMX_USB3_USBSS_XECP_DCDDI2_PROD_ID(v) (((v) << 0) & 0xFFFF)
/* Field DEV_REV - Device Revision, RW. This field is presented by the Debug Device in the USB Device Descriptor bcdDevice field. */
#define IMX_USB3_USBSS_XECP_DCDDI2_DEV_REV_SHIFT 16
#define IMX_USB3_USBSS_XECP_DCDDI2_DEV_REV_MASK 0xFFFF0000
#define IMX_USB3_USBSS_XECP_DCDDI2_DEV_REV(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG - USB3_TEST_PORT_REG. */
typedef union IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_union_t {
    uint32_t R;
    struct {
        uint32_t USB3_TEST_CTRL :1;              /* USB3_test_ctrl */
        uint32_t USB3_TEST_LOOP_NUM :15;         /* USB3_test_loop_num */
        uint32_t LINK_TEST_DONE :1;              /* link_test_done */
        uint32_t LINK_TEST_LOOP_PASS :15;        /* link_test_loop_pass */
    } B;
} IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_t;

/* Register XECP_USB3_TEST_PORT0_REG - USB3_TEST_PORT_REG. */
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_OFFSET 0x18800
/* Field USB3_TEST_CTRL - USB3_test_ctrl */
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_USB3_TEST_CTRL_SHIFT 0
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_USB3_TEST_CTRL_MASK 0x1
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_USB3_TEST_CTRL(v) (((v) << 0) & 0x1)
/* Field USB3_TEST_LOOP_NUM - USB3_test_loop_num */
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_USB3_TEST_LOOP_NUM_SHIFT 1
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_USB3_TEST_LOOP_NUM_MASK 0xFFFE
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_USB3_TEST_LOOP_NUM(v) (((v) << 0x1) & 0xFFFE)
/* Field LINK_TEST_DONE - link_test_done */
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_LINK_TEST_DONE_SHIFT 16
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_LINK_TEST_DONE_MASK 0x10000
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_LINK_TEST_DONE(v) (((v) << 0x10) & 0x10000)
/* Field LINK_TEST_LOOP_PASS - link_test_loop_pass */
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_LINK_TEST_LOOP_PASS_SHIFT 17
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_LINK_TEST_LOOP_PASS_MASK 0xFFFE0000
#define IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_LINK_TEST_LOOP_PASS(v) (((v) << 0x11) & 0xFFFE0000)

/* IMX_USB3_USBSS_USB_CONF - Global Configuration Register */
typedef union IMX_USB3_USBSS_USB_CONF_union_t {
    uint32_t R;
    struct {
        uint32_t CFGRST      :1;                 /* Reset USB device configuration. Writing '1' to this bit resets USB device configuration, leaving only EP0 IN/OUT active (all other EP-related registers will be loaded with default values). Any configuration/interface change, including adding new IF, must be preceded with configuration reset, adding current IF's as well as new IF. Writing '0' has no effect. This bit is always '0' while reading. */
        uint32_t CFGSET      :1;                 /* Set Configuration. Software writes '1' to this bit when it receives SET_CONFIGURATION request with non-zero configuration number. CPU sets this bit after setting requested configuration and before setting REQ_CMPL bit in the EP_CMD register. Configuration will be set internally in the hardware when REQ_CMPL bit will be set. Writing '0' has no effect. The actual configuration status can be checked in the USB_STS register. This bit is always '0' while reading. */
        uint32_t RESERVED0   :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t USB3DIS     :1;                 /* Disconnect USB device in SuperSpeed. Writing '1' to this bit disconnects USB in Super Speed. The actual USB connection status in the SS mode can be checked in the USB_STS register. If link is in U3 (SuperSpeed PHY clock is disabled) while software writes USB3DIS bit, first the hardware automatically wakes up the PHY to the P2 to turn on the PHY clock (clklink), and second, all operations related to device disconnection cease. Writing '0' has no effect. To connect disconnected device, CPU performs software reset (UCB_CFG.SWRST). This bit is always '0' while reading. */
        uint32_t USB2DIS     :1;                 /* Disconnect USB device in HS/FS. Writing '1' to this bit disconnects USB in HS/FS. The actual USB connection status in HS/FS can be checked in the USB_STS register. Writing '0' has no effect. To connect disconnected device, CPU performs software reset (UCB_CFG.SWRST). This bit is always '0' while reading. */
        uint32_t LENDIAN     :1;                 /* Little Endian access. Writing '1' to this bit sets Little Endian byte order for SFRs access. By default (after hardware reset), USBSS-DEV acts as little-endian device. Writing '0' has no effect. When both LENDIAN and BENDIAN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t BENDIAN     :1;                 /* Big Endian Access. Writing '1' to this bit sets Big Endian byte order for SFRs access. Writing '0' has no effect. When both LENDIAN and BENDIAN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t SWRST       :1;                 /* Device software reset. When set to 1, the entire USBSS-DEV is reset. The SWRST resets most flip-flops in entire USBSS-DEV. This bit is also used to connect disconnected device. Writing '0' has no effect. */
        uint32_t DSING       :1;                 /* Singular DMA transfer mode. When set to '1', all DMA transfers are singular: when single TRB chain ends, the transfer ends. Writing '0' has no effect. This bit is always '0' while reading. The status of this settings can be check in the USB_STS.DTRANS bit. */
        uint32_t DMULT       :1;                 /* Multiple DMA transfers mode. When set to '1', all DMA transfers are multiple: when current TRB chain ends, the DMA checks if next TRB is ready and, if owner bit (C) is correct, starts next chain; otherwise, it stops current EP transfer. Writing '0' has no effect. This bit is always '0' while reading. The status of this settings can be check in the USB_STS.DTRANS bit. */
        uint32_t DMAOFFEN    :1;                 /* DMA clock turn-off enable. Writing '1' to this bit enables DMA clock turning-off when device exits U0 link state in SuperSpeed mode. When both DMAOFFDS and DMAOFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t DMAOFFDS    :1;                 /* DMA clock turn-off disable. Writing '1' to this bit disables DMA clock turning-off when device exits U0 link state in SuperSpeed mode. When both DMAOFFDS and DMAOFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t CFORCE_FS   :1;                 /* Clear Force Full Speed. Writing '1' to this bit stop forcing Full Speed when USBSS-DEV operates in USB2.0 mode (stop disabling High Speed). When both SFORCE_FS and CFORCE_FS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. The status of this settings can be check in the USB_STS.DISABLE_HS bit. This bit is always '0' while reading. */
        uint32_t SFORCE_FS   :1;                 /* Set Force Full Speed. Writing '1' to this bit forces Full Speed when USBSS-DEV operates in USB2.0 mode (disables High Speed). When both SFORCE_FS and CFORCE_FS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. The status of this settings can be check in the USB_STS.DISABLE_HS bit. This bit is always '0' while reading. */
        uint32_t DEVEN       :1;                 /* Device enable. After Power-On-Reset the USBSS_DEV is disconnected from the USB bus. To connect the device into the USB bus the software has to write '1' to DEVEN bit - this couse connection of the VBUS input to the internal device logic and connetion to the USB bus as a result (inside of USBSS_DEV an internal VBUS is used which which is the and gate: VBUS input AND USB_STS.DEVS bit in SFRs). Writing '1' to the DEVEN bit sets to '1' the USB_STS.DEVS bit. Writing '0' has no effect. This bit is always '0' while reading. */
        uint32_t DEVDS       :1;                 /* Device disable. Writing '1' to the DEVDS bit sets to '0' the USB_STS.DEVS bit. Check also the DEVEN bit description. Writing '0' has no effect. This bit is always '0' while reading. */
        uint32_t L1EN        :1;                 /* L1 LPM state entry enable (device side, HS/FS mode only). Writing '1' to this bit enables USB2.0 LPM to enter L1 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both L1EN and L1DS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t L1DS        :1;                 /* L1 LPM state entry disable (HS/FS mode only). Writing '1' to this bit disables USB2.0 LPM from entering L1 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both L1EN and L1DS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t CLK2OFFEN   :1;                 /* USB 2.0 clock gate disable. Writing '1' to this bit enables hsfs clock turning-off when device enters L2 LPM state in HS/FS mode. The actual 'USB 2.0 clock gate' status in can be checked in the USB_STS.USB2OFF register. When both CLK2OFFDS and CLK2OFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t CLK2OFFDS   :1;                 /* USB 2.0 clock gate enable. Writing '1' to this bit disables hsfs clock turning-off when device enters L2 LPM state in HS/FS mode. The actual 'USB 2.0 clock gate' status in can be checked in the USB_STS.USB2OFF register. When both CLK2OFFDS and CLK2OFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t LGO_L0      :1;                 /* L0 LPM state entry request (HS/FS mode only). Writing '1' will trigger an attempt to perform transition to L0 LPM state. This bit will be automatically cleared to '0' after LPM enter L0 state. Result of the request (LPM enters L0 or not) can be verified by reading LPMST (LPM state) field in USB_STS register. Writing '0' has no effect. If the LPM is suspended (L2 state) and CPU set this bit to'1', upstream will start driving resume signaling to indicate remote wakeup. */
        uint32_t CLK3OFFEN   :1;                 /* USB 3.0 clock gate disable. Writing '1' to this bit enables pclk clock turning-off when device enters U3 link state in SS mode. The actual 'USB 3.0 clock gate' status in can be checked in the USB_STS.USB3OFF register. When both CLK3OFFDS and CLK3OFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t CLK3OFFDS   :1;                 /* USB 3.0 clock gate enable. Writing '1' to this bit disables pclk clock turning-off when device enters U3 link state in SS mode. The actual 'USB 3.0 clock gate' status in can be checked in the USB_STS.USB3OFF register. When both CLK3OFFDS and CLK3OFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t RESERVED1   :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t U1EN        :1;                 /* U1 state entry enable (device side, SS mode only), Writing '1' to this bit enables link layer to enter U1 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both U1EN and U1DS bits are set to '1' while writing to USB_CONF register, none of the operations associated with these bits will be performed. This bit is always '0' while reading. */
        uint32_t U1DS        :1;                 /* U1 state entry disable (SS mode only). Writing '1' to this bit disables link layer from entering U1 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both U1EN and U1DS bits are set to '1' while writing to USB_CONF register, none of the operations associated with these bits will be performed. This bit is always '0' while reading. */
        uint32_t U2EN        :1;                 /* U2 state entry enable (device side, SS mode only). Writing '1' to this bit enables link layer to enter U2 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both U2EN and U2DS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
        uint32_t U2DS        :1;                 /* U2 state entry disable (SS mode only). Writing '1' to this bit disables link layer from entering U2 state. Status of this bit can be checked in the USB_STS register. When both U2EN and U2DS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. Writing '0' has no effect. This bit is always '0' while reading. */
        uint32_t LGO_U0      :1;                 /* U0 state entry request (SS mode only). Writing '1' will trigger an attempt to perform transition to U0 state. If the link is suspended (U3 state) and CPU set this bit to'1', link will start driving resume signaling on its upstream link to indicate remote wakeup. The Function Wake Notification should be send using USB_CMD.SDNFW bit. Writing '0' has no effect. */
        uint32_t LGO_U1      :1;                 /* U1 state entry request (SS mode only). Writing '1' will trigger an attempt to perform transition to U1 state. This bit will be automatically cleared to '0' after link layer finishes U1 request. Result of the request (link layer enters U1 or not) can be verified by reading LTS (link state) field in USB_STS register. Writing '1' has no effect when USB_STS.LGOU1ENS is set to '0'. Writing '0' has no effect. */
        uint32_t LGO_U2      :1;                 /* U2 state entry request (SS mode only). Writing '1' will trigger an attempt to perform transition to U2 state. This bit will be automatically cleared to '0' after link layer finishes U2 request. Result of the request (link layer enters U2 or not) can be verified by reading LTS (link state) field in USB_STS register. Writing '1' has no effect when USB_STS.LGOU2ENS is set to '0'. Writing '0' has no effect. */
        uint32_t LGO_SSINACT :1;                 /* SS.Inactive state entry request (SS mode only). This bit can be used only if USBSS-DEV is part of the CDNS USB OTG Controller (USB_CAP.OTG_READY bit is 1 while reading). In other cases should not be used and returns 0 when read. Writing '1' will trigger an attempt to perform transition to SS.Inactive state. Should be used only if Link is in U0 or Recovery state. This bit will be automatically cleared to '0' after link layer finishes SS.Inactive request. Result of the request (link layer enters SS.Inactive or not) can be verified by reading LTS (link state) field in USB_STS register. Writing '0' has no effect */
    } B;
} IMX_USB3_USBSS_USB_CONF_t;

/* Register USB_CONF - Global Configuration Register */
#define IMX_USB3_USBSS_USB_CONF_OFFSET 0x20000
/* Field CFGRST - Reset USB device configuration. Writing '1' to this bit resets USB device configuration, leaving only EP0 IN/OUT active (all other EP-related registers will be loaded with default values). Any configuration/interface change, including adding new IF, must be preceded with configuration reset, adding current IF's as well as new IF. Writing '0' has no effect. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_CFGRST_SHIFT 0
#define IMX_USB3_USBSS_USB_CONF_CFGRST_MASK 0x1
#define IMX_USB3_USBSS_USB_CONF_CFGRST(v) (((v) << 0) & 0x1)
/* Field CFGSET - Set Configuration. Software writes '1' to this bit when it receives SET_CONFIGURATION request with non-zero configuration number. CPU sets this bit after setting requested configuration and before setting REQ_CMPL bit in the EP_CMD register. Configuration will be set internally in the hardware when REQ_CMPL bit will be set. Writing '0' has no effect. The actual configuration status can be checked in the USB_STS register. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_CFGSET_SHIFT 1
#define IMX_USB3_USBSS_USB_CONF_CFGSET_MASK 0x2
#define IMX_USB3_USBSS_USB_CONF_CFGSET(v) (((v) << 0x1) & 0x2)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_CONF_RESERVED0_SHIFT 2
#define IMX_USB3_USBSS_USB_CONF_RESERVED0_MASK 0x4
#define IMX_USB3_USBSS_USB_CONF_RESERVED0(v) (((v) << 0x2) & 0x4)
/* Field USB3DIS - Disconnect USB device in SuperSpeed. Writing '1' to this bit disconnects USB in Super Speed. The actual USB connection status in the SS mode can be checked in the USB_STS register. If link is in U3 (SuperSpeed PHY clock is disabled) while software writes USB3DIS bit, first the hardware automatically wakes up the PHY to the P2 to turn on the PHY clock (clklink), and second, all operations related to device disconnection cease. Writing '0' has no effect. To connect disconnected device, CPU performs software reset (UCB_CFG.SWRST). This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_USB3DIS_SHIFT 3
#define IMX_USB3_USBSS_USB_CONF_USB3DIS_MASK 0x8
#define IMX_USB3_USBSS_USB_CONF_USB3DIS(v) (((v) << 0x3) & 0x8)
/* Field USB2DIS - Disconnect USB device in HS/FS. Writing '1' to this bit disconnects USB in HS/FS. The actual USB connection status in HS/FS can be checked in the USB_STS register. Writing '0' has no effect. To connect disconnected device, CPU performs software reset (UCB_CFG.SWRST). This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_USB2DIS_SHIFT 4
#define IMX_USB3_USBSS_USB_CONF_USB2DIS_MASK 0x10
#define IMX_USB3_USBSS_USB_CONF_USB2DIS(v) (((v) << 0x4) & 0x10)
/* Field LENDIAN - Little Endian access. Writing '1' to this bit sets Little Endian byte order for SFRs access. By default (after hardware reset), USBSS-DEV acts as little-endian device. Writing '0' has no effect. When both LENDIAN and BENDIAN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_LENDIAN_SHIFT 5
#define IMX_USB3_USBSS_USB_CONF_LENDIAN_MASK 0x20
#define IMX_USB3_USBSS_USB_CONF_LENDIAN(v) (((v) << 0x5) & 0x20)
/* Field BENDIAN - Big Endian Access. Writing '1' to this bit sets Big Endian byte order for SFRs access. Writing '0' has no effect. When both LENDIAN and BENDIAN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_BENDIAN_SHIFT 6
#define IMX_USB3_USBSS_USB_CONF_BENDIAN_MASK 0x40
#define IMX_USB3_USBSS_USB_CONF_BENDIAN(v) (((v) << 0x6) & 0x40)
/* Field SWRST - Device software reset. When set to 1, the entire USBSS-DEV is reset. The SWRST resets most flip-flops in entire USBSS-DEV. This bit is also used to connect disconnected device. Writing '0' has no effect. */
#define IMX_USB3_USBSS_USB_CONF_SWRST_SHIFT 7
#define IMX_USB3_USBSS_USB_CONF_SWRST_MASK 0x80
#define IMX_USB3_USBSS_USB_CONF_SWRST(v) (((v) << 0x7) & 0x80)
/* Field DSING - Singular DMA transfer mode. When set to '1', all DMA transfers are singular: when single TRB chain ends, the transfer ends. Writing '0' has no effect. This bit is always '0' while reading. The status of this settings can be check in the USB_STS.DTRANS bit. */
#define IMX_USB3_USBSS_USB_CONF_DSING_SHIFT 8
#define IMX_USB3_USBSS_USB_CONF_DSING_MASK 0x100
#define IMX_USB3_USBSS_USB_CONF_DSING(v) (((v) << 0x8) & 0x100)
/* Field DMULT - Multiple DMA transfers mode. When set to '1', all DMA transfers are multiple: when current TRB chain ends, the DMA checks if next TRB is ready and, if owner bit (C) is correct, starts next chain; otherwise, it stops current EP transfer. Writing '0' has no effect. This bit is always '0' while reading. The status of this settings can be check in the USB_STS.DTRANS bit. */
#define IMX_USB3_USBSS_USB_CONF_DMULT_SHIFT 9
#define IMX_USB3_USBSS_USB_CONF_DMULT_MASK 0x200
#define IMX_USB3_USBSS_USB_CONF_DMULT(v) (((v) << 0x9) & 0x200)
/* Field DMAOFFEN - DMA clock turn-off enable. Writing '1' to this bit enables DMA clock turning-off when device exits U0 link state in SuperSpeed mode. When both DMAOFFDS and DMAOFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_DMAOFFEN_SHIFT 10
#define IMX_USB3_USBSS_USB_CONF_DMAOFFEN_MASK 0x400
#define IMX_USB3_USBSS_USB_CONF_DMAOFFEN(v) (((v) << 0xA) & 0x400)
/* Field DMAOFFDS - DMA clock turn-off disable. Writing '1' to this bit disables DMA clock turning-off when device exits U0 link state in SuperSpeed mode. When both DMAOFFDS and DMAOFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_DMAOFFDS_SHIFT 11
#define IMX_USB3_USBSS_USB_CONF_DMAOFFDS_MASK 0x800
#define IMX_USB3_USBSS_USB_CONF_DMAOFFDS(v) (((v) << 0xB) & 0x800)
/* Field CFORCE_FS - Clear Force Full Speed. Writing '1' to this bit stop forcing Full Speed when USBSS-DEV operates in USB2.0 mode (stop disabling High Speed). When both SFORCE_FS and CFORCE_FS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. The status of this settings can be check in the USB_STS.DISABLE_HS bit. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_CFORCE_FS_SHIFT 12
#define IMX_USB3_USBSS_USB_CONF_CFORCE_FS_MASK 0x1000
#define IMX_USB3_USBSS_USB_CONF_CFORCE_FS(v) (((v) << 0xC) & 0x1000)
/* Field SFORCE_FS - Set Force Full Speed. Writing '1' to this bit forces Full Speed when USBSS-DEV operates in USB2.0 mode (disables High Speed). When both SFORCE_FS and CFORCE_FS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. The status of this settings can be check in the USB_STS.DISABLE_HS bit. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_SFORCE_FS_SHIFT 13
#define IMX_USB3_USBSS_USB_CONF_SFORCE_FS_MASK 0x2000
#define IMX_USB3_USBSS_USB_CONF_SFORCE_FS(v) (((v) << 0xD) & 0x2000)
/* Field DEVEN - Device enable. After Power-On-Reset the USBSS_DEV is disconnected from the USB bus. To connect the device into the USB bus the software has to write '1' to DEVEN bit - this couse connection of the VBUS input to the internal device logic and connetion to the USB bus as a result (inside of USBSS_DEV an internal VBUS is used which which is the and gate: VBUS input AND USB_STS.DEVS bit in SFRs). Writing '1' to the DEVEN bit sets to '1' the USB_STS.DEVS bit. Writing '0' has no effect. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_DEVEN_SHIFT 14
#define IMX_USB3_USBSS_USB_CONF_DEVEN_MASK 0x4000
#define IMX_USB3_USBSS_USB_CONF_DEVEN(v) (((v) << 0xE) & 0x4000)
/* Field DEVDS - Device disable. Writing '1' to the DEVDS bit sets to '0' the USB_STS.DEVS bit. Check also the DEVEN bit description. Writing '0' has no effect. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_DEVDS_SHIFT 15
#define IMX_USB3_USBSS_USB_CONF_DEVDS_MASK 0x8000
#define IMX_USB3_USBSS_USB_CONF_DEVDS(v) (((v) << 0xF) & 0x8000)
/* Field L1EN - L1 LPM state entry enable (device side, HS/FS mode only). Writing '1' to this bit enables USB2.0 LPM to enter L1 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both L1EN and L1DS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_L1EN_SHIFT 16
#define IMX_USB3_USBSS_USB_CONF_L1EN_MASK 0x10000
#define IMX_USB3_USBSS_USB_CONF_L1EN(v) (((v) << 0x10) & 0x10000)
/* Field L1DS - L1 LPM state entry disable (HS/FS mode only). Writing '1' to this bit disables USB2.0 LPM from entering L1 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both L1EN and L1DS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_L1DS_SHIFT 17
#define IMX_USB3_USBSS_USB_CONF_L1DS_MASK 0x20000
#define IMX_USB3_USBSS_USB_CONF_L1DS(v) (((v) << 0x11) & 0x20000)
/* Field CLK2OFFEN - USB 2.0 clock gate disable. Writing '1' to this bit enables hsfs clock turning-off when device enters L2 LPM state in HS/FS mode. The actual 'USB 2.0 clock gate' status in can be checked in the USB_STS.USB2OFF register. When both CLK2OFFDS and CLK2OFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_CLK2OFFEN_SHIFT 18
#define IMX_USB3_USBSS_USB_CONF_CLK2OFFEN_MASK 0x40000
#define IMX_USB3_USBSS_USB_CONF_CLK2OFFEN(v) (((v) << 0x12) & 0x40000)
/* Field CLK2OFFDS - USB 2.0 clock gate enable. Writing '1' to this bit disables hsfs clock turning-off when device enters L2 LPM state in HS/FS mode. The actual 'USB 2.0 clock gate' status in can be checked in the USB_STS.USB2OFF register. When both CLK2OFFDS and CLK2OFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_CLK2OFFDS_SHIFT 19
#define IMX_USB3_USBSS_USB_CONF_CLK2OFFDS_MASK 0x80000
#define IMX_USB3_USBSS_USB_CONF_CLK2OFFDS(v) (((v) << 0x13) & 0x80000)
/* Field LGO_L0 - L0 LPM state entry request (HS/FS mode only). Writing '1' will trigger an attempt to perform transition to L0 LPM state. This bit will be automatically cleared to '0' after LPM enter L0 state. Result of the request (LPM enters L0 or not) can be verified by reading LPMST (LPM state) field in USB_STS register. Writing '0' has no effect. If the LPM is suspended (L2 state) and CPU set this bit to'1', upstream will start driving resume signaling to indicate remote wakeup. */
#define IMX_USB3_USBSS_USB_CONF_LGO_L0_SHIFT 20
#define IMX_USB3_USBSS_USB_CONF_LGO_L0_MASK 0x100000
#define IMX_USB3_USBSS_USB_CONF_LGO_L0(v) (((v) << 0x14) & 0x100000)
/* Field CLK3OFFEN - USB 3.0 clock gate disable. Writing '1' to this bit enables pclk clock turning-off when device enters U3 link state in SS mode. The actual 'USB 3.0 clock gate' status in can be checked in the USB_STS.USB3OFF register. When both CLK3OFFDS and CLK3OFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_CLK3OFFEN_SHIFT 21
#define IMX_USB3_USBSS_USB_CONF_CLK3OFFEN_MASK 0x200000
#define IMX_USB3_USBSS_USB_CONF_CLK3OFFEN(v) (((v) << 0x15) & 0x200000)
/* Field CLK3OFFDS - USB 3.0 clock gate enable. Writing '1' to this bit disables pclk clock turning-off when device enters U3 link state in SS mode. The actual 'USB 3.0 clock gate' status in can be checked in the USB_STS.USB3OFF register. When both CLK3OFFDS and CLK3OFFEN bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_CLK3OFFDS_SHIFT 22
#define IMX_USB3_USBSS_USB_CONF_CLK3OFFDS_MASK 0x400000
#define IMX_USB3_USBSS_USB_CONF_CLK3OFFDS(v) (((v) << 0x16) & 0x400000)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_CONF_RESERVED1_SHIFT 23
#define IMX_USB3_USBSS_USB_CONF_RESERVED1_MASK 0x800000
#define IMX_USB3_USBSS_USB_CONF_RESERVED1(v) (((v) << 0x17) & 0x800000)
/* Field U1EN - U1 state entry enable (device side, SS mode only), Writing '1' to this bit enables link layer to enter U1 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both U1EN and U1DS bits are set to '1' while writing to USB_CONF register, none of the operations associated with these bits will be performed. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_U1EN_SHIFT 24
#define IMX_USB3_USBSS_USB_CONF_U1EN_MASK 0x1000000
#define IMX_USB3_USBSS_USB_CONF_U1EN(v) (((v) << 0x18) & 0x1000000)
/* Field U1DS - U1 state entry disable (SS mode only). Writing '1' to this bit disables link layer from entering U1 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both U1EN and U1DS bits are set to '1' while writing to USB_CONF register, none of the operations associated with these bits will be performed. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_U1DS_SHIFT 25
#define IMX_USB3_USBSS_USB_CONF_U1DS_MASK 0x2000000
#define IMX_USB3_USBSS_USB_CONF_U1DS(v) (((v) << 0x19) & 0x2000000)
/* Field U2EN - U2 state entry enable (device side, SS mode only). Writing '1' to this bit enables link layer to enter U2 state. Status of this bit can be checked in the USB_STS register. Writing '0' has no effect. When both U2EN and U2DS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_U2EN_SHIFT 26
#define IMX_USB3_USBSS_USB_CONF_U2EN_MASK 0x4000000
#define IMX_USB3_USBSS_USB_CONF_U2EN(v) (((v) << 0x1A) & 0x4000000)
/* Field U2DS - U2 state entry disable (SS mode only). Writing '1' to this bit disables link layer from entering U2 state. Status of this bit can be checked in the USB_STS register. When both U2EN and U2DS bits are set to '1' while writing to USB_CONF register, the device behaviour is udefined. Writing '0' has no effect. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CONF_U2DS_SHIFT 27
#define IMX_USB3_USBSS_USB_CONF_U2DS_MASK 0x8000000
#define IMX_USB3_USBSS_USB_CONF_U2DS(v) (((v) << 0x1B) & 0x8000000)
/* Field LGO_U0 - U0 state entry request (SS mode only). Writing '1' will trigger an attempt to perform transition to U0 state. If the link is suspended (U3 state) and CPU set this bit to'1', link will start driving resume signaling on its upstream link to indicate remote wakeup. The Function Wake Notification should be send using USB_CMD.SDNFW bit. Writing '0' has no effect. */
#define IMX_USB3_USBSS_USB_CONF_LGO_U0_SHIFT 28
#define IMX_USB3_USBSS_USB_CONF_LGO_U0_MASK 0x10000000
#define IMX_USB3_USBSS_USB_CONF_LGO_U0(v) (((v) << 0x1C) & 0x10000000)
/* Field LGO_U1 - U1 state entry request (SS mode only). Writing '1' will trigger an attempt to perform transition to U1 state. This bit will be automatically cleared to '0' after link layer finishes U1 request. Result of the request (link layer enters U1 or not) can be verified by reading LTS (link state) field in USB_STS register. Writing '1' has no effect when USB_STS.LGOU1ENS is set to '0'. Writing '0' has no effect. */
#define IMX_USB3_USBSS_USB_CONF_LGO_U1_SHIFT 29
#define IMX_USB3_USBSS_USB_CONF_LGO_U1_MASK 0x20000000
#define IMX_USB3_USBSS_USB_CONF_LGO_U1(v) (((v) << 0x1D) & 0x20000000)
/* Field LGO_U2 - U2 state entry request (SS mode only). Writing '1' will trigger an attempt to perform transition to U2 state. This bit will be automatically cleared to '0' after link layer finishes U2 request. Result of the request (link layer enters U2 or not) can be verified by reading LTS (link state) field in USB_STS register. Writing '1' has no effect when USB_STS.LGOU2ENS is set to '0'. Writing '0' has no effect. */
#define IMX_USB3_USBSS_USB_CONF_LGO_U2_SHIFT 30
#define IMX_USB3_USBSS_USB_CONF_LGO_U2_MASK 0x40000000
#define IMX_USB3_USBSS_USB_CONF_LGO_U2(v) (((v) << 0x1E) & 0x40000000)
/* Field LGO_SSINACT - SS.Inactive state entry request (SS mode only). This bit can be used only if USBSS-DEV is part of the CDNS USB OTG Controller (USB_CAP.OTG_READY bit is 1 while reading). In other cases should not be used and returns 0 when read. Writing '1' will trigger an attempt to perform transition to SS.Inactive state. Should be used only if Link is in U0 or Recovery state. This bit will be automatically cleared to '0' after link layer finishes SS.Inactive request. Result of the request (link layer enters SS.Inactive or not) can be verified by reading LTS (link state) field in USB_STS register. Writing '0' has no effect */
#define IMX_USB3_USBSS_USB_CONF_LGO_SSINACT_SHIFT 31
#define IMX_USB3_USBSS_USB_CONF_LGO_SSINACT_MASK 0x80000000
#define IMX_USB3_USBSS_USB_CONF_LGO_SSINACT(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_USB_STS - Global Status Register */
typedef union IMX_USB3_USBSS_USB_STS_union_t {
    uint32_t R;
    struct {
        uint32_t CFGSTS      :1;                 /* Configuration status. 1 - device is in the configured state 0 - device is not configured This bit set during SET_CONFIGURATION request means that status stage of this request was finished successfully, thus device configuration was finished successfully. */
        uint32_t MEM_OV      :1;                 /* On-chip memory overflow. 0 - On-chip memory status OK 1 - On-chip memory overflow Memory overflow may occur if, during enumeration (SET_CONFIGURATION request) device software will try to turn on too many endpoints or will try to set too much endpoinds buffers (see EP_CFG.BUFFERING). After each completion of enumeration software should check this bit, and when a memory overflow occurred, software must delete current configuration (using USB_CONF.CFGRST bit) and then set the one that requires less on-chip memory. For available memory calculation, the CDNS_USBSSDEV_ATTACHED_MEM_SIZE define parameter is used. */
        uint32_t USB3CONS    :1;                 /* SuperSpeed connection status. 0 - USB in SuperSpeed mode disconnected 1 - USB in SuperSpeed mode connected */
        uint32_t DTRANS      :1;                 /* DMA transfer configuration status. 0 - single request - Single TRB chain. Single request (DRDY/Doorbell) triggers DMA, which transfers single TRB chain only and ends the EP transfer. 1 - single request - Multiple TRB chain. Single request (DRDY/Doorbell) triggers DMA which transfers TRB chains until the owner of the new chain is not DMA (this causes a TRB error interrupt). This DMA transfer configuration settings can be changed by using bits USB_CONF.DSING and USB_CONF.DMULT. */
        uint32_t USBSPEED    :3;                 /* Device speed: 0: undef., 1: LowSpeed (not supported), 2: FullSpeed, 3: HighSpeed, 4: SuperSpeed, 5-7: Reserved */
        uint32_t ENDIAN_MIRROR :1;               /* Little/Big Endian byte order for SFR access. 0 - Little Endian order (default after hardware reset) 1 - Big Endian order Endian byte order for SFR access can be changed by setting BENDIAN or LEDNIAN bits in USB_CONF register. */
        uint32_t CLK2OFF     :1;                 /* HS/FS clock turn-off status. When CLK2OFF bit is '0', the utmisuspendm output signal is not set low in USB2.0 suspend state (L2 state), thus USB2.0 PHY does not turn off the hsfs clock 0 - hsfs clock is always on 1 - hsfs clock turn-off in L2 (HS/FS mode) is enabled (default after hardware reset) */
        uint32_t CLK3OFF     :1;                 /* PCLK clock turn-off status. When CLK3OFF bit is '0', the phypowerdown output signal is not set to '11' in U3 link state, thus USB3.0 PHY does not turn off the pclk clock. 0 - pclk clock is always on 1 - pclk clock turn-off in U3 (SS mode) is enabled (default after hardware reset) */
        uint32_t IN_RST      :1;                 /* Controler in reset state. This bit indicate that whole (in case of POR) or part of controller (in case of SWRST or USB resets) currently is in reset state. As controller has registers in both clock domains (system, and USB), internal reset synchronization between these domains may take longer than the cause of the reset (e.g active reset_n input). Thus it is recommended to check if controller is not in reset state, before software starts its operations (especially after POR). 0 - Internal reset is active 1 - Internal reset is not active and controller is fully operational. */
        uint32_t RESERVED0   :3;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t DEVS        :1;                 /* Device enable Status 0 - USB device is disabled (VBUS input is disconnected from internal logic) 1 - USB device is enabled (VBUS input is connected to the internal logic) This bit can be changed by setting DEVEN or DEVDS bits in USB_CONF register. */
        uint32_t ADDRESSED   :1;                 /* Address status: 0 - USB device is default state 1 - USB device is at least in address state (Function Address was set by the SW) */
        uint32_t L1ENS       :1;                 /* L1 LPM state enable status (valid for HS/FS mode only). 0 - Entering to L1 LPM state disabled 1 - Entering to L1 LPM state enabled */
        uint32_t VBUSS       :1;                 /* Internal VBUS connection status. 0 - internal VBUS is not detected 1 - internal VBUS is detected */
        uint32_t LPMST       :2;                 /* HS/FS LPM state (valid for HS/FS mode only). This field reflects USBSS-DEV current LPM (used in HS/FS mode) state: 0 - L0 State 1 - L1 State 2 - L2 State 3 - L3 State */
        uint32_t USB2CONS    :1;                 /* HS/FS mode connection enable status (valid for HS/FS mode only). 0 - the disconnect bit for HS/FS mode is set (USB_CONF.USB2DIS) 1 - the disconnect bit for HS/FS mode is not set (device can be connected in this mode) The actual connection status can be checked in the USB_STS.USBSPEED register */
        uint32_t DISABLE_HS  :1;                 /* DisableHS status (valid for HS/FS mode only) 0 - High Speed operations in USB2.0 (FS/HS) mode not disabled 1 - High Speed operations in USB2.0 (FS/HS) mode disabled */
        uint32_t RESERVED1   :2;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t U1ENS       :1;                 /* U1 state enable status (valid in SS mode only): 0 - Entering to U1 state disabled 1 - Entering to U1 state enabled */
        uint32_t U2ENS       :1;                 /* U2 state enable status (valid in SS mode only): 0 - Entering to U2 state disabled 1 - Entering to U2 state enabled */
        uint32_t LST         :4;                 /* SuperSpeed Link LTSSM state. This field reflects USBSS-DEV current SuperSpeed link state: 0 - U0 State 1 - U1 State 2 - U2 State 3 - U3 State (Device Suspended) 4 - Disabled State 5 - RxDetect State 6 - Inactive State 7 - Polling State 8 - Recovery State 9 - Hot Reset State 10 - Compliance Mode State 11 - Loopback State 12:14 - Reserved 15 - Uninitialized */
        uint32_t DMAOFF      :1;                 /* DMA clock turn-off status. DMA clock turn-off/enable status: 0 - DMA clock is always on (default after hardware reset) 1 - DMA clock turn-off in U1, U2 and U3 (SS mode) is enabled. */
        uint32_t ENDIAN      :1;                 /* SFR Endian status. Little/Big Endian byte order for SFR access: 0 - Little Endian order (default after hardware reset) 1 - Big Endian order */
    } B;
} IMX_USB3_USBSS_USB_STS_t;

/* Register USB_STS - Global Status Register */
#define IMX_USB3_USBSS_USB_STS_OFFSET 0x20004
/* Field CFGSTS - Configuration status. 1 - device is in the configured state 0 - device is not configured This bit set during SET_CONFIGURATION request means that status stage of this request was finished successfully, thus device configuration was finished successfully. */
#define IMX_USB3_USBSS_USB_STS_CFGSTS_SHIFT 0
#define IMX_USB3_USBSS_USB_STS_CFGSTS_MASK 0x1
#define IMX_USB3_USBSS_USB_STS_CFGSTS(v) (((v) << 0) & 0x1)
/* Field MEM_OV - On-chip memory overflow. 0 - On-chip memory status OK 1 - On-chip memory overflow Memory overflow may occur if, during enumeration (SET_CONFIGURATION request) device software will try to turn on too many endpoints or will try to set too much endpoinds buffers (see EP_CFG.BUFFERING). After each completion of enumeration software should check this bit, and when a memory overflow occurred, software must delete current configuration (using USB_CONF.CFGRST bit) and then set the one that requires less on-chip memory. For available memory calculation, the CDNS_USBSSDEV_ATTACHED_MEM_SIZE define parameter is used. */
#define IMX_USB3_USBSS_USB_STS_MEM_OV_SHIFT 1
#define IMX_USB3_USBSS_USB_STS_MEM_OV_MASK 0x2
#define IMX_USB3_USBSS_USB_STS_MEM_OV(v) (((v) << 0x1) & 0x2)
/* Field USB3CONS - SuperSpeed connection status. 0 - USB in SuperSpeed mode disconnected 1 - USB in SuperSpeed mode connected */
#define IMX_USB3_USBSS_USB_STS_USB3CONS_SHIFT 2
#define IMX_USB3_USBSS_USB_STS_USB3CONS_MASK 0x4
#define IMX_USB3_USBSS_USB_STS_USB3CONS(v) (((v) << 0x2) & 0x4)
/* Field DTRANS - DMA transfer configuration status. 0 - single request - Single TRB chain. Single request (DRDY/Doorbell) triggers DMA, which transfers single TRB chain only and ends the EP transfer. 1 - single request - Multiple TRB chain. Single request (DRDY/Doorbell) triggers DMA which transfers TRB chains until the owner of the new chain is not DMA (this causes a TRB error interrupt). This DMA transfer configuration settings can be changed by using bits USB_CONF.DSING and USB_CONF.DMULT. */
#define IMX_USB3_USBSS_USB_STS_DTRANS_SHIFT 3
#define IMX_USB3_USBSS_USB_STS_DTRANS_MASK 0x8
#define IMX_USB3_USBSS_USB_STS_DTRANS(v) (((v) << 0x3) & 0x8)
/* Field USBSPEED - Device speed: 0: undef., 1: LowSpeed (not supported), 2: FullSpeed, 3: HighSpeed, 4: SuperSpeed, 5-7: Reserved */
#define IMX_USB3_USBSS_USB_STS_USBSPEED_SHIFT 4
#define IMX_USB3_USBSS_USB_STS_USBSPEED_MASK 0x70
#define IMX_USB3_USBSS_USB_STS_USBSPEED(v) (((v) << 0x4) & 0x70)
/* Field ENDIAN_MIRROR - Little/Big Endian byte order for SFR access. 0 - Little Endian order (default after hardware reset) 1 - Big Endian order Endian byte order for SFR access can be changed by setting BENDIAN or LEDNIAN bits in USB_CONF register. */
#define IMX_USB3_USBSS_USB_STS_ENDIAN_MIRROR_SHIFT 7
#define IMX_USB3_USBSS_USB_STS_ENDIAN_MIRROR_MASK 0x80
#define IMX_USB3_USBSS_USB_STS_ENDIAN_MIRROR(v) (((v) << 0x7) & 0x80)
/* Field CLK2OFF - HS/FS clock turn-off status. When CLK2OFF bit is '0', the utmisuspendm output signal is not set low in USB2.0 suspend state (L2 state), thus USB2.0 PHY does not turn off the hsfs clock 0 - hsfs clock is always on 1 - hsfs clock turn-off in L2 (HS/FS mode) is enabled (default after hardware reset) */
#define IMX_USB3_USBSS_USB_STS_CLK2OFF_SHIFT 8
#define IMX_USB3_USBSS_USB_STS_CLK2OFF_MASK 0x100
#define IMX_USB3_USBSS_USB_STS_CLK2OFF(v) (((v) << 0x8) & 0x100)
/* Field CLK3OFF - PCLK clock turn-off status. When CLK3OFF bit is '0', the phypowerdown output signal is not set to '11' in U3 link state, thus USB3.0 PHY does not turn off the pclk clock. 0 - pclk clock is always on 1 - pclk clock turn-off in U3 (SS mode) is enabled (default after hardware reset) */
#define IMX_USB3_USBSS_USB_STS_CLK3OFF_SHIFT 9
#define IMX_USB3_USBSS_USB_STS_CLK3OFF_MASK 0x200
#define IMX_USB3_USBSS_USB_STS_CLK3OFF(v) (((v) << 0x9) & 0x200)
/* Field IN_RST - Controler in reset state. This bit indicate that whole (in case of POR) or part of controller (in case of SWRST or USB resets) currently is in reset state. As controller has registers in both clock domains (system, and USB), internal reset synchronization between these domains may take longer than the cause of the reset (e.g active reset_n input). Thus it is recommended to check if controller is not in reset state, before software starts its operations (especially after POR). 0 - Internal reset is active 1 - Internal reset is not active and controller is fully operational. */
#define IMX_USB3_USBSS_USB_STS_IN_RST_SHIFT 10
#define IMX_USB3_USBSS_USB_STS_IN_RST_MASK 0x400
#define IMX_USB3_USBSS_USB_STS_IN_RST(v) (((v) << 0xA) & 0x400)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_STS_RESERVED0_SHIFT 11
#define IMX_USB3_USBSS_USB_STS_RESERVED0_MASK 0x3800
#define IMX_USB3_USBSS_USB_STS_RESERVED0(v) (((v) << 0xB) & 0x3800)
/* Field DEVS - Device enable Status 0 - USB device is disabled (VBUS input is disconnected from internal logic) 1 - USB device is enabled (VBUS input is connected to the internal logic) This bit can be changed by setting DEVEN or DEVDS bits in USB_CONF register. */
#define IMX_USB3_USBSS_USB_STS_DEVS_SHIFT 14
#define IMX_USB3_USBSS_USB_STS_DEVS_MASK 0x4000
#define IMX_USB3_USBSS_USB_STS_DEVS(v) (((v) << 0xE) & 0x4000)
/* Field ADDRESSED - Address status: 0 - USB device is default state 1 - USB device is at least in address state (Function Address was set by the SW) */
#define IMX_USB3_USBSS_USB_STS_ADDRESSED_SHIFT 15
#define IMX_USB3_USBSS_USB_STS_ADDRESSED_MASK 0x8000
#define IMX_USB3_USBSS_USB_STS_ADDRESSED(v) (((v) << 0xF) & 0x8000)
/* Field L1ENS - L1 LPM state enable status (valid for HS/FS mode only). 0 - Entering to L1 LPM state disabled 1 - Entering to L1 LPM state enabled */
#define IMX_USB3_USBSS_USB_STS_L1ENS_SHIFT 16
#define IMX_USB3_USBSS_USB_STS_L1ENS_MASK 0x10000
#define IMX_USB3_USBSS_USB_STS_L1ENS(v) (((v) << 0x10) & 0x10000)
/* Field VBUSS - Internal VBUS connection status. 0 - internal VBUS is not detected 1 - internal VBUS is detected */
#define IMX_USB3_USBSS_USB_STS_VBUSS_SHIFT 17
#define IMX_USB3_USBSS_USB_STS_VBUSS_MASK 0x20000
#define IMX_USB3_USBSS_USB_STS_VBUSS(v) (((v) << 0x11) & 0x20000)
/* Field LPMST - HS/FS LPM state (valid for HS/FS mode only). This field reflects USBSS-DEV current LPM (used in HS/FS mode) state: 0 - L0 State 1 - L1 State 2 - L2 State 3 - L3 State */
#define IMX_USB3_USBSS_USB_STS_LPMST_SHIFT 18
#define IMX_USB3_USBSS_USB_STS_LPMST_MASK 0xC0000
#define IMX_USB3_USBSS_USB_STS_LPMST(v) (((v) << 0x12) & 0xC0000)
/* Field USB2CONS - HS/FS mode connection enable status (valid for HS/FS mode only). 0 - the disconnect bit for HS/FS mode is set (USB_CONF.USB2DIS) 1 - the disconnect bit for HS/FS mode is not set (device can be connected in this mode) The actual connection status can be checked in the USB_STS.USBSPEED register */
#define IMX_USB3_USBSS_USB_STS_USB2CONS_SHIFT 20
#define IMX_USB3_USBSS_USB_STS_USB2CONS_MASK 0x100000
#define IMX_USB3_USBSS_USB_STS_USB2CONS(v) (((v) << 0x14) & 0x100000)
/* Field DISABLE_HS - DisableHS status (valid for HS/FS mode only) 0 - High Speed operations in USB2.0 (FS/HS) mode not disabled 1 - High Speed operations in USB2.0 (FS/HS) mode disabled */
#define IMX_USB3_USBSS_USB_STS_DISABLE_HS_SHIFT 21
#define IMX_USB3_USBSS_USB_STS_DISABLE_HS_MASK 0x200000
#define IMX_USB3_USBSS_USB_STS_DISABLE_HS(v) (((v) << 0x15) & 0x200000)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_STS_RESERVED1_SHIFT 22
#define IMX_USB3_USBSS_USB_STS_RESERVED1_MASK 0xC00000
#define IMX_USB3_USBSS_USB_STS_RESERVED1(v) (((v) << 0x16) & 0xC00000)
/* Field U1ENS - U1 state enable status (valid in SS mode only): 0 - Entering to U1 state disabled 1 - Entering to U1 state enabled */
#define IMX_USB3_USBSS_USB_STS_U1ENS_SHIFT 24
#define IMX_USB3_USBSS_USB_STS_U1ENS_MASK 0x1000000
#define IMX_USB3_USBSS_USB_STS_U1ENS(v) (((v) << 0x18) & 0x1000000)
/* Field U2ENS - U2 state enable status (valid in SS mode only): 0 - Entering to U2 state disabled 1 - Entering to U2 state enabled */
#define IMX_USB3_USBSS_USB_STS_U2ENS_SHIFT 25
#define IMX_USB3_USBSS_USB_STS_U2ENS_MASK 0x2000000
#define IMX_USB3_USBSS_USB_STS_U2ENS(v) (((v) << 0x19) & 0x2000000)
/* Field LST - SuperSpeed Link LTSSM state. This field reflects USBSS-DEV current SuperSpeed link state: 0 - U0 State 1 - U1 State 2 - U2 State 3 - U3 State (Device Suspended) 4 - Disabled State 5 - RxDetect State 6 - Inactive State 7 - Polling State 8 - Recovery State 9 - Hot Reset State 10 - Compliance Mode State 11 - Loopback State 12:14 - Reserved 15 - Uninitialized */
#define IMX_USB3_USBSS_USB_STS_LST_SHIFT 26
#define IMX_USB3_USBSS_USB_STS_LST_MASK 0x3C000000
#define IMX_USB3_USBSS_USB_STS_LST(v) (((v) << 0x1A) & 0x3C000000)
/* Field DMAOFF - DMA clock turn-off status. DMA clock turn-off/enable status: 0 - DMA clock is always on (default after hardware reset) 1 - DMA clock turn-off in U1, U2 and U3 (SS mode) is enabled. */
#define IMX_USB3_USBSS_USB_STS_DMAOFF_SHIFT 30
#define IMX_USB3_USBSS_USB_STS_DMAOFF_MASK 0x40000000
#define IMX_USB3_USBSS_USB_STS_DMAOFF(v) (((v) << 0x1E) & 0x40000000)
/* Field ENDIAN - SFR Endian status. Little/Big Endian byte order for SFR access: 0 - Little Endian order (default after hardware reset) 1 - Big Endian order */
#define IMX_USB3_USBSS_USB_STS_ENDIAN_SHIFT 31
#define IMX_USB3_USBSS_USB_STS_ENDIAN_MASK 0x80000000
#define IMX_USB3_USBSS_USB_STS_ENDIAN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_USB_CMD - Global Command Register */
typedef union IMX_USB3_USBSS_USB_CMD_union_t {
    uint32_t R;
    struct {
        uint32_t SET_ADDR    :1;                 /* Set Function Address. Writing the value '1 'to this bit causes the device is assigned to the USB Function Address according to the FADDR field. The device address must be saved by software when operating SET_ADDRESS request. After saving device address, software should set the EP_CMD.ERDY bit (as with all other requests) to quit the setup phase and then set bit EP_CMD.REQ_CMPL to confirm the status of the host phase. Writing '0 'has no effect. This bit is always '0' while reading. */
        uint32_t FADDR       :7;                 /* Function Address. This field is saved to the device only when the field SET_ADDR is set '1 ' during write to USB_CMD register. Software is responsible for entering the address of the device during SET_ADDRESS request service. This field should be set immediately after the SETUP packet is decoded, and prior to confirmation of the status phase (what is done by bit EP_CMD.REQ_CMPL) Verify that the device successfully completed the SET_ADDRESS request and is in ADRESSED state (as defined in USB3 spec) can be realized by checking the bit USB_STS. ADRESSED. USB_CMD.FADDR field can also be read at any time. This field is always '0' while reading. */
        uint32_t SDNFW       :1;                 /* Send Function Wake Device Notification TP (SS mode only). Writing '1' will trigger an attempt to send 'Device Notification' with 'Interface' field set to DNFW_INT. This bit will be automatically cleared if the FW Notification TP is sent and only then the new FW Notification TP or the other TP (by means of SPKT or SDNLTM bits) can be send again. Writing '0' has no effect. This bit cannot be written by '1' simultaneously with SPKT and SDNLTM bits. */
        uint32_t STMODE      :1;                 /* Set Test Mode (HS/FS mode only). Writing the value '1 'to this bit causes the device enters into test mode selected by the TMODE_SEL field. Writing '0' has no effect. This bit is always '0' while reading. */
        uint32_t TMODE_SEL   :2;                 /* Test mode selector (HS/FS mode only). This field contains selected Test Mode - Device will enter this Test mode when '1' is written to STMODE. USB 2.0 Test mode selector: 00 - Test_J, 01 - Test_K, 10 - Test_SE0_NAK, 11 - Test_Packet This field is always '0' while reading. */
        uint32_t SDNLTM      :1;                 /* Send Latency Tolerance Message Device Notification TP (SS mode only). Writing '1' will trigger an attempt to send Device Notification 'Latency Tolerance Message' with 'BELT' field set to DNLTM_BELT. This bit will be automatically cleared if the LTM Notification TP is sent and only then the new LTM Notification TP or the other TP (by means of SPKT or SDNFW bits) can be send again. Writing '0' has no effect. This bit cannot be written by '1' simultaneously with SPKT and SDNFW bits. */
        uint32_t SPKT        :1;                 /* Send Custom Transaction Packet (SS mode only) Writing '1' will trigger an attempt to send Custom TP as defined in the USB3.0 specification. The packet contents that will be send as TP to the host must be previously prepared in the CPKT1 (will be sent as DWORD 0 in the TP), CPKT2 (will be sent as DWORD 1 in the TP) and CPKT3 (will be sent as DWORD 2 in the TP) registers. Note that TP DWORD 3 will be automatically inserted by the device controller. This bit will be automatically cleared if this TP is sent and only then the new Custom TP (by means of SPKT bit) or other Notification TP (by means of SDNLTM or SDNFW bits) can be send again. Writing 0 has no effect. This bit cannot be written by 1 simultaneously with SDNLTM and SDNFW bits. */
        uint32_t RESERVED0   :2;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t DNLTM_BELT_7_0 :8;              /* Device Notification 'Latency Tolerance Message' - BELT value [7:0] / Device Notification 'Function Wake' - Interface value (SS mode only). This field must be filled up before one of the USB_CMD.SDNLTM/SDNFW bits is set, and cannot be changed while USB_CMD.SDNLTM/SDNFW bits are not zero (Device Notification is being sent by the device controller). If user writes '1' to SDNFW bit the device will send Device Notification 'Function Wake' with 'Interface[7:0]' field value equal to DNLTM_BELT_7_0. If user writes '1' to SDNLTM bit, the device will send Device Notification 'Latency Tolerance Message' with 'BELT[7:0]' field value equal to DNLTM_BELT_7_0. This field is always '0' while reading. */
        uint32_t DNLTM_BELT_11_8 :4;             /* Device Notification 'Latency Tolerance Message' - BELT value [11:8] (SS mode only). If user writes '1' to SDNLTM bit, the device will send Device Notification 'Latency Tolerance Message' with 'BELT[11:8]' field value equal to DNLTM_BELT_11_8. This field must be filled up before the USB_CMD.SDNLTM bit is set, and cannot be changed while USB_CMD.SDNLTM bit is not zero (Device Notification is being sent by the device controller) This field is always '0' while reading. */
        uint32_t RESERVED1   :4;                 /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_USB_CMD_t;

/* Register USB_CMD - Global Command Register */
#define IMX_USB3_USBSS_USB_CMD_OFFSET 0x20008
/* Field SET_ADDR - Set Function Address. Writing the value '1 'to this bit causes the device is assigned to the USB Function Address according to the FADDR field. The device address must be saved by software when operating SET_ADDRESS request. After saving device address, software should set the EP_CMD.ERDY bit (as with all other requests) to quit the setup phase and then set bit EP_CMD.REQ_CMPL to confirm the status of the host phase. Writing '0 'has no effect. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CMD_SET_ADDR_SHIFT 0
#define IMX_USB3_USBSS_USB_CMD_SET_ADDR_MASK 0x1
#define IMX_USB3_USBSS_USB_CMD_SET_ADDR(v) (((v) << 0) & 0x1)
/* Field FADDR - Function Address. This field is saved to the device only when the field SET_ADDR is set '1 ' during write to USB_CMD register. Software is responsible for entering the address of the device during SET_ADDRESS request service. This field should be set immediately after the SETUP packet is decoded, and prior to confirmation of the status phase (what is done by bit EP_CMD.REQ_CMPL) Verify that the device successfully completed the SET_ADDRESS request and is in ADRESSED state (as defined in USB3 spec) can be realized by checking the bit USB_STS. ADRESSED. USB_CMD.FADDR field can also be read at any time. This field is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CMD_FADDR_SHIFT 1
#define IMX_USB3_USBSS_USB_CMD_FADDR_MASK 0xFE
#define IMX_USB3_USBSS_USB_CMD_FADDR(v) (((v) << 0x1) & 0xFE)
/* Field SDNFW - Send Function Wake Device Notification TP (SS mode only). Writing '1' will trigger an attempt to send 'Device Notification' with 'Interface' field set to DNFW_INT. This bit will be automatically cleared if the FW Notification TP is sent and only then the new FW Notification TP or the other TP (by means of SPKT or SDNLTM bits) can be send again. Writing '0' has no effect. This bit cannot be written by '1' simultaneously with SPKT and SDNLTM bits. */
#define IMX_USB3_USBSS_USB_CMD_SDNFW_SHIFT 8
#define IMX_USB3_USBSS_USB_CMD_SDNFW_MASK 0x100
#define IMX_USB3_USBSS_USB_CMD_SDNFW(v) (((v) << 0x8) & 0x100)
/* Field STMODE - Set Test Mode (HS/FS mode only). Writing the value '1 'to this bit causes the device enters into test mode selected by the TMODE_SEL field. Writing '0' has no effect. This bit is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CMD_STMODE_SHIFT 9
#define IMX_USB3_USBSS_USB_CMD_STMODE_MASK 0x200
#define IMX_USB3_USBSS_USB_CMD_STMODE(v) (((v) << 0x9) & 0x200)
/* Field TMODE_SEL - Test mode selector (HS/FS mode only). This field contains selected Test Mode - Device will enter this Test mode when '1' is written to STMODE. USB 2.0 Test mode selector: 00 - Test_J, 01 - Test_K, 10 - Test_SE0_NAK, 11 - Test_Packet This field is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CMD_TMODE_SEL_SHIFT 10
#define IMX_USB3_USBSS_USB_CMD_TMODE_SEL_MASK 0xC00
#define IMX_USB3_USBSS_USB_CMD_TMODE_SEL(v) (((v) << 0xA) & 0xC00)
/* Field SDNLTM - Send Latency Tolerance Message Device Notification TP (SS mode only). Writing '1' will trigger an attempt to send Device Notification 'Latency Tolerance Message' with 'BELT' field set to DNLTM_BELT. This bit will be automatically cleared if the LTM Notification TP is sent and only then the new LTM Notification TP or the other TP (by means of SPKT or SDNFW bits) can be send again. Writing '0' has no effect. This bit cannot be written by '1' simultaneously with SPKT and SDNFW bits. */
#define IMX_USB3_USBSS_USB_CMD_SDNLTM_SHIFT 12
#define IMX_USB3_USBSS_USB_CMD_SDNLTM_MASK 0x1000
#define IMX_USB3_USBSS_USB_CMD_SDNLTM(v) (((v) << 0xC) & 0x1000)
/* Field SPKT - Send Custom Transaction Packet (SS mode only) Writing '1' will trigger an attempt to send Custom TP as defined in the USB3.0 specification. The packet contents that will be send as TP to the host must be previously prepared in the CPKT1 (will be sent as DWORD 0 in the TP), CPKT2 (will be sent as DWORD 1 in the TP) and CPKT3 (will be sent as DWORD 2 in the TP) registers. Note that TP DWORD 3 will be automatically inserted by the device controller. This bit will be automatically cleared if this TP is sent and only then the new Custom TP (by means of SPKT bit) or other Notification TP (by means of SDNLTM or SDNFW bits) can be send again. Writing 0 has no effect. This bit cannot be written by 1 simultaneously with SDNLTM and SDNFW bits. */
#define IMX_USB3_USBSS_USB_CMD_SPKT_SHIFT 13
#define IMX_USB3_USBSS_USB_CMD_SPKT_MASK 0x2000
#define IMX_USB3_USBSS_USB_CMD_SPKT(v) (((v) << 0xD) & 0x2000)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_CMD_RESERVED0_SHIFT 14
#define IMX_USB3_USBSS_USB_CMD_RESERVED0_MASK 0xC000
#define IMX_USB3_USBSS_USB_CMD_RESERVED0(v) (((v) << 0xE) & 0xC000)
/* Field DNLTM_BELT_7_0 - Device Notification 'Latency Tolerance Message' - BELT value [7:0] / Device Notification 'Function Wake' - Interface value (SS mode only). This field must be filled up before one of the USB_CMD.SDNLTM/SDNFW bits is set, and cannot be changed while USB_CMD.SDNLTM/SDNFW bits are not zero (Device Notification is being sent by the device controller). If user writes '1' to SDNFW bit the device will send Device Notification 'Function Wake' with 'Interface[7:0]' field value equal to DNLTM_BELT_7_0. If user writes '1' to SDNLTM bit, the device will send Device Notification 'Latency Tolerance Message' with 'BELT[7:0]' field value equal to DNLTM_BELT_7_0. This field is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CMD_DNLTM_BELT_7_0_SHIFT 16
#define IMX_USB3_USBSS_USB_CMD_DNLTM_BELT_7_0_MASK 0xFF0000
#define IMX_USB3_USBSS_USB_CMD_DNLTM_BELT_7_0(v) (((v) << 0x10) & 0xFF0000)
/* Field DNLTM_BELT_11_8 - Device Notification 'Latency Tolerance Message' - BELT value [11:8] (SS mode only). If user writes '1' to SDNLTM bit, the device will send Device Notification 'Latency Tolerance Message' with 'BELT[11:8]' field value equal to DNLTM_BELT_11_8. This field must be filled up before the USB_CMD.SDNLTM bit is set, and cannot be changed while USB_CMD.SDNLTM bit is not zero (Device Notification is being sent by the device controller) This field is always '0' while reading. */
#define IMX_USB3_USBSS_USB_CMD_DNLTM_BELT_11_8_SHIFT 24
#define IMX_USB3_USBSS_USB_CMD_DNLTM_BELT_11_8_MASK 0xF000000
#define IMX_USB3_USBSS_USB_CMD_DNLTM_BELT_11_8(v) (((v) << 0x18) & 0xF000000)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_CMD_RESERVED1_SHIFT 28
#define IMX_USB3_USBSS_USB_CMD_RESERVED1_MASK 0xF0000000
#define IMX_USB3_USBSS_USB_CMD_RESERVED1(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_USB_IPTN -  */
typedef union IMX_USB3_USBSS_USB_IPTN_union_t {
    uint32_t R;
    struct {
        uint32_t ITPN        :14;                /* ITP(SS) / SOF (HS/FS) number. In SS mode this field represent number of last ITP received from host. In HS/FS mode this field represent number of last SOF received from host. */
        uint32_t RESERVED    :18;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_USB_IPTN_t;

/* Register USB_IPTN -  */
#define IMX_USB3_USBSS_USB_IPTN_OFFSET 0x2000C
/* Field ITPN - ITP(SS) / SOF (HS/FS) number. In SS mode this field represent number of last ITP received from host. In HS/FS mode this field represent number of last SOF received from host. */
#define IMX_USB3_USBSS_USB_IPTN_ITPN_SHIFT 0
#define IMX_USB3_USBSS_USB_IPTN_ITPN_MASK 0x3FFF
#define IMX_USB3_USBSS_USB_IPTN_ITPN(v) (((v) << 0) & 0x3FFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_IPTN_RESERVED_SHIFT 14
#define IMX_USB3_USBSS_USB_IPTN_RESERVED_MASK 0xFFFFC000
#define IMX_USB3_USBSS_USB_IPTN_RESERVED(v) (((v) << 0xE) & 0xFFFFC000)

/* IMX_USB3_USBSS_USB_LPM - USB LPM Register */
typedef union IMX_USB3_USBSS_USB_LPM_union_t {
    uint32_t R;
    struct {
        uint32_t HIRD        :4;                 /* Host Initiated Resume Duration. This is the Resume duration from L1 LPM state, received from the host in the latest Extended Token packet. For more information see chapter: 'HS/FS mode - Link Power Management' */
        uint32_t BRW         :1;                 /* Remote Wakeup Enable (bRemoteWake) */
        uint32_t RESERVED    :27;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_USB_LPM_t;

/* Register USB_LPM - USB LPM Register */
#define IMX_USB3_USBSS_USB_LPM_OFFSET 0x20010
/* Field HIRD - Host Initiated Resume Duration. This is the Resume duration from L1 LPM state, received from the host in the latest Extended Token packet. For more information see chapter: 'HS/FS mode - Link Power Management' */
#define IMX_USB3_USBSS_USB_LPM_HIRD_SHIFT 0
#define IMX_USB3_USBSS_USB_LPM_HIRD_MASK 0xF
#define IMX_USB3_USBSS_USB_LPM_HIRD(v) (((v) << 0) & 0xF)
/* Field BRW - Remote Wakeup Enable (bRemoteWake) */
#define IMX_USB3_USBSS_USB_LPM_BRW_SHIFT 4
#define IMX_USB3_USBSS_USB_LPM_BRW_MASK 0x10
#define IMX_USB3_USBSS_USB_LPM_BRW(v) (((v) << 0x4) & 0x10)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_LPM_RESERVED_SHIFT 5
#define IMX_USB3_USBSS_USB_LPM_RESERVED_MASK 0xFFFFFFE0
#define IMX_USB3_USBSS_USB_LPM_RESERVED(v) (((v) << 0x5) & 0xFFFFFFE0)

/* IMX_USB3_USBSS_USB_IEN - Interrupt Enable Register */
typedef union IMX_USB3_USBSS_USB_IEN_union_t {
    uint32_t R;
    struct {
        uint32_t CONIEN      :1;                 /* SS connection interrupt enable. This bit enables requesting a CONI interrupt. */
        uint32_t DISIEN      :1;                 /* SS disconnection interrupt enable. This bit enables requesting a DISI interrupt. */
        uint32_t UWRESIEN    :1;                 /* USB SS warm reset interrupt enable. This bit enables requesting an UWRESI interrupt. */
        uint32_t UHRESIEN    :1;                 /* USB SS hot reset interrupt enable. This bit enables requesting an UHRESI interrupt. */
        uint32_t U3ENTIEN    :1;                 /* SS link U3 state enter interrupt enable (suspend). This bit enables requesting an U3ENTI interrupt. */
        uint32_t U3EXTIEN    :1;                 /* SS link U3 state exit interrupt enable (wakeup). This bit enables requesting an U3EXTI interrupt. */
        uint32_t U2ENTIEN    :1;                 /* SS link U2 state enter interrupt enable. This bit enables requesting an U2ENTI interrupt. */
        uint32_t U2EXTIEN    :1;                 /* SS link U2 state exit interrupt enable. This bit enables requesting an U2EXTI interrupt. */
        uint32_t U1ENTIEN    :1;                 /* SS link U1 state enter interrupt enable. This bit enables requesting an U1ENTI interrupt. */
        uint32_t U1EXTIEN    :1;                 /* SS link U1 state exit interrupt enable. This bit enables requesting an U1EXTI interrupt. */
        uint32_t ITPIEN      :1;                 /* ITP/SOF packet detected interrupt enable. This bit enables requesting an ITPI interrupt. */
        uint32_t WAKEIEN     :1;                 /* Wakeup interrupt enable. This bit enables requesting a Wakeup interrupt. */
        uint32_t SPKTIEN     :1;                 /* Send Custom Packet interrupt enable. This bit enables requesting a Send Custom Packet interrupt. */
        uint32_t RESERVED0   :3;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t CON2IEN     :1;                 /* HS/FS mode connection interrupt enable. This bit enables requesting a CON2I interrupt. */
        uint32_t DIS2IEN     :1;                 /* HS/FS mode disconnection interrupt enable. This bit enables requesting a DIS2I interrupt. */
        uint32_t U2RESIEN    :1;                 /* USB reset (HS/FS mode) interrupt enable. This bit enables requesting an U2RESI interrupt. */
        uint32_t RESERVED1   :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t L2ENTIEN    :1;                 /* LPM L2 state enter interrupt enable. This bit enables requesting a L2ENTI interrupt. */
        uint32_t L2EXTIEN    :1;                 /* LPM L2 state exit interrupt enable. This bit enables requesting a L2EXTI interrupt. */
        uint32_t RESERVED2   :2;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t L1ENTIEN    :1;                 /* LPM L1 state enter interrupt enable. This bit enables requesting an L1ENTI interrupt. */
        uint32_t L1EXTIEN    :1;                 /* LPM L1 state exit interrupt enable. This bit enables requesting an L1EXTI interrupt. */
        uint32_t CFGRESIEN   :1;                 /* Configuration reset interrupt enable. This bit enables requesting a CFGRESI interrupt */
        uint32_t RESERVED3   :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t UWRESSIEN   :1;                 /* Start of the USB SS warm reset interrupt enable. This bit enables requesting a UWRESSI interrupt */
        uint32_t UWRESEIEN   :1;                 /* End of the USB SS warm reset interrupt enable. This bit enables requesting a UWRESEI interrupt */
        uint32_t RESERVED4   :2;                 /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_USB_IEN_t;

/* Register USB_IEN - Interrupt Enable Register */
#define IMX_USB3_USBSS_USB_IEN_OFFSET 0x20014
/* Field CONIEN - SS connection interrupt enable. This bit enables requesting a CONI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_CONIEN_SHIFT 0
#define IMX_USB3_USBSS_USB_IEN_CONIEN_MASK 0x1
#define IMX_USB3_USBSS_USB_IEN_CONIEN(v) (((v) << 0) & 0x1)
/* Field DISIEN - SS disconnection interrupt enable. This bit enables requesting a DISI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_DISIEN_SHIFT 1
#define IMX_USB3_USBSS_USB_IEN_DISIEN_MASK 0x2
#define IMX_USB3_USBSS_USB_IEN_DISIEN(v) (((v) << 0x1) & 0x2)
/* Field UWRESIEN - USB SS warm reset interrupt enable. This bit enables requesting an UWRESI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_UWRESIEN_SHIFT 2
#define IMX_USB3_USBSS_USB_IEN_UWRESIEN_MASK 0x4
#define IMX_USB3_USBSS_USB_IEN_UWRESIEN(v) (((v) << 0x2) & 0x4)
/* Field UHRESIEN - USB SS hot reset interrupt enable. This bit enables requesting an UHRESI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_UHRESIEN_SHIFT 3
#define IMX_USB3_USBSS_USB_IEN_UHRESIEN_MASK 0x8
#define IMX_USB3_USBSS_USB_IEN_UHRESIEN(v) (((v) << 0x3) & 0x8)
/* Field U3ENTIEN - SS link U3 state enter interrupt enable (suspend). This bit enables requesting an U3ENTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_U3ENTIEN_SHIFT 4
#define IMX_USB3_USBSS_USB_IEN_U3ENTIEN_MASK 0x10
#define IMX_USB3_USBSS_USB_IEN_U3ENTIEN(v) (((v) << 0x4) & 0x10)
/* Field U3EXTIEN - SS link U3 state exit interrupt enable (wakeup). This bit enables requesting an U3EXTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_U3EXTIEN_SHIFT 5
#define IMX_USB3_USBSS_USB_IEN_U3EXTIEN_MASK 0x20
#define IMX_USB3_USBSS_USB_IEN_U3EXTIEN(v) (((v) << 0x5) & 0x20)
/* Field U2ENTIEN - SS link U2 state enter interrupt enable. This bit enables requesting an U2ENTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_U2ENTIEN_SHIFT 6
#define IMX_USB3_USBSS_USB_IEN_U2ENTIEN_MASK 0x40
#define IMX_USB3_USBSS_USB_IEN_U2ENTIEN(v) (((v) << 0x6) & 0x40)
/* Field U2EXTIEN - SS link U2 state exit interrupt enable. This bit enables requesting an U2EXTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_U2EXTIEN_SHIFT 7
#define IMX_USB3_USBSS_USB_IEN_U2EXTIEN_MASK 0x80
#define IMX_USB3_USBSS_USB_IEN_U2EXTIEN(v) (((v) << 0x7) & 0x80)
/* Field U1ENTIEN - SS link U1 state enter interrupt enable. This bit enables requesting an U1ENTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_U1ENTIEN_SHIFT 8
#define IMX_USB3_USBSS_USB_IEN_U1ENTIEN_MASK 0x100
#define IMX_USB3_USBSS_USB_IEN_U1ENTIEN(v) (((v) << 0x8) & 0x100)
/* Field U1EXTIEN - SS link U1 state exit interrupt enable. This bit enables requesting an U1EXTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_U1EXTIEN_SHIFT 9
#define IMX_USB3_USBSS_USB_IEN_U1EXTIEN_MASK 0x200
#define IMX_USB3_USBSS_USB_IEN_U1EXTIEN(v) (((v) << 0x9) & 0x200)
/* Field ITPIEN - ITP/SOF packet detected interrupt enable. This bit enables requesting an ITPI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_ITPIEN_SHIFT 10
#define IMX_USB3_USBSS_USB_IEN_ITPIEN_MASK 0x400
#define IMX_USB3_USBSS_USB_IEN_ITPIEN(v) (((v) << 0xA) & 0x400)
/* Field WAKEIEN - Wakeup interrupt enable. This bit enables requesting a Wakeup interrupt. */
#define IMX_USB3_USBSS_USB_IEN_WAKEIEN_SHIFT 11
#define IMX_USB3_USBSS_USB_IEN_WAKEIEN_MASK 0x800
#define IMX_USB3_USBSS_USB_IEN_WAKEIEN(v) (((v) << 0xB) & 0x800)
/* Field SPKTIEN - Send Custom Packet interrupt enable. This bit enables requesting a Send Custom Packet interrupt. */
#define IMX_USB3_USBSS_USB_IEN_SPKTIEN_SHIFT 12
#define IMX_USB3_USBSS_USB_IEN_SPKTIEN_MASK 0x1000
#define IMX_USB3_USBSS_USB_IEN_SPKTIEN(v) (((v) << 0xC) & 0x1000)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_IEN_RESERVED0_SHIFT 13
#define IMX_USB3_USBSS_USB_IEN_RESERVED0_MASK 0xE000
#define IMX_USB3_USBSS_USB_IEN_RESERVED0(v) (((v) << 0xD) & 0xE000)
/* Field CON2IEN - HS/FS mode connection interrupt enable. This bit enables requesting a CON2I interrupt. */
#define IMX_USB3_USBSS_USB_IEN_CON2IEN_SHIFT 16
#define IMX_USB3_USBSS_USB_IEN_CON2IEN_MASK 0x10000
#define IMX_USB3_USBSS_USB_IEN_CON2IEN(v) (((v) << 0x10) & 0x10000)
/* Field DIS2IEN - HS/FS mode disconnection interrupt enable. This bit enables requesting a DIS2I interrupt. */
#define IMX_USB3_USBSS_USB_IEN_DIS2IEN_SHIFT 17
#define IMX_USB3_USBSS_USB_IEN_DIS2IEN_MASK 0x20000
#define IMX_USB3_USBSS_USB_IEN_DIS2IEN(v) (((v) << 0x11) & 0x20000)
/* Field U2RESIEN - USB reset (HS/FS mode) interrupt enable. This bit enables requesting an U2RESI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_U2RESIEN_SHIFT 18
#define IMX_USB3_USBSS_USB_IEN_U2RESIEN_MASK 0x40000
#define IMX_USB3_USBSS_USB_IEN_U2RESIEN(v) (((v) << 0x12) & 0x40000)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_IEN_RESERVED1_SHIFT 19
#define IMX_USB3_USBSS_USB_IEN_RESERVED1_MASK 0x80000
#define IMX_USB3_USBSS_USB_IEN_RESERVED1(v) (((v) << 0x13) & 0x80000)
/* Field L2ENTIEN - LPM L2 state enter interrupt enable. This bit enables requesting a L2ENTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_L2ENTIEN_SHIFT 20
#define IMX_USB3_USBSS_USB_IEN_L2ENTIEN_MASK 0x100000
#define IMX_USB3_USBSS_USB_IEN_L2ENTIEN(v) (((v) << 0x14) & 0x100000)
/* Field L2EXTIEN - LPM L2 state exit interrupt enable. This bit enables requesting a L2EXTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_L2EXTIEN_SHIFT 21
#define IMX_USB3_USBSS_USB_IEN_L2EXTIEN_MASK 0x200000
#define IMX_USB3_USBSS_USB_IEN_L2EXTIEN(v) (((v) << 0x15) & 0x200000)
/* Field RESERVED2 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_IEN_RESERVED2_SHIFT 22
#define IMX_USB3_USBSS_USB_IEN_RESERVED2_MASK 0xC00000
#define IMX_USB3_USBSS_USB_IEN_RESERVED2(v) (((v) << 0x16) & 0xC00000)
/* Field L1ENTIEN - LPM L1 state enter interrupt enable. This bit enables requesting an L1ENTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_L1ENTIEN_SHIFT 24
#define IMX_USB3_USBSS_USB_IEN_L1ENTIEN_MASK 0x1000000
#define IMX_USB3_USBSS_USB_IEN_L1ENTIEN(v) (((v) << 0x18) & 0x1000000)
/* Field L1EXTIEN - LPM L1 state exit interrupt enable. This bit enables requesting an L1EXTI interrupt. */
#define IMX_USB3_USBSS_USB_IEN_L1EXTIEN_SHIFT 25
#define IMX_USB3_USBSS_USB_IEN_L1EXTIEN_MASK 0x2000000
#define IMX_USB3_USBSS_USB_IEN_L1EXTIEN(v) (((v) << 0x19) & 0x2000000)
/* Field CFGRESIEN - Configuration reset interrupt enable. This bit enables requesting a CFGRESI interrupt */
#define IMX_USB3_USBSS_USB_IEN_CFGRESIEN_SHIFT 26
#define IMX_USB3_USBSS_USB_IEN_CFGRESIEN_MASK 0x4000000
#define IMX_USB3_USBSS_USB_IEN_CFGRESIEN(v) (((v) << 0x1A) & 0x4000000)
/* Field RESERVED3 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_IEN_RESERVED3_SHIFT 27
#define IMX_USB3_USBSS_USB_IEN_RESERVED3_MASK 0x8000000
#define IMX_USB3_USBSS_USB_IEN_RESERVED3(v) (((v) << 0x1B) & 0x8000000)
/* Field UWRESSIEN - Start of the USB SS warm reset interrupt enable. This bit enables requesting a UWRESSI interrupt */
#define IMX_USB3_USBSS_USB_IEN_UWRESSIEN_SHIFT 28
#define IMX_USB3_USBSS_USB_IEN_UWRESSIEN_MASK 0x10000000
#define IMX_USB3_USBSS_USB_IEN_UWRESSIEN(v) (((v) << 0x1C) & 0x10000000)
/* Field UWRESEIEN - End of the USB SS warm reset interrupt enable. This bit enables requesting a UWRESEI interrupt */
#define IMX_USB3_USBSS_USB_IEN_UWRESEIEN_SHIFT 29
#define IMX_USB3_USBSS_USB_IEN_UWRESEIEN_MASK 0x20000000
#define IMX_USB3_USBSS_USB_IEN_UWRESEIEN(v) (((v) << 0x1D) & 0x20000000)
/* Field RESERVED4 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_IEN_RESERVED4_SHIFT 30
#define IMX_USB3_USBSS_USB_IEN_RESERVED4_MASK 0xC0000000
#define IMX_USB3_USBSS_USB_IEN_RESERVED4(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_USB_ISTS - USB Interrupt Status Register Each bit (interrupt flag) from this register can be cleared by writing '1'. */
typedef union IMX_USB3_USBSS_USB_ISTS_union_t {
    uint32_t R;
    struct {
        uint32_t CONI        :1;                 /* SS connection detected This interrupt informs that SuperSpeed link was conncted to the USB line This interrupt is reported on the irqs[0] pin. */
        uint32_t DISI        :1;                 /* SS disconnection detected This interrupt informs that SuperSpeed link was disconncted from the USB line. This interrupt is reported on the irqs[0] pin. */
        uint32_t UWRESI      :1;                 /* USB SS warm reset detected This interrupt is requested after the SuperSpeed warm reset ends or when USBSS-DEVs LTSSM exits Polling.LFPS state. After this reset, SW should reininitialize the controller. This interrupt is reported on the irqs[0] pin. */
        uint32_t UHRESI      :1;                 /* USB SS hot reset detected This interrupt is requested after the SuperSpeed hot reset ends. This interrupt is reported on the irqs[0] pin. */
        uint32_t U3ENTI      :1;                 /* SS link U3 state enter detected (suspend) This interrupt informs that SuperSpeed link enter U3 state. This interrupt is reported on the irqs[0] pin. */
        uint32_t U3EXTI      :1;                 /* SS link U3 state exit detected (wakeup) This interrupt informs that SuperSpeed link exit U3 state. This interrupt is reported on the irqs[1] pin. */
        uint32_t U2ENTI      :1;                 /* SS link U2 state enter detected This interrupt informs that SuperSpeed link enter U2 state. This interrupt is reported on the irqs[0] pin. */
        uint32_t U2EXTI      :1;                 /* SS link U2 state exit detected This interrupt informs that SuperSpeed link exit U2 state. This interrupt is reported on the irqs[0] pin. */
        uint32_t U1ENTI      :1;                 /* SS link U1 state enter detected This interrupt informs that SuperSpeed link enter U1 state. This interrupt is reported on the irqs[0] pin. */
        uint32_t U1EXTI      :1;                 /* SS link U1 state exit detected This interrupt informs that SuperSpeed link exit U1 state. This interrupt is reported on the irqs[0] pin. */
        uint32_t ITPI        :1;                 /* ITP/SOF packet detected In SuperSpeed mode this interrupt informs that ITP packet was received. In FS/HS mode this interrupt informs that SOF was detected. This interrupt is reported on the irqs[0] pin. */
        uint32_t WAKEI       :1;                 /* This interrupt informs that at wakeup pin appeared active state. This interrupt is reported on the irqs[1] pin. */
        uint32_t SPKTI       :1;                 /* Send Custom Packet This interrupt informs that Custom Packet prepared in the USB_CPKT1-3 registers and triggered with USB_CMD.SPKT bit was already sent. This interrupt is reported on the irqs[0] pin. */
        uint32_t RESERVED0   :3;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t CON2I       :1;                 /* HS/FS mode connection detected This interrupt informs that HS/FS upstream port was conncted to the USB line This interrupt is reported on the irqs[0] pin. */
        uint32_t DIS2I       :1;                 /* HS/FS mode disconnection detected This interrupt informs that HS/FS upstream port was disconncted from the USB line. This interrupt is reported on the irqs[0] pin. */
        uint32_t U2RESI      :1;                 /* USB reset (HS/FS mode) detected This interrupt is requested after the USB reset in HS/FS mode ends. This interrupt is reported on the irqs[0] pin. */
        uint32_t RESERVED1   :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t L2ENTI      :1;                 /* LPM L2 state enter detected This interrupt informs that HS/FS LPM enter L2 state. This interrupt is reported on the irqs[0] pin. */
        uint32_t L2EXTI      :1;                 /* LPM L2 state exit detected This interrupt informs that HS/FS LPM exit L2 state. This interrupt is reported on the irqs[1] pin. */
        uint32_t RESERVED2   :2;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t L1ENTI      :1;                 /* LPM L1 state enter detected This interrupt informs that HS/FS LPM enter L1 state. This interrupt is reported on the irqs[0] pin. */
        uint32_t L1EXTI      :1;                 /* LPM L1 state exit detected This interrupt informs that HS/FS LPM exit L1 state. This interrupt is reported on the irqs[0] pin. */
        uint32_t CFGRESI     :1;                 /* USB configuration reset detected. This interrupt is requested after the device internally resets its endpoints onfiguration. This is done after each USB reset (UWRESI, UWRESI or U2RESI), after each connection event (CONI, CON2I) and after configuration reset initiated by software (USB_CONF.CFGRST). Generally this interrupt is generated in the same time as mentioned interrupts, however due to internal clock domain synchronisation this configuration reset can be performed a little later, so one can use this interrupt to perform some software operations. This interrupt informs that controller did the following operations: disabled all non control endpoints, cleared all pending endpoints transfers and interrupts. The configuration reset does not clear general device configuration (set in USB_CONF) and EP0 configuration settings. This interrupt is reported on the irqs[0] pin. */
        uint32_t RESERVED3   :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t UWRESSI     :1;                 /* Start of the USB warm reset detected. This interrupt is requested as soon as the SuperSpeed warm reset signalling is detected. This interrupt is reported on the irqs[0] pin. */
        uint32_t UWRESEI     :1;                 /* End of the USB warm reset detected. This interrupt is requested after the SuperSpeed warm reset ends. This interrupt is reported on the irqs[0] pin. */
        uint32_t RESERVED4   :2;                 /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_USB_ISTS_t;

/* Register USB_ISTS - USB Interrupt Status Register Each bit (interrupt flag) from this register can be cleared by writing '1'. */
#define IMX_USB3_USBSS_USB_ISTS_OFFSET 0x20018
/* Field CONI - SS connection detected This interrupt informs that SuperSpeed link was conncted to the USB line This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_CONI_SHIFT 0
#define IMX_USB3_USBSS_USB_ISTS_CONI_MASK 0x1
#define IMX_USB3_USBSS_USB_ISTS_CONI(v) (((v) << 0) & 0x1)
/* Field DISI - SS disconnection detected This interrupt informs that SuperSpeed link was disconncted from the USB line. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_DISI_SHIFT 1
#define IMX_USB3_USBSS_USB_ISTS_DISI_MASK 0x2
#define IMX_USB3_USBSS_USB_ISTS_DISI(v) (((v) << 0x1) & 0x2)
/* Field UWRESI - USB SS warm reset detected This interrupt is requested after the SuperSpeed warm reset ends or when USBSS-DEVs LTSSM exits Polling.LFPS state. After this reset, SW should reininitialize the controller. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_UWRESI_SHIFT 2
#define IMX_USB3_USBSS_USB_ISTS_UWRESI_MASK 0x4
#define IMX_USB3_USBSS_USB_ISTS_UWRESI(v) (((v) << 0x2) & 0x4)
/* Field UHRESI - USB SS hot reset detected This interrupt is requested after the SuperSpeed hot reset ends. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_UHRESI_SHIFT 3
#define IMX_USB3_USBSS_USB_ISTS_UHRESI_MASK 0x8
#define IMX_USB3_USBSS_USB_ISTS_UHRESI(v) (((v) << 0x3) & 0x8)
/* Field U3ENTI - SS link U3 state enter detected (suspend) This interrupt informs that SuperSpeed link enter U3 state. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_U3ENTI_SHIFT 4
#define IMX_USB3_USBSS_USB_ISTS_U3ENTI_MASK 0x10
#define IMX_USB3_USBSS_USB_ISTS_U3ENTI(v) (((v) << 0x4) & 0x10)
/* Field U3EXTI - SS link U3 state exit detected (wakeup) This interrupt informs that SuperSpeed link exit U3 state. This interrupt is reported on the irqs[1] pin. */
#define IMX_USB3_USBSS_USB_ISTS_U3EXTI_SHIFT 5
#define IMX_USB3_USBSS_USB_ISTS_U3EXTI_MASK 0x20
#define IMX_USB3_USBSS_USB_ISTS_U3EXTI(v) (((v) << 0x5) & 0x20)
/* Field U2ENTI - SS link U2 state enter detected This interrupt informs that SuperSpeed link enter U2 state. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_U2ENTI_SHIFT 6
#define IMX_USB3_USBSS_USB_ISTS_U2ENTI_MASK 0x40
#define IMX_USB3_USBSS_USB_ISTS_U2ENTI(v) (((v) << 0x6) & 0x40)
/* Field U2EXTI - SS link U2 state exit detected This interrupt informs that SuperSpeed link exit U2 state. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_U2EXTI_SHIFT 7
#define IMX_USB3_USBSS_USB_ISTS_U2EXTI_MASK 0x80
#define IMX_USB3_USBSS_USB_ISTS_U2EXTI(v) (((v) << 0x7) & 0x80)
/* Field U1ENTI - SS link U1 state enter detected This interrupt informs that SuperSpeed link enter U1 state. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_U1ENTI_SHIFT 8
#define IMX_USB3_USBSS_USB_ISTS_U1ENTI_MASK 0x100
#define IMX_USB3_USBSS_USB_ISTS_U1ENTI(v) (((v) << 0x8) & 0x100)
/* Field U1EXTI - SS link U1 state exit detected This interrupt informs that SuperSpeed link exit U1 state. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_U1EXTI_SHIFT 9
#define IMX_USB3_USBSS_USB_ISTS_U1EXTI_MASK 0x200
#define IMX_USB3_USBSS_USB_ISTS_U1EXTI(v) (((v) << 0x9) & 0x200)
/* Field ITPI - ITP/SOF packet detected In SuperSpeed mode this interrupt informs that ITP packet was received. In FS/HS mode this interrupt informs that SOF was detected. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_ITPI_SHIFT 10
#define IMX_USB3_USBSS_USB_ISTS_ITPI_MASK 0x400
#define IMX_USB3_USBSS_USB_ISTS_ITPI(v) (((v) << 0xA) & 0x400)
/* Field WAKEI - This interrupt informs that at wakeup pin appeared active state. This interrupt is reported on the irqs[1] pin. */
#define IMX_USB3_USBSS_USB_ISTS_WAKEI_SHIFT 11
#define IMX_USB3_USBSS_USB_ISTS_WAKEI_MASK 0x800
#define IMX_USB3_USBSS_USB_ISTS_WAKEI(v) (((v) << 0xB) & 0x800)
/* Field SPKTI - Send Custom Packet This interrupt informs that Custom Packet prepared in the USB_CPKT1-3 registers and triggered with USB_CMD.SPKT bit was already sent. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_SPKTI_SHIFT 12
#define IMX_USB3_USBSS_USB_ISTS_SPKTI_MASK 0x1000
#define IMX_USB3_USBSS_USB_ISTS_SPKTI(v) (((v) << 0xC) & 0x1000)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_ISTS_RESERVED0_SHIFT 13
#define IMX_USB3_USBSS_USB_ISTS_RESERVED0_MASK 0xE000
#define IMX_USB3_USBSS_USB_ISTS_RESERVED0(v) (((v) << 0xD) & 0xE000)
/* Field CON2I - HS/FS mode connection detected This interrupt informs that HS/FS upstream port was conncted to the USB line This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_CON2I_SHIFT 16
#define IMX_USB3_USBSS_USB_ISTS_CON2I_MASK 0x10000
#define IMX_USB3_USBSS_USB_ISTS_CON2I(v) (((v) << 0x10) & 0x10000)
/* Field DIS2I - HS/FS mode disconnection detected This interrupt informs that HS/FS upstream port was disconncted from the USB line. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_DIS2I_SHIFT 17
#define IMX_USB3_USBSS_USB_ISTS_DIS2I_MASK 0x20000
#define IMX_USB3_USBSS_USB_ISTS_DIS2I(v) (((v) << 0x11) & 0x20000)
/* Field U2RESI - USB reset (HS/FS mode) detected This interrupt is requested after the USB reset in HS/FS mode ends. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_U2RESI_SHIFT 18
#define IMX_USB3_USBSS_USB_ISTS_U2RESI_MASK 0x40000
#define IMX_USB3_USBSS_USB_ISTS_U2RESI(v) (((v) << 0x12) & 0x40000)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_ISTS_RESERVED1_SHIFT 19
#define IMX_USB3_USBSS_USB_ISTS_RESERVED1_MASK 0x80000
#define IMX_USB3_USBSS_USB_ISTS_RESERVED1(v) (((v) << 0x13) & 0x80000)
/* Field L2ENTI - LPM L2 state enter detected This interrupt informs that HS/FS LPM enter L2 state. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_L2ENTI_SHIFT 20
#define IMX_USB3_USBSS_USB_ISTS_L2ENTI_MASK 0x100000
#define IMX_USB3_USBSS_USB_ISTS_L2ENTI(v) (((v) << 0x14) & 0x100000)
/* Field L2EXTI - LPM L2 state exit detected This interrupt informs that HS/FS LPM exit L2 state. This interrupt is reported on the irqs[1] pin. */
#define IMX_USB3_USBSS_USB_ISTS_L2EXTI_SHIFT 21
#define IMX_USB3_USBSS_USB_ISTS_L2EXTI_MASK 0x200000
#define IMX_USB3_USBSS_USB_ISTS_L2EXTI(v) (((v) << 0x15) & 0x200000)
/* Field RESERVED2 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_ISTS_RESERVED2_SHIFT 22
#define IMX_USB3_USBSS_USB_ISTS_RESERVED2_MASK 0xC00000
#define IMX_USB3_USBSS_USB_ISTS_RESERVED2(v) (((v) << 0x16) & 0xC00000)
/* Field L1ENTI - LPM L1 state enter detected This interrupt informs that HS/FS LPM enter L1 state. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_L1ENTI_SHIFT 24
#define IMX_USB3_USBSS_USB_ISTS_L1ENTI_MASK 0x1000000
#define IMX_USB3_USBSS_USB_ISTS_L1ENTI(v) (((v) << 0x18) & 0x1000000)
/* Field L1EXTI - LPM L1 state exit detected This interrupt informs that HS/FS LPM exit L1 state. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_L1EXTI_SHIFT 25
#define IMX_USB3_USBSS_USB_ISTS_L1EXTI_MASK 0x2000000
#define IMX_USB3_USBSS_USB_ISTS_L1EXTI(v) (((v) << 0x19) & 0x2000000)
/* Field CFGRESI - USB configuration reset detected. This interrupt is requested after the device internally resets its endpoints onfiguration. This is done after each USB reset (UWRESI, UWRESI or U2RESI), after each connection event (CONI, CON2I) and after configuration reset initiated by software (USB_CONF.CFGRST). Generally this interrupt is generated in the same time as mentioned interrupts, however due to internal clock domain synchronisation this configuration reset can be performed a little later, so one can use this interrupt to perform some software operations. This interrupt informs that controller did the following operations: disabled all non control endpoints, cleared all pending endpoints transfers and interrupts. The configuration reset does not clear general device configuration (set in USB_CONF) and EP0 configuration settings. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_CFGRESI_SHIFT 26
#define IMX_USB3_USBSS_USB_ISTS_CFGRESI_MASK 0x4000000
#define IMX_USB3_USBSS_USB_ISTS_CFGRESI(v) (((v) << 0x1A) & 0x4000000)
/* Field RESERVED3 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_ISTS_RESERVED3_SHIFT 27
#define IMX_USB3_USBSS_USB_ISTS_RESERVED3_MASK 0x8000000
#define IMX_USB3_USBSS_USB_ISTS_RESERVED3(v) (((v) << 0x1B) & 0x8000000)
/* Field UWRESSI - Start of the USB warm reset detected. This interrupt is requested as soon as the SuperSpeed warm reset signalling is detected. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_UWRESSI_SHIFT 28
#define IMX_USB3_USBSS_USB_ISTS_UWRESSI_MASK 0x10000000
#define IMX_USB3_USBSS_USB_ISTS_UWRESSI(v) (((v) << 0x1C) & 0x10000000)
/* Field UWRESEI - End of the USB warm reset detected. This interrupt is requested after the SuperSpeed warm reset ends. This interrupt is reported on the irqs[0] pin. */
#define IMX_USB3_USBSS_USB_ISTS_UWRESEI_SHIFT 29
#define IMX_USB3_USBSS_USB_ISTS_UWRESEI_MASK 0x20000000
#define IMX_USB3_USBSS_USB_ISTS_UWRESEI(v) (((v) << 0x1D) & 0x20000000)
/* Field RESERVED4 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_ISTS_RESERVED4_SHIFT 30
#define IMX_USB3_USBSS_USB_ISTS_RESERVED4_MASK 0xC0000000
#define IMX_USB3_USBSS_USB_ISTS_RESERVED4(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_EP_SEL - Endpoint Select Register This register is used in conjunction with Endpoint Configuration, Command, Status, and Transfer ring address registers. */
typedef union IMX_USB3_USBSS_EP_SEL_union_t {
    uint32_t R;
    struct {
        uint32_t EPNO        :4;                 /* Selected Endpoint number */
        uint32_t RESERVED0   :3;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t DIR         :1;                 /* Selected Endpoint direction. 0-OUT Endpoint selected, 1-IN Endpoint selected */
        uint32_t RESERVED1   :24;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_EP_SEL_t;

/* Register EP_SEL - Endpoint Select Register This register is used in conjunction with Endpoint Configuration, Command, Status, and Transfer ring address registers. */
#define IMX_USB3_USBSS_EP_SEL_OFFSET 0x2001C
/* Field EPNO - Selected Endpoint number */
#define IMX_USB3_USBSS_EP_SEL_EPNO_SHIFT 0
#define IMX_USB3_USBSS_EP_SEL_EPNO_MASK 0xF
#define IMX_USB3_USBSS_EP_SEL_EPNO(v) (((v) << 0) & 0xF)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_SEL_RESERVED0_SHIFT 4
#define IMX_USB3_USBSS_EP_SEL_RESERVED0_MASK 0x70
#define IMX_USB3_USBSS_EP_SEL_RESERVED0(v) (((v) << 0x4) & 0x70)
/* Field DIR - Selected Endpoint direction. 0-OUT Endpoint selected, 1-IN Endpoint selected */
#define IMX_USB3_USBSS_EP_SEL_DIR_SHIFT 7
#define IMX_USB3_USBSS_EP_SEL_DIR_MASK 0x80
#define IMX_USB3_USBSS_EP_SEL_DIR(v) (((v) << 0x7) & 0x80)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_SEL_RESERVED1_SHIFT 8
#define IMX_USB3_USBSS_EP_SEL_RESERVED1_MASK 0xFFFFFF00
#define IMX_USB3_USBSS_EP_SEL_RESERVED1(v) (((v) << 0x8) & 0xFFFFFF00)

/* IMX_USB3_USBSS_EP_TRADDR - Endpoint Transfer Ring Address Register All bytes of the register must be written, to store the TRADDR value. */
typedef union IMX_USB3_USBSS_EP_TRADDR_union_t {
    uint32_t R;
    struct {
        uint32_t TRADDR      :32;                /* Transfer Ring address. Address of transfer ring for endpoint selected by endpoint select register. Based on this address, DMA will fetch transfer descriptors from system memory. This register can be used as dequeue pointer. CPU can use this register (read it or write to it) only when endpoint is configured and enabled (using EP_CFG register) */
    } B;
} IMX_USB3_USBSS_EP_TRADDR_t;

/* Register EP_TRADDR - Endpoint Transfer Ring Address Register All bytes of the register must be written, to store the TRADDR value. */
#define IMX_USB3_USBSS_EP_TRADDR_OFFSET 0x20020
/* Field TRADDR - Transfer Ring address. Address of transfer ring for endpoint selected by endpoint select register. Based on this address, DMA will fetch transfer descriptors from system memory. This register can be used as dequeue pointer. CPU can use this register (read it or write to it) only when endpoint is configured and enabled (using EP_CFG register) */
#define IMX_USB3_USBSS_EP_TRADDR_TRADDR_SHIFT 0
#define IMX_USB3_USBSS_EP_TRADDR_TRADDR_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_EP_TRADDR_TRADDR(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_EP_CFG - Endpoint Configuration Register The endpoint configuration can be changed only once after reset (or configuration reset: USB_CONF. */
typedef union IMX_USB3_USBSS_EP_CFG_union_t {
    uint32_t R;
    struct {
        uint32_t ENABLE      :1;                 /* Endpoint enable. If endpoint is disabled (the ENABLE bit is cleared), the endpoint will not: - request any interrupts - start any transmission over the DMA Even if Endpoint is disabled, software can set DRDY bit for it, but the DMA transmission will not begin until the endpoint is enabled. 0: disabled 1: enabled Reset value of this bit for EP0 is 1, for other EP's is 0. */
        uint32_t EPTYPE      :2;                 /* Endpoint type. 0: control, 1: isochronous, 2: bulk, 3: interrupt. Endpoint type is programmable, however, certain types of transmissions require hardware support that must be incorporated prior to implementation. That can be done only for selected endpoints. Selective inclusion of hardware support is to reduce the size of the controller. Accordingly: - Endpoint-type iso should be set by the software only for those endpoints for which isochronous transmission hardware support is enabled. - A bulk endpoint can handle transmission with Bulk Streams support only for those endpoints for which Bulk Stream transmission hardware support is enabled. For detailed description how to implement hardware support for ISO transfers or Bulk Stream transfers see chapter 'Endpoints Implementation'. */
        uint32_t STREAM_EN   :1;                 /* Stream support enable (only in SS mode). This bit must be set to enable a stream transfes on a bulk endpoint 0: Stream support OFF 1: Stream support ON */
        uint32_t TDL_CHK     :1;                 /* TDL check(only in SS mode for BULK OUT EP). This field has to be set for stream capable SS bulk endpoints and it can be set for other bulk endpoint. The OUT bulk endpoints If the TDL_CHK bit is set if the device takes the packets to the OUT endpoint only when the value of the TDL (EP_CMD.TDL) for this endpoint is different from zero. Each received packet for the particular endpoint decrements the value of a TDL. If the TDL_CHK bit is not set, then each packet from the host to the OUT endpoint is taken as long as it free space in the on-chip device buffers. The IN bulk endpoints This bit is is used by USBSS_DEV to set EOB bit when TDL (programmed value) reach zero. 0: Do not check the TDL value when sending/receiving packets to the endpoints 1: Check the TDL value when sending/receiving packets to the endpoint */
        uint32_t SID_CHK     :1;                 /* SID check(only in SS mode for BULK OUT EP) This field can be set only for SS bulk OUT endpoints with stream support enabled 1) If SID_CHK bit is set, the device checks whether the incoming packets from the host to the particular OUT endpoint have the SID field set to the expected value. If the packet has an expected SID value is then taken and stored in the on-chip device buffers. If the packet has a different SID than expected, then the packet is rejected (NRDY) and the SIDERROR interrupt is reported to the software. The value of the SID to which incoming packets will be compared, are written to the device during sending ERDY TP (EP_CMD.ERDY and EP_CMD.ERDY_SID). The SID value from the incoming packet that has been rejected and caused the SIDERR interrupt can be read from the EP_STS_SID register. 2) If SID_CHK bit is not set, then each packet from the host is taken to the on-chip buffers is transmitted by the DMA regardless of the SID field in the TD. 0: SID chceck at device input OFF 1: SID chceck at device input ON */
        uint32_t RESERVED0   :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t EPENDIAN    :1;                 /* DMA transfer endianness. When the conversion is ON, the byte order within DWORD is inverted. While the bit is set, the software confirms that the transfer length is a multiplication of 4 bytes. Enabling the conversion is possible only when SUPPORT_ENDIANESS_CONV is defined. By default this parameter is not defined, so endianess conversion is disabled. 0: Endianess conversion OFF 1: Endianess conversion ON */
        uint32_t MAXBURST    :4;                 /* Maximum Burst size. The maximum number of packets the endpoint can send or receive as part of a burst. Valid values are from 0 to 15. A value of 0 indicates that the endpoint can only burst one packet at a time, and a value of 15 indicates that the endpoint can burst up to 16 packets at a time. For endpoints of type control this is set to 0. This field is meaningfull only in SuperSpeed mode. */
        uint32_t RESERVED1   :2;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t MULT        :2;                 /* ISO max burst SuperSpeed mode: A zero-based value that indicates the maximum number of bursts within a service interval that this endpoint supports. This field is only valid for isochronous endpoints. A value of zero indicates that the device supports one Burst of bMaxBurst packets per service interval. The max value that can be set in this field in SuperSpeed is '2'. HS/FS mode: This field indicates how many packets will be transferred during micro frame. In Full-Speed mode only one ISO IN packet can be transferred per endpoint, per frame, thus this field has to be always '0'. In High-Speed mode, up to three ISO IN packets can be transferred per endpoint, per microframe, so the max value that can be set in this field in HighSpeed is '2'. */
        uint32_t MAXPKTSIZE  :11;                /* Max packet size. The maximum packet size this endpoint is capable of sending or receiving. SuperSpeed mode: For control endpoints, this field is set to 512. For bulk endpoint types, this field is set to 1024. For interrupt and isochronous endpoints, this field is set to 1024 if this endpoint defines a value in the bMaxBurst field greater than zero. If the value in the bMaxBurst field is set to zero, then this field can have any value from 0 to 1024 for an isochronous endpoint, and 1 to 1024 for an interrupt endpoint. High Speed/Full Speed mode: For control endpoints, this field is set to 64. For other endpoint types this field can have any value from 0 to 1024. */
        uint32_t BUFFERING   :5;                 /* Max number of buffered packets. The maximum number of packets the device can buffer in the on-chip memory for a specified endpoint. Valid values are from 0 to 15. Value 0 means that 1 on-chip buffer is available for the appropriate endpoint. Value 15 means that 16 on-chip buffers are available for the appropriate endpoint. Each IN endpoint has individual buffers associated with it. OUT endpoints have common buffers, so buffering for OUT endpoints is determined by the maximum buffering value along all enabled OUT endpoints. The number of possible endpoint buffers depends on the on-chip memory size and the size of endpoint buffers. */
    } B;
} IMX_USB3_USBSS_EP_CFG_t;

/* Register EP_CFG - Endpoint Configuration Register The endpoint configuration can be changed only once after reset (or configuration reset: USB_CONF. */
#define IMX_USB3_USBSS_EP_CFG_OFFSET 0x20024
/* Field ENABLE - Endpoint enable. If endpoint is disabled (the ENABLE bit is cleared), the endpoint will not: - request any interrupts - start any transmission over the DMA Even if Endpoint is disabled, software can set DRDY bit for it, but the DMA transmission will not begin until the endpoint is enabled. 0: disabled 1: enabled Reset value of this bit for EP0 is 1, for other EP's is 0. */
#define IMX_USB3_USBSS_EP_CFG_ENABLE_SHIFT 0
#define IMX_USB3_USBSS_EP_CFG_ENABLE_MASK 0x1
#define IMX_USB3_USBSS_EP_CFG_ENABLE(v) (((v) << 0) & 0x1)
/* Field EPTYPE - Endpoint type. 0: control, 1: isochronous, 2: bulk, 3: interrupt. Endpoint type is programmable, however, certain types of transmissions require hardware support that must be incorporated prior to implementation. That can be done only for selected endpoints. Selective inclusion of hardware support is to reduce the size of the controller. Accordingly: - Endpoint-type iso should be set by the software only for those endpoints for which isochronous transmission hardware support is enabled. - A bulk endpoint can handle transmission with Bulk Streams support only for those endpoints for which Bulk Stream transmission hardware support is enabled. For detailed description how to implement hardware support for ISO transfers or Bulk Stream transfers see chapter 'Endpoints Implementation'. */
#define IMX_USB3_USBSS_EP_CFG_EPTYPE_SHIFT 1
#define IMX_USB3_USBSS_EP_CFG_EPTYPE_MASK 0x6
#define IMX_USB3_USBSS_EP_CFG_EPTYPE(v) (((v) << 0x1) & 0x6)
/* Field STREAM_EN - Stream support enable (only in SS mode). This bit must be set to enable a stream transfes on a bulk endpoint 0: Stream support OFF 1: Stream support ON */
#define IMX_USB3_USBSS_EP_CFG_STREAM_EN_SHIFT 3
#define IMX_USB3_USBSS_EP_CFG_STREAM_EN_MASK 0x8
#define IMX_USB3_USBSS_EP_CFG_STREAM_EN(v) (((v) << 0x3) & 0x8)
/* Field TDL_CHK - TDL check(only in SS mode for BULK OUT EP). This field has to be set for stream capable SS bulk endpoints and it can be set for other bulk endpoint. The OUT bulk endpoints If the TDL_CHK bit is set if the device takes the packets to the OUT endpoint only when the value of the TDL (EP_CMD.TDL) for this endpoint is different from zero. Each received packet for the particular endpoint decrements the value of a TDL. If the TDL_CHK bit is not set, then each packet from the host to the OUT endpoint is taken as long as it free space in the on-chip device buffers. The IN bulk endpoints This bit is is used by USBSS_DEV to set EOB bit when TDL (programmed value) reach zero. 0: Do not check the TDL value when sending/receiving packets to the endpoints 1: Check the TDL value when sending/receiving packets to the endpoint */
#define IMX_USB3_USBSS_EP_CFG_TDL_CHK_SHIFT 4
#define IMX_USB3_USBSS_EP_CFG_TDL_CHK_MASK 0x10
#define IMX_USB3_USBSS_EP_CFG_TDL_CHK(v) (((v) << 0x4) & 0x10)
/* Field SID_CHK - SID check(only in SS mode for BULK OUT EP) This field can be set only for SS bulk OUT endpoints with stream support enabled 1) If SID_CHK bit is set, the device checks whether the incoming packets from the host to the particular OUT endpoint have the SID field set to the expected value. If the packet has an expected SID value is then taken and stored in the on-chip device buffers. If the packet has a different SID than expected, then the packet is rejected (NRDY) and the SIDERROR interrupt is reported to the software. The value of the SID to which incoming packets will be compared, are written to the device during sending ERDY TP (EP_CMD.ERDY and EP_CMD.ERDY_SID). The SID value from the incoming packet that has been rejected and caused the SIDERR interrupt can be read from the EP_STS_SID register. 2) If SID_CHK bit is not set, then each packet from the host is taken to the on-chip buffers is transmitted by the DMA regardless of the SID field in the TD. 0: SID chceck at device input OFF 1: SID chceck at device input ON */
#define IMX_USB3_USBSS_EP_CFG_SID_CHK_SHIFT 5
#define IMX_USB3_USBSS_EP_CFG_SID_CHK_MASK 0x20
#define IMX_USB3_USBSS_EP_CFG_SID_CHK(v) (((v) << 0x5) & 0x20)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_CFG_RESERVED0_SHIFT 6
#define IMX_USB3_USBSS_EP_CFG_RESERVED0_MASK 0x40
#define IMX_USB3_USBSS_EP_CFG_RESERVED0(v) (((v) << 0x6) & 0x40)
/* Field EPENDIAN - DMA transfer endianness. When the conversion is ON, the byte order within DWORD is inverted. While the bit is set, the software confirms that the transfer length is a multiplication of 4 bytes. Enabling the conversion is possible only when SUPPORT_ENDIANESS_CONV is defined. By default this parameter is not defined, so endianess conversion is disabled. 0: Endianess conversion OFF 1: Endianess conversion ON */
#define IMX_USB3_USBSS_EP_CFG_EPENDIAN_SHIFT 7
#define IMX_USB3_USBSS_EP_CFG_EPENDIAN_MASK 0x80
#define IMX_USB3_USBSS_EP_CFG_EPENDIAN(v) (((v) << 0x7) & 0x80)
/* Field MAXBURST - Maximum Burst size. The maximum number of packets the endpoint can send or receive as part of a burst. Valid values are from 0 to 15. A value of 0 indicates that the endpoint can only burst one packet at a time, and a value of 15 indicates that the endpoint can burst up to 16 packets at a time. For endpoints of type control this is set to 0. This field is meaningfull only in SuperSpeed mode. */
#define IMX_USB3_USBSS_EP_CFG_MAXBURST_SHIFT 8
#define IMX_USB3_USBSS_EP_CFG_MAXBURST_MASK 0xF00
#define IMX_USB3_USBSS_EP_CFG_MAXBURST(v) (((v) << 0x8) & 0xF00)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_CFG_RESERVED1_SHIFT 12
#define IMX_USB3_USBSS_EP_CFG_RESERVED1_MASK 0x3000
#define IMX_USB3_USBSS_EP_CFG_RESERVED1(v) (((v) << 0xC) & 0x3000)
/* Field MULT - ISO max burst SuperSpeed mode: A zero-based value that indicates the maximum number of bursts within a service interval that this endpoint supports. This field is only valid for isochronous endpoints. A value of zero indicates that the device supports one Burst of bMaxBurst packets per service interval. The max value that can be set in this field in SuperSpeed is '2'. HS/FS mode: This field indicates how many packets will be transferred during micro frame. In Full-Speed mode only one ISO IN packet can be transferred per endpoint, per frame, thus this field has to be always '0'. In High-Speed mode, up to three ISO IN packets can be transferred per endpoint, per microframe, so the max value that can be set in this field in HighSpeed is '2'. */
#define IMX_USB3_USBSS_EP_CFG_MULT_SHIFT 14
#define IMX_USB3_USBSS_EP_CFG_MULT_MASK 0xC000
#define IMX_USB3_USBSS_EP_CFG_MULT(v) (((v) << 0xE) & 0xC000)
/* Field MAXPKTSIZE - Max packet size. The maximum packet size this endpoint is capable of sending or receiving. SuperSpeed mode: For control endpoints, this field is set to 512. For bulk endpoint types, this field is set to 1024. For interrupt and isochronous endpoints, this field is set to 1024 if this endpoint defines a value in the bMaxBurst field greater than zero. If the value in the bMaxBurst field is set to zero, then this field can have any value from 0 to 1024 for an isochronous endpoint, and 1 to 1024 for an interrupt endpoint. High Speed/Full Speed mode: For control endpoints, this field is set to 64. For other endpoint types this field can have any value from 0 to 1024. */
#define IMX_USB3_USBSS_EP_CFG_MAXPKTSIZE_SHIFT 16
#define IMX_USB3_USBSS_EP_CFG_MAXPKTSIZE_MASK 0x7FF0000
#define IMX_USB3_USBSS_EP_CFG_MAXPKTSIZE(v) (((v) << 0x10) & 0x7FF0000)
/* Field BUFFERING - Max number of buffered packets. The maximum number of packets the device can buffer in the on-chip memory for a specified endpoint. Valid values are from 0 to 15. Value 0 means that 1 on-chip buffer is available for the appropriate endpoint. Value 15 means that 16 on-chip buffers are available for the appropriate endpoint. Each IN endpoint has individual buffers associated with it. OUT endpoints have common buffers, so buffering for OUT endpoints is determined by the maximum buffering value along all enabled OUT endpoints. The number of possible endpoint buffers depends on the on-chip memory size and the size of endpoint buffers. */
#define IMX_USB3_USBSS_EP_CFG_BUFFERING_SHIFT 27
#define IMX_USB3_USBSS_EP_CFG_BUFFERING_MASK 0xF8000000
#define IMX_USB3_USBSS_EP_CFG_BUFFERING(v) (((v) << 0x1B) & 0xF8000000)

/* IMX_USB3_USBSS_EP_CMD - Endpoint Command Register */
typedef union IMX_USB3_USBSS_EP_CMD_union_t {
    uint32_t R;
    struct {
        uint32_t EPRST       :1;                 /* Endpoint reset. 0: no effect 1: resets endpoint This command performs the following actions for particular endpoint: - clears DRDY bit and stops DMA transfer - clears on-chip buffers - clears sequence number in SS mode or Data Toggle in HS/FS mode This command does not clear Endpoint interrupt if already requested (irq[0] pin was asserted) thus it is recommended first to clear all interrupts from endpoint scheduled to reset. When EPRST operation is started ('1' is written), CPU must wait until this bit becomes again '0' (it indicates that HW finishes all internal opertations related to DFLUSH), and only then can proceed with next software operations. Additionally, when DMA already started processing TD for this EP, the EPRST command cause that DMA engine will once more access the descriptor in external memory. After endpoint reset the software is responsible for it to re-set the Endpoint TRADDR. Writing '0 'has no effect. */
        uint32_t SSTALL      :1;                 /* Endpoint STALL set. Writing '1' to this bit cause the endpoint is halted. 0: no effect 1: STALLs endpoint */
        uint32_t CSTALL      :1;                 /* Endpoint STALL clear. Writing '1' to this bit cause the endpoint becames not halted. 0: no effect 1: clears endpoint STALL */
        uint32_t ERDY        :1;                 /* Send ERDY TP. Writing '1' to this bit forces the device to send ERDY TP with stream ID equal to ERDY_SID. This bit is necessary to support SS bulk stream transfers. This bit is also used during control transfers (in both modes: HS/FS and SS): writing '1' instruct device controller HW that it can exit from Setup Stage to the Data Stage (or directly to the Status Stage if USB Request is without Data Stage). However the ERDY packet is only actually sent in SS mode. Writing '0' has no effect. */
        uint32_t RESERVED    :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t REQ_CMPL    :1;                 /* Request complete. 0 : no effect 1 : informs device that Request service is complete Bit valid only for endpoint 0. Writing '1' to this bit informs USBSS-DEV that software finished USB request service and device can send ACK answer for the Status Stage within USB request. This bit is automatically cleared by USBSS-DEV after device answers to the status stage with ACK or STALL. Until software do not set this bit, during proceeding current host request, the device will answer to the status stage with NRDY answer. */
        uint32_t DRDY        :1;                 /* Transfer descriptor ready. Transfer Descriptor Ready for selected endpoint (0 - no effect, 1 - starts transfer). Writing '1' to this bit informs USBSS-DEV that in-system memory has prepared a new Transfer Descriptor for selected endpoints. If an IN endpoint is 'Not Ready' (NRDY=1 in Endpoint Status Register), then setting the DRDY bit (which is proceeded by DMA transfer to the on-chip buffers) will cause the device to send the ERDY packet. If the TRB error occurs, the DRDY bit is cleared and held in the low state until the TRBERR is not cleared (even if the DTRANS bit is set, the Multiple TRB chain mode is enabled). This bit is duplicated in the Doorbell register. Writing '1' to this bit while DESCMIS interrupt flag is set for the same endpoint will also clear the DESCMIS flag. */
        uint32_t DFLUSH      :1;                 /* Data flush. Writing '1' to this bit performs the following actions for particular endpoint: - clears DRDY bit and stops DMA transfer - flush endpoint data from on chip buffers As in case of Endpoint reset (EPRST bit), after endpoint data flush the software is responsible for it to re-set the Endpoint TRADDR. When DFLUSH operation is started ('1' is written), CPU must wait until this bit becomes again '0' (it indicates that HW finishes all internal opertations related to DFLUSH), and only then can proceed with next software operations. Writing '0' has no effect. */
        uint32_t STDL        :1;                 /* Transfer Descriptor Length write (used only for Bulk Stream capable endpoints in SS mode). Writing '1' to this bit writes to the device the TDL field. The bit is automatically cleared. */
        uint32_t TDL         :7;                 /* Transfer Descriptor Length (used only in SS mode for bulk endpoints). Using the field TDL for bulk EP assumes TDL_CHK bit enabled. This field will be writen to the device when the EP_CMD.STDL bit is set to '1'. This field is used by the device when particular endpoint: - is configured as Stream capable (EP_CFG.STREAM_EN bit is set) or - the IOT interrupt is to be used This field should be written each time, when bit EP_CMD.DRDY is written (i.e. device is notified that new TD is ready). The written value should correspond to the prepared data size (multiple of endpoint MAXPKTSIZE eg. in KB for BULK EP) in the transfer descriptor (which has been prepared for this endpoint before DRDY bit is set) rounded up (if short packet expected). This field has to be written no later than DRDY (or Dorbel) bit. 1) For OUT endpoints device will decrement this field by one after each successful packet received from the host. 2) For IN endpoints device will decrement this field by one after each successful handshake packet received from the host. As long as this field is not decremented to zero, then for each response NRDY that device send to the host (e.g. due to temporary lack of space (OUT EP) / packets (IN EP) in the on-chip buffers), device will automatically send the ERDY package to the host as soon as free spece (OUT EP) / new packet (IN EP) will be available in the on-chip buffers. When the field TDL is decremented to zero then, it will mean that the device does not expect to have more packets from the host (OUT EP) / does not want to send more packets (IN EP). Then device generates IOT interrupt and from this moment ERDY TP will not be sent automatically if endpoint enters flow control. Additionally, if TDL_CHK is set (only for BULK EP), and TDL value is equal to zero, device will: - for OUT EP - not accept any data packet from host for particular EP, even if there are empty OUT buffers. In this case device answer with NRDY TP and NRDY interrupt will be requested. - for IN EP - send last programmed (according to the TDL field) with EOB bit set. Writing into this field any value at the time when the previous value of this field was not zero, will result in adding these two values. */
        uint32_t ERDY_SID    :16;                /* ERDY Stream ID value (used in SS mode). This field contains SID - it will be sent to host in ERDY packet (by writing '1' to ERDY). This field is meaningfull only in SuperSpeed mode. */
    } B;
} IMX_USB3_USBSS_EP_CMD_t;

/* Register EP_CMD - Endpoint Command Register */
#define IMX_USB3_USBSS_EP_CMD_OFFSET 0x20028
/* Field EPRST - Endpoint reset. 0: no effect 1: resets endpoint This command performs the following actions for particular endpoint: - clears DRDY bit and stops DMA transfer - clears on-chip buffers - clears sequence number in SS mode or Data Toggle in HS/FS mode This command does not clear Endpoint interrupt if already requested (irq[0] pin was asserted) thus it is recommended first to clear all interrupts from endpoint scheduled to reset. When EPRST operation is started ('1' is written), CPU must wait until this bit becomes again '0' (it indicates that HW finishes all internal opertations related to DFLUSH), and only then can proceed with next software operations. Additionally, when DMA already started processing TD for this EP, the EPRST command cause that DMA engine will once more access the descriptor in external memory. After endpoint reset the software is responsible for it to re-set the Endpoint TRADDR. Writing '0 'has no effect. */
#define IMX_USB3_USBSS_EP_CMD_EPRST_SHIFT 0
#define IMX_USB3_USBSS_EP_CMD_EPRST_MASK 0x1
#define IMX_USB3_USBSS_EP_CMD_EPRST(v) (((v) << 0) & 0x1)
/* Field SSTALL - Endpoint STALL set. Writing '1' to this bit cause the endpoint is halted. 0: no effect 1: STALLs endpoint */
#define IMX_USB3_USBSS_EP_CMD_SSTALL_SHIFT 1
#define IMX_USB3_USBSS_EP_CMD_SSTALL_MASK 0x2
#define IMX_USB3_USBSS_EP_CMD_SSTALL(v) (((v) << 0x1) & 0x2)
/* Field CSTALL - Endpoint STALL clear. Writing '1' to this bit cause the endpoint becames not halted. 0: no effect 1: clears endpoint STALL */
#define IMX_USB3_USBSS_EP_CMD_CSTALL_SHIFT 2
#define IMX_USB3_USBSS_EP_CMD_CSTALL_MASK 0x4
#define IMX_USB3_USBSS_EP_CMD_CSTALL(v) (((v) << 0x2) & 0x4)
/* Field ERDY - Send ERDY TP. Writing '1' to this bit forces the device to send ERDY TP with stream ID equal to ERDY_SID. This bit is necessary to support SS bulk stream transfers. This bit is also used during control transfers (in both modes: HS/FS and SS): writing '1' instruct device controller HW that it can exit from Setup Stage to the Data Stage (or directly to the Status Stage if USB Request is without Data Stage). However the ERDY packet is only actually sent in SS mode. Writing '0' has no effect. */
#define IMX_USB3_USBSS_EP_CMD_ERDY_SHIFT 3
#define IMX_USB3_USBSS_EP_CMD_ERDY_MASK 0x8
#define IMX_USB3_USBSS_EP_CMD_ERDY(v) (((v) << 0x3) & 0x8)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_CMD_RESERVED_SHIFT 4
#define IMX_USB3_USBSS_EP_CMD_RESERVED_MASK 0x10
#define IMX_USB3_USBSS_EP_CMD_RESERVED(v) (((v) << 0x4) & 0x10)
/* Field REQ_CMPL - Request complete. 0 : no effect 1 : informs device that Request service is complete Bit valid only for endpoint 0. Writing '1' to this bit informs USBSS-DEV that software finished USB request service and device can send ACK answer for the Status Stage within USB request. This bit is automatically cleared by USBSS-DEV after device answers to the status stage with ACK or STALL. Until software do not set this bit, during proceeding current host request, the device will answer to the status stage with NRDY answer. */
#define IMX_USB3_USBSS_EP_CMD_REQ_CMPL_SHIFT 5
#define IMX_USB3_USBSS_EP_CMD_REQ_CMPL_MASK 0x20
#define IMX_USB3_USBSS_EP_CMD_REQ_CMPL(v) (((v) << 0x5) & 0x20)
/* Field DRDY - Transfer descriptor ready. Transfer Descriptor Ready for selected endpoint (0 - no effect, 1 - starts transfer). Writing '1' to this bit informs USBSS-DEV that in-system memory has prepared a new Transfer Descriptor for selected endpoints. If an IN endpoint is 'Not Ready' (NRDY=1 in Endpoint Status Register), then setting the DRDY bit (which is proceeded by DMA transfer to the on-chip buffers) will cause the device to send the ERDY packet. If the TRB error occurs, the DRDY bit is cleared and held in the low state until the TRBERR is not cleared (even if the DTRANS bit is set, the Multiple TRB chain mode is enabled). This bit is duplicated in the Doorbell register. Writing '1' to this bit while DESCMIS interrupt flag is set for the same endpoint will also clear the DESCMIS flag. */
#define IMX_USB3_USBSS_EP_CMD_DRDY_SHIFT 6
#define IMX_USB3_USBSS_EP_CMD_DRDY_MASK 0x40
#define IMX_USB3_USBSS_EP_CMD_DRDY(v) (((v) << 0x6) & 0x40)
/* Field DFLUSH - Data flush. Writing '1' to this bit performs the following actions for particular endpoint: - clears DRDY bit and stops DMA transfer - flush endpoint data from on chip buffers As in case of Endpoint reset (EPRST bit), after endpoint data flush the software is responsible for it to re-set the Endpoint TRADDR. When DFLUSH operation is started ('1' is written), CPU must wait until this bit becomes again '0' (it indicates that HW finishes all internal opertations related to DFLUSH), and only then can proceed with next software operations. Writing '0' has no effect. */
#define IMX_USB3_USBSS_EP_CMD_DFLUSH_SHIFT 7
#define IMX_USB3_USBSS_EP_CMD_DFLUSH_MASK 0x80
#define IMX_USB3_USBSS_EP_CMD_DFLUSH(v) (((v) << 0x7) & 0x80)
/* Field STDL - Transfer Descriptor Length write (used only for Bulk Stream capable endpoints in SS mode). Writing '1' to this bit writes to the device the TDL field. The bit is automatically cleared. */
#define IMX_USB3_USBSS_EP_CMD_STDL_SHIFT 8
#define IMX_USB3_USBSS_EP_CMD_STDL_MASK 0x100
#define IMX_USB3_USBSS_EP_CMD_STDL(v) (((v) << 0x8) & 0x100)
/* Field TDL - Transfer Descriptor Length (used only in SS mode for bulk endpoints). Using the field TDL for bulk EP assumes TDL_CHK bit enabled. This field will be writen to the device when the EP_CMD.STDL bit is set to '1'. This field is used by the device when particular endpoint: - is configured as Stream capable (EP_CFG.STREAM_EN bit is set) or - the IOT interrupt is to be used This field should be written each time, when bit EP_CMD.DRDY is written (i.e. device is notified that new TD is ready). The written value should correspond to the prepared data size (multiple of endpoint MAXPKTSIZE eg. in KB for BULK EP) in the transfer descriptor (which has been prepared for this endpoint before DRDY bit is set) rounded up (if short packet expected). This field has to be written no later than DRDY (or Dorbel) bit. 1) For OUT endpoints device will decrement this field by one after each successful packet received from the host. 2) For IN endpoints device will decrement this field by one after each successful handshake packet received from the host. As long as this field is not decremented to zero, then for each response NRDY that device send to the host (e.g. due to temporary lack of space (OUT EP) / packets (IN EP) in the on-chip buffers), device will automatically send the ERDY package to the host as soon as free spece (OUT EP) / new packet (IN EP) will be available in the on-chip buffers. When the field TDL is decremented to zero then, it will mean that the device does not expect to have more packets from the host (OUT EP) / does not want to send more packets (IN EP). Then device generates IOT interrupt and from this moment ERDY TP will not be sent automatically if endpoint enters flow control. Additionally, if TDL_CHK is set (only for BULK EP), and TDL value is equal to zero, device will: - for OUT EP - not accept any data packet from host for particular EP, even if there are empty OUT buffers. In this case device answer with NRDY TP and NRDY interrupt will be requested. - for IN EP - send last programmed (according to the TDL field) with EOB bit set. Writing into this field any value at the time when the previous value of this field was not zero, will result in adding these two values. */
#define IMX_USB3_USBSS_EP_CMD_TDL_SHIFT 9
#define IMX_USB3_USBSS_EP_CMD_TDL_MASK 0xFE00
#define IMX_USB3_USBSS_EP_CMD_TDL(v) (((v) << 0x9) & 0xFE00)
/* Field ERDY_SID - ERDY Stream ID value (used in SS mode). This field contains SID - it will be sent to host in ERDY packet (by writing '1' to ERDY). This field is meaningfull only in SuperSpeed mode. */
#define IMX_USB3_USBSS_EP_CMD_ERDY_SID_SHIFT 16
#define IMX_USB3_USBSS_EP_CMD_ERDY_SID_MASK 0xFFFF0000
#define IMX_USB3_USBSS_EP_CMD_ERDY_SID(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_EP_STS - Endpoint Status Register. */
typedef union IMX_USB3_USBSS_EP_STS_union_t {
    uint32_t R;
    struct {
        uint32_t SETUP       :1;                 /* Setup transfer complete. Bit used only for EP0. If setup type transmission has been completed and data from host has been received and copied to system memory, this bit is set to '1' and interrupt is generated. Setup packet is applicable only to control transmissions (EP0). This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
        uint32_t STALL       :1;                 /* Endpoint STALL status 0 - endpoint is not stalled 1 - endpoint is stalled This bit is not treated as an interrupt (not reported in the EP__ISTS register). This bit is read-only. */
        uint32_t IOC         :1;                 /* Interrupt On Complete When DMA transfer is completed and transfer descriptor is updated, then this bit is set to 1 and interrupt is generated. Enabling or disabling of this interrupt is realized by IOC bit in transfer descriptor. Additionally, this interrupt can be masked for a particular endpoint in EP__ISTS register. When in given transfer descriptor both interrupts (IOC and ISP interrupts) are enabled, then in the case of short packet, only one interrupt is generated - SP. Writing '1' to this bit clears the interrupt. */
        uint32_t ISP         :1;                 /* Interrupt on Short Packet. This bit is set to 1 and interrupt is generated when a transfer containing less data than MaxPacket for a given endpoint has been completed and transfer descriptor has been updated.Enabling or disabling of interrupt is realized by ISP bit in transfer descriptor. Additionally, this interrupt can be masked for a particular endpoint in EP__ISTS register. When in given transfer descriptor both interrupts are enabled (IOC and ISP), then in the case of short packet only one interrupt is generated - SP. Writing '1' to this bit clears the interrupt. */
        uint32_t DESCMIS     :1;                 /* Transfer descriptor missing. This bit is set to 1 and interrupt is generated when any of the following conditions are met: - device is requested to send data to host and none of Transfer Descriptor is prepared (IN transfer) - device receives OUT packet and cannot transmit it using DMA as Transfer Descriptor has not been prepared (DRDY was not set) for it (OUT transfer) Note1: This interrupt is not generated for ISO IN endpoints. For such endpoints the ISOERR interrupt should be used. Note2: DMA will not start operating on transfer descriptor array until the OUT packet is received (or host requests IN packet) and processor has not previously notified DMA (by writing to EP_CMD register of DRDY register). Note2: For BULK OUT endpoints with TDL_CHK bit set this interrupt will not by requested as device will not accept any packet from host when TRB is not prepared (and TDL is not written with non-zero value). In this case the NRDY interrupt should be used instead of DESMIS. Writing '1' to this bit or writing '1' to EP_CMD.DRDY bit of endpoints which generated interrupt will delete the interrupt. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
        uint32_t STREAMR     :1;                 /* Stream Rejected (used only in SS mode). This bit is set to '1' if device tries to initiate stream number and host does not accept it. Stream support is class-dependent. This interrupt can be masked by the corresponding bit in STREAMREN register. Writing '1' to this bit clears the interrupt. */
        uint32_t MD_EXIT     :1;                 /* EXIT from MOVE DATA State (used only for stream transfers in SS mode) This bit is set to '1' if stream capable endpoint exits from MOVE DATA state of Bulk IN/OUT Stream Ptrotocol State Machine (ISPSM/OSPSM). Stream support is class-dependent. This interrupt can be masked by the corresponding bit in MD_EXITEN register. Writing '1' to this bit clears the interrupt. */
        uint32_t TRBERR      :1;                 /* TRB error. This bit is set if DMA read corrupted TRB (wrong C bit value or TRB type). Address of the TRB is stored in the EP_TRADDR register. This interrupt can be masked by the corresponding bit in EP_STS_EN register. If this error occurs, the bit DRDY is cleared and held in the low state until the TRBERR is not cleared. To start the DMA again, the software has to clear this interrupt and set the DRDY bit once more. Writing '1' to this bit clears the interrupt. */
        uint32_t NRDY        :1;                 /* Not ready (used only in SS mode). This bit is automatically set to 1 when for some reason endpoint enters Flow Control. If ERDY is sent automatically by the endpoint (what is done when current TDL value is greater then zero), this interrupt bit is not automatically cleared (although the endpoint itself leaves FlowControl). Note: For BULK OUT endpoints with TDL_CHK bit seting this interrupt should be used instead of DESCMIS interrupt. See also DESCMIS description. Writing '1' to this bit clears the interrupt. */
        uint32_t DBUSY       :1;                 /* DMA busy. This bit is set to '1' while the DMA services the endpoint. Through the service means either actual transmission of data between on-chip cache and system memory for particular endpoint or a pending data transmission which has already begun but was interrupted by endpoint with a higher priority. Such pending transmissions will begin automatically themselves after these higher priority. This bit is only a status bit (not an interrupt flag). */
        uint32_t BUFFEMPTY   :1;                 /* Endpoint Buffer Empty. When this bit is set to '1', there are no packets for the particular endpoint in the on-chip buffers. This bit is only a status bit (not an interrupt flag). */
        uint32_t CCS         :1;                 /* Current Cycle Status. Informs about current value of C bit corresponding to DMA ownership of TRBs for selected endpoint. For more information about TRBs C bit see chapter 2.11.3. This bit is only a status bit (not an interrupt flag). */
        uint32_t PRIME       :1;                 /* Prime (used only in SS mode). This bit is set when the device receives the packet with PRIME ID. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
        uint32_t SIDERR      :1;                 /* Stream error (used only in SS mode) If host requested IN (sent OUT) packet with particular Stream ID, and device is actually programmed to transfer packets with different Stream ID (SID written in the EP_CMD.ERDY_SID field) the host IN request (OUT packet) is rejected (NRDY) and the SIDERR interrupt is requested. In case of IN direction, the SIDERR interrupt will not be requested when device is not prepared for any transfer (EP_CMD.TDL= 0 for this endpoint). In this case (and additionally when EP_CMD.DRDY= 0 and EP_STS.DBUSY=0), the DESCMIS interrupt will be requested. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
        uint32_t OUTSMM      :1;                 /* OUT size mismatch. This bit is set when host sends a different data size than device was anticipating (according to Data Length field in TRB). In such a case, the DMA updates length field in current TRB, updates TRADDR (next TRB address), and triggers the interrupt. DMA will not start processing TRB ring of this EP until its DRDY is set. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
        uint32_t ISOERR      :1;                 /* ISO transmission error. Error of isochronous transmission. This bit is set during data transmission to/from ISO endpoints while the last data transfer at PIPE IF is in current micro frame. For ISO IN endpoints: If host asks for data packet and device is not ready for sent data immediatelly, then ISOERR flag is set for particular endpoint and core sends a 0-length DATA packet to the host. The next data portion transfer (for the next micro frame) from system memory to on-chip buffers is automatically started (when EP_CMD.DRDY bit is set or DMA works in DMULT mode). For ISO OUT endpoints: When host issues an OUT data packet for the specific endpoint but the OUT buffers are full, then device is unable to receive data packet and the ISOERR flag is set. For more information about ISO trasfer see chapter 'Isochronous Transfers'. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
        uint32_t HOSTPP      :1;                 /* Host Packet Pending (only for SS mode). Depending on whether the endpoint is enabled for streams or not, this bit behaves as follows: 1)For stream enabled bulk endpoints (EP_CFG.EPSTREAM_EN bit set): This bit reflects the PP bit in the last packet received from the host during Move Data state of the DOSPSM for the OUT endpoint. This bit is updated on exit from the MOVE DATA state of the DOSPSM and can be analyzed during servicing MD_EXIT interrupt for BULK OUT endpoint with Stream support enabled. If this bit is set to '0' during MD_EXIT interrupt, it means that the host terminated current stream. If this bit is set to '1' during MD_EXIT interrupt, it means that the host doesn't terminated current stream and still has data for this stream. 2)Non stream bulk endpoints (EP_CFG.EPSTREAM_EN bit not set): This bit reflects the PP bit in the packets received from the host. This bit is updated as long as the EP_CMD.TDL is nonzero and it can be analyzed during servicing IOT interrupt for BULK endpoints. This bit is only a status bit (not an interrupt flag). */
        uint32_t SPSMST      :2;                 /* Stream Protocol State Machine State (only for Bulk stream endpoints) This field is valid only for stream capable bulk endpoints and reflects the current state of the Stream Protocol State Machine for selected endpoint: 0 - DISABLED 1 - IDLE 2 - START_STREAM 3 - MOVE_DATA Soft should check if the SPSM is in IDLE state before sending ERDY TP from stream EP (leading to the transition from IDE to START_STREAM) Before software will order to send an ERDY TP from stream capable endpoint (leading to the transition from IDLE to START_STREAM) it should first check if the SPSM is in IDLE state. This bit is only a status bit (not an interrupt flag). */
        uint32_t IOT         :1;                 /* Interrupt On Transfer complete. This interrupt is generated when the field EP_CMD.TDL is decremented to zero. It means that the device - does not expect to have more packets from the host (OUT EP) - does not want to send more packets (IN EP) More information can be found in the description of EP_CMD.TDL field. Writing '1' to this bit clears the interrupt. */
        uint32_t RESERVED0   :4;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t OUTQ_NO     :4;                 /* OUT queue endpoint number. This field shows the number of the endpoint to which the packet, received by the host, currently is waiting to be transmitted by the DMA from the on-chip buffers to the system memory. As there is one buffers queue for all Out Endpoints, this field is not endpoint related, and thus it can be read regardless of current value stored in the EP_SEL register. This bit is only a status bit (not an interrupt flag). */
        uint32_t OUTQ_VAL    :1;                 /* OUT queue valid flag. This field indicates whether the endpoint number of the OUT packet waiting for transmission by the DMA, is valid or not. In other words, whether the packet queue is not empty. As there is one buffers queue for all Out Endpoints, this field is not endpoint related, and thus it can be read regardless of current value stored in the EP_SEL register. 0 - queue of out packets is empty thus OUTQ_NO is not valid 1 - queue of out packets is not empty thus OUTQ_NO is valid This bit is only a status bit (not an interrupt flag). */
        uint32_t RESERVED1   :2;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t STPWAIT     :1;                 /* Bit used only for EP0. If setup packet is received correctly and stored in the on-chip buffer, this bit is set to 1 and interrupt is generated. Setup packet is applicable only to control transmissions (EP0). This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
    } B;
} IMX_USB3_USBSS_EP_STS_t;

/* Register EP_STS - Endpoint Status Register. */
#define IMX_USB3_USBSS_EP_STS_OFFSET 0x2002C
/* Field SETUP - Setup transfer complete. Bit used only for EP0. If setup type transmission has been completed and data from host has been received and copied to system memory, this bit is set to '1' and interrupt is generated. Setup packet is applicable only to control transmissions (EP0). This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_SETUP_SHIFT 0
#define IMX_USB3_USBSS_EP_STS_SETUP_MASK 0x1
#define IMX_USB3_USBSS_EP_STS_SETUP(v) (((v) << 0) & 0x1)
/* Field STALL - Endpoint STALL status 0 - endpoint is not stalled 1 - endpoint is stalled This bit is not treated as an interrupt (not reported in the EP__ISTS register). This bit is read-only. */
#define IMX_USB3_USBSS_EP_STS_STALL_SHIFT 1
#define IMX_USB3_USBSS_EP_STS_STALL_MASK 0x2
#define IMX_USB3_USBSS_EP_STS_STALL(v) (((v) << 0x1) & 0x2)
/* Field IOC - Interrupt On Complete When DMA transfer is completed and transfer descriptor is updated, then this bit is set to 1 and interrupt is generated. Enabling or disabling of this interrupt is realized by IOC bit in transfer descriptor. Additionally, this interrupt can be masked for a particular endpoint in EP__ISTS register. When in given transfer descriptor both interrupts (IOC and ISP interrupts) are enabled, then in the case of short packet, only one interrupt is generated - SP. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_IOC_SHIFT 2
#define IMX_USB3_USBSS_EP_STS_IOC_MASK 0x4
#define IMX_USB3_USBSS_EP_STS_IOC(v) (((v) << 0x2) & 0x4)
/* Field ISP - Interrupt on Short Packet. This bit is set to 1 and interrupt is generated when a transfer containing less data than MaxPacket for a given endpoint has been completed and transfer descriptor has been updated.Enabling or disabling of interrupt is realized by ISP bit in transfer descriptor. Additionally, this interrupt can be masked for a particular endpoint in EP__ISTS register. When in given transfer descriptor both interrupts are enabled (IOC and ISP), then in the case of short packet only one interrupt is generated - SP. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_ISP_SHIFT 3
#define IMX_USB3_USBSS_EP_STS_ISP_MASK 0x8
#define IMX_USB3_USBSS_EP_STS_ISP(v) (((v) << 0x3) & 0x8)
/* Field DESCMIS - Transfer descriptor missing. This bit is set to 1 and interrupt is generated when any of the following conditions are met: - device is requested to send data to host and none of Transfer Descriptor is prepared (IN transfer) - device receives OUT packet and cannot transmit it using DMA as Transfer Descriptor has not been prepared (DRDY was not set) for it (OUT transfer) Note1: This interrupt is not generated for ISO IN endpoints. For such endpoints the ISOERR interrupt should be used. Note2: DMA will not start operating on transfer descriptor array until the OUT packet is received (or host requests IN packet) and processor has not previously notified DMA (by writing to EP_CMD register of DRDY register). Note2: For BULK OUT endpoints with TDL_CHK bit set this interrupt will not by requested as device will not accept any packet from host when TRB is not prepared (and TDL is not written with non-zero value). In this case the NRDY interrupt should be used instead of DESMIS. Writing '1' to this bit or writing '1' to EP_CMD.DRDY bit of endpoints which generated interrupt will delete the interrupt. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_DESCMIS_SHIFT 4
#define IMX_USB3_USBSS_EP_STS_DESCMIS_MASK 0x10
#define IMX_USB3_USBSS_EP_STS_DESCMIS(v) (((v) << 0x4) & 0x10)
/* Field STREAMR - Stream Rejected (used only in SS mode). This bit is set to '1' if device tries to initiate stream number and host does not accept it. Stream support is class-dependent. This interrupt can be masked by the corresponding bit in STREAMREN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_STREAMR_SHIFT 5
#define IMX_USB3_USBSS_EP_STS_STREAMR_MASK 0x20
#define IMX_USB3_USBSS_EP_STS_STREAMR(v) (((v) << 0x5) & 0x20)
/* Field MD_EXIT - EXIT from MOVE DATA State (used only for stream transfers in SS mode) This bit is set to '1' if stream capable endpoint exits from MOVE DATA state of Bulk IN/OUT Stream Ptrotocol State Machine (ISPSM/OSPSM). Stream support is class-dependent. This interrupt can be masked by the corresponding bit in MD_EXITEN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_MD_EXIT_SHIFT 6
#define IMX_USB3_USBSS_EP_STS_MD_EXIT_MASK 0x40
#define IMX_USB3_USBSS_EP_STS_MD_EXIT(v) (((v) << 0x6) & 0x40)
/* Field TRBERR - TRB error. This bit is set if DMA read corrupted TRB (wrong C bit value or TRB type). Address of the TRB is stored in the EP_TRADDR register. This interrupt can be masked by the corresponding bit in EP_STS_EN register. If this error occurs, the bit DRDY is cleared and held in the low state until the TRBERR is not cleared. To start the DMA again, the software has to clear this interrupt and set the DRDY bit once more. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_TRBERR_SHIFT 7
#define IMX_USB3_USBSS_EP_STS_TRBERR_MASK 0x80
#define IMX_USB3_USBSS_EP_STS_TRBERR(v) (((v) << 0x7) & 0x80)
/* Field NRDY - Not ready (used only in SS mode). This bit is automatically set to 1 when for some reason endpoint enters Flow Control. If ERDY is sent automatically by the endpoint (what is done when current TDL value is greater then zero), this interrupt bit is not automatically cleared (although the endpoint itself leaves FlowControl). Note: For BULK OUT endpoints with TDL_CHK bit seting this interrupt should be used instead of DESCMIS interrupt. See also DESCMIS description. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_NRDY_SHIFT 8
#define IMX_USB3_USBSS_EP_STS_NRDY_MASK 0x100
#define IMX_USB3_USBSS_EP_STS_NRDY(v) (((v) << 0x8) & 0x100)
/* Field DBUSY - DMA busy. This bit is set to '1' while the DMA services the endpoint. Through the service means either actual transmission of data between on-chip cache and system memory for particular endpoint or a pending data transmission which has already begun but was interrupted by endpoint with a higher priority. Such pending transmissions will begin automatically themselves after these higher priority. This bit is only a status bit (not an interrupt flag). */
#define IMX_USB3_USBSS_EP_STS_DBUSY_SHIFT 9
#define IMX_USB3_USBSS_EP_STS_DBUSY_MASK 0x200
#define IMX_USB3_USBSS_EP_STS_DBUSY(v) (((v) << 0x9) & 0x200)
/* Field BUFFEMPTY - Endpoint Buffer Empty. When this bit is set to '1', there are no packets for the particular endpoint in the on-chip buffers. This bit is only a status bit (not an interrupt flag). */
#define IMX_USB3_USBSS_EP_STS_BUFFEMPTY_SHIFT 10
#define IMX_USB3_USBSS_EP_STS_BUFFEMPTY_MASK 0x400
#define IMX_USB3_USBSS_EP_STS_BUFFEMPTY(v) (((v) << 0xA) & 0x400)
/* Field CCS - Current Cycle Status. Informs about current value of C bit corresponding to DMA ownership of TRBs for selected endpoint. For more information about TRBs C bit see chapter 2.11.3. This bit is only a status bit (not an interrupt flag). */
#define IMX_USB3_USBSS_EP_STS_CCS_SHIFT 11
#define IMX_USB3_USBSS_EP_STS_CCS_MASK 0x800
#define IMX_USB3_USBSS_EP_STS_CCS(v) (((v) << 0xB) & 0x800)
/* Field PRIME - Prime (used only in SS mode). This bit is set when the device receives the packet with PRIME ID. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_PRIME_SHIFT 12
#define IMX_USB3_USBSS_EP_STS_PRIME_MASK 0x1000
#define IMX_USB3_USBSS_EP_STS_PRIME(v) (((v) << 0xC) & 0x1000)
/* Field SIDERR - Stream error (used only in SS mode) If host requested IN (sent OUT) packet with particular Stream ID, and device is actually programmed to transfer packets with different Stream ID (SID written in the EP_CMD.ERDY_SID field) the host IN request (OUT packet) is rejected (NRDY) and the SIDERR interrupt is requested. In case of IN direction, the SIDERR interrupt will not be requested when device is not prepared for any transfer (EP_CMD.TDL= 0 for this endpoint). In this case (and additionally when EP_CMD.DRDY= 0 and EP_STS.DBUSY=0), the DESCMIS interrupt will be requested. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_SIDERR_SHIFT 13
#define IMX_USB3_USBSS_EP_STS_SIDERR_MASK 0x2000
#define IMX_USB3_USBSS_EP_STS_SIDERR(v) (((v) << 0xD) & 0x2000)
/* Field OUTSMM - OUT size mismatch. This bit is set when host sends a different data size than device was anticipating (according to Data Length field in TRB). In such a case, the DMA updates length field in current TRB, updates TRADDR (next TRB address), and triggers the interrupt. DMA will not start processing TRB ring of this EP until its DRDY is set. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_OUTSMM_SHIFT 14
#define IMX_USB3_USBSS_EP_STS_OUTSMM_MASK 0x4000
#define IMX_USB3_USBSS_EP_STS_OUTSMM(v) (((v) << 0xE) & 0x4000)
/* Field ISOERR - ISO transmission error. Error of isochronous transmission. This bit is set during data transmission to/from ISO endpoints while the last data transfer at PIPE IF is in current micro frame. For ISO IN endpoints: If host asks for data packet and device is not ready for sent data immediatelly, then ISOERR flag is set for particular endpoint and core sends a 0-length DATA packet to the host. The next data portion transfer (for the next micro frame) from system memory to on-chip buffers is automatically started (when EP_CMD.DRDY bit is set or DMA works in DMULT mode). For ISO OUT endpoints: When host issues an OUT data packet for the specific endpoint but the OUT buffers are full, then device is unable to receive data packet and the ISOERR flag is set. For more information about ISO trasfer see chapter 'Isochronous Transfers'. This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_ISOERR_SHIFT 15
#define IMX_USB3_USBSS_EP_STS_ISOERR_MASK 0x8000
#define IMX_USB3_USBSS_EP_STS_ISOERR(v) (((v) << 0xF) & 0x8000)
/* Field HOSTPP - Host Packet Pending (only for SS mode). Depending on whether the endpoint is enabled for streams or not, this bit behaves as follows: 1)For stream enabled bulk endpoints (EP_CFG.EPSTREAM_EN bit set): This bit reflects the PP bit in the last packet received from the host during Move Data state of the DOSPSM for the OUT endpoint. This bit is updated on exit from the MOVE DATA state of the DOSPSM and can be analyzed during servicing MD_EXIT interrupt for BULK OUT endpoint with Stream support enabled. If this bit is set to '0' during MD_EXIT interrupt, it means that the host terminated current stream. If this bit is set to '1' during MD_EXIT interrupt, it means that the host doesn't terminated current stream and still has data for this stream. 2)Non stream bulk endpoints (EP_CFG.EPSTREAM_EN bit not set): This bit reflects the PP bit in the packets received from the host. This bit is updated as long as the EP_CMD.TDL is nonzero and it can be analyzed during servicing IOT interrupt for BULK endpoints. This bit is only a status bit (not an interrupt flag). */
#define IMX_USB3_USBSS_EP_STS_HOSTPP_SHIFT 16
#define IMX_USB3_USBSS_EP_STS_HOSTPP_MASK 0x10000
#define IMX_USB3_USBSS_EP_STS_HOSTPP(v) (((v) << 0x10) & 0x10000)
/* Field SPSMST - Stream Protocol State Machine State (only for Bulk stream endpoints) This field is valid only for stream capable bulk endpoints and reflects the current state of the Stream Protocol State Machine for selected endpoint: 0 - DISABLED 1 - IDLE 2 - START_STREAM 3 - MOVE_DATA Soft should check if the SPSM is in IDLE state before sending ERDY TP from stream EP (leading to the transition from IDE to START_STREAM) Before software will order to send an ERDY TP from stream capable endpoint (leading to the transition from IDLE to START_STREAM) it should first check if the SPSM is in IDLE state. This bit is only a status bit (not an interrupt flag). */
#define IMX_USB3_USBSS_EP_STS_SPSMST_SHIFT 17
#define IMX_USB3_USBSS_EP_STS_SPSMST_MASK 0x60000
#define IMX_USB3_USBSS_EP_STS_SPSMST(v) (((v) << 0x11) & 0x60000)
/* Field IOT - Interrupt On Transfer complete. This interrupt is generated when the field EP_CMD.TDL is decremented to zero. It means that the device - does not expect to have more packets from the host (OUT EP) - does not want to send more packets (IN EP) More information can be found in the description of EP_CMD.TDL field. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_IOT_SHIFT 19
#define IMX_USB3_USBSS_EP_STS_IOT_MASK 0x80000
#define IMX_USB3_USBSS_EP_STS_IOT(v) (((v) << 0x13) & 0x80000)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_STS_RESERVED0_SHIFT 20
#define IMX_USB3_USBSS_EP_STS_RESERVED0_MASK 0xF00000
#define IMX_USB3_USBSS_EP_STS_RESERVED0(v) (((v) << 0x14) & 0xF00000)
/* Field OUTQ_NO - OUT queue endpoint number. This field shows the number of the endpoint to which the packet, received by the host, currently is waiting to be transmitted by the DMA from the on-chip buffers to the system memory. As there is one buffers queue for all Out Endpoints, this field is not endpoint related, and thus it can be read regardless of current value stored in the EP_SEL register. This bit is only a status bit (not an interrupt flag). */
#define IMX_USB3_USBSS_EP_STS_OUTQ_NO_SHIFT 24
#define IMX_USB3_USBSS_EP_STS_OUTQ_NO_MASK 0xF000000
#define IMX_USB3_USBSS_EP_STS_OUTQ_NO(v) (((v) << 0x18) & 0xF000000)
/* Field OUTQ_VAL - OUT queue valid flag. This field indicates whether the endpoint number of the OUT packet waiting for transmission by the DMA, is valid or not. In other words, whether the packet queue is not empty. As there is one buffers queue for all Out Endpoints, this field is not endpoint related, and thus it can be read regardless of current value stored in the EP_SEL register. 0 - queue of out packets is empty thus OUTQ_NO is not valid 1 - queue of out packets is not empty thus OUTQ_NO is valid This bit is only a status bit (not an interrupt flag). */
#define IMX_USB3_USBSS_EP_STS_OUTQ_VAL_SHIFT 28
#define IMX_USB3_USBSS_EP_STS_OUTQ_VAL_MASK 0x10000000
#define IMX_USB3_USBSS_EP_STS_OUTQ_VAL(v) (((v) << 0x1C) & 0x10000000)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_STS_RESERVED1_SHIFT 29
#define IMX_USB3_USBSS_EP_STS_RESERVED1_MASK 0x60000000
#define IMX_USB3_USBSS_EP_STS_RESERVED1(v) (((v) << 0x1D) & 0x60000000)
/* Field STPWAIT - Bit used only for EP0. If setup packet is received correctly and stored in the on-chip buffer, this bit is set to 1 and interrupt is generated. Setup packet is applicable only to control transmissions (EP0). This interrupt can be masked by the corresponding bit in EP_STS_EN register. Writing '1' to this bit clears the interrupt. */
#define IMX_USB3_USBSS_EP_STS_STPWAIT_SHIFT 31
#define IMX_USB3_USBSS_EP_STS_STPWAIT_MASK 0x80000000
#define IMX_USB3_USBSS_EP_STS_STPWAIT(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_EP_STS_SID - Endpoint Status Register */
typedef union IMX_USB3_USBSS_EP_STS_SID_union_t {
    uint32_t R;
    struct {
        uint32_t SID         :16;                /* Stream ID (used only in SS mode). Stream ID of packet, which generates interrupt. The interrupts that update the SID field are: - SIDERR for EP OUT - SIDERR/DESCMIS for EP IN For the above interrupts, the values of the SID field reflects: - in case of SIDERR for EP OUT this field reflects the Stream ID of OUT packet sent by host which was rejected by the device, due to SID_CHK bit set - in case of SIDERR/DESCMIS for EP IN this field reflects the Stream ID of ACK TP sent by host which was rejected by the device. */
        uint32_t RESERVED    :16;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_EP_STS_SID_t;

/* Register EP_STS_SID - Endpoint Status Register */
#define IMX_USB3_USBSS_EP_STS_SID_OFFSET 0x20030
/* Field SID - Stream ID (used only in SS mode). Stream ID of packet, which generates interrupt. The interrupts that update the SID field are: - SIDERR for EP OUT - SIDERR/DESCMIS for EP IN For the above interrupts, the values of the SID field reflects: - in case of SIDERR for EP OUT this field reflects the Stream ID of OUT packet sent by host which was rejected by the device, due to SID_CHK bit set - in case of SIDERR/DESCMIS for EP IN this field reflects the Stream ID of ACK TP sent by host which was rejected by the device. */
#define IMX_USB3_USBSS_EP_STS_SID_SID_SHIFT 0
#define IMX_USB3_USBSS_EP_STS_SID_SID_MASK 0xFFFF
#define IMX_USB3_USBSS_EP_STS_SID_SID(v) (((v) << 0) & 0xFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_STS_SID_RESERVED_SHIFT 16
#define IMX_USB3_USBSS_EP_STS_SID_RESERVED_MASK 0xFFFF0000
#define IMX_USB3_USBSS_EP_STS_SID_RESERVED(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_EP_STS_EN - Endpoint Status Register Enable */
typedef union IMX_USB3_USBSS_EP_STS_EN_union_t {
    uint32_t R;
    struct {
        uint32_t SETUPEN     :1;                 /* Setup transfer complete. This bit enables the SETUP interrupt. Valid only for EP0. */
        uint32_t RESERVED0   :3;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t DESCMISEN   :1;                 /* OUT transfer missing descriptor enable. This bit enables the DESCMIS interrupt. */
        uint32_t STREAMREN   :1;                 /* Stream Rejected enable. This bit enables the STREAMR interrupt. */
        uint32_t MD_EXITEN   :1;                 /* Move Data Exit enable. This bit enables the MD_EXIT interrupt. */
        uint32_t TRBERREN    :1;                 /* TRB enable. This bit enables the TRBERR interrupt. */
        uint32_t NRDYEN      :1;                 /* NRDY enable. This bit enables the NRDY interrupt. */
        uint32_t RESERVED1   :3;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t PRIMEEN     :1;                 /* Prime enable. This bit enables the PRIME interrupt. */
        uint32_t SIDERREN    :1;                 /* Stream error enable. This bit enables the SIDERR interrupt. */
        uint32_t OUTSMMEN    :1;                 /* OUT size mismatch enable. This bit enables the OUTSMM interrupt. */
        uint32_t ISOERREN    :1;                 /* ISO transmission error enable. This bit enables the ISOERR interrupt. */
        uint32_t RESERVED2   :3;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t IOTEN       :1;                 /* Interrupt on Transmission complete enable. This bit enables the IOT interrupt. */
        uint32_t RESERVED3   :11;                /* Reserved field. Write ignored. 0 when read */
        uint32_t STPWAITEN   :1;                 /* Setup Wait interrupt enable. This bit enables the STPWAIT interrupt. Valid only for EP0 */
    } B;
} IMX_USB3_USBSS_EP_STS_EN_t;

/* Register EP_STS_EN - Endpoint Status Register Enable */
#define IMX_USB3_USBSS_EP_STS_EN_OFFSET 0x20034
/* Field SETUPEN - Setup transfer complete. This bit enables the SETUP interrupt. Valid only for EP0. */
#define IMX_USB3_USBSS_EP_STS_EN_SETUPEN_SHIFT 0
#define IMX_USB3_USBSS_EP_STS_EN_SETUPEN_MASK 0x1
#define IMX_USB3_USBSS_EP_STS_EN_SETUPEN(v) (((v) << 0) & 0x1)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED0_SHIFT 1
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED0_MASK 0xE
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED0(v) (((v) << 0x1) & 0xE)
/* Field DESCMISEN - OUT transfer missing descriptor enable. This bit enables the DESCMIS interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_DESCMISEN_SHIFT 4
#define IMX_USB3_USBSS_EP_STS_EN_DESCMISEN_MASK 0x10
#define IMX_USB3_USBSS_EP_STS_EN_DESCMISEN(v) (((v) << 0x4) & 0x10)
/* Field STREAMREN - Stream Rejected enable. This bit enables the STREAMR interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_STREAMREN_SHIFT 5
#define IMX_USB3_USBSS_EP_STS_EN_STREAMREN_MASK 0x20
#define IMX_USB3_USBSS_EP_STS_EN_STREAMREN(v) (((v) << 0x5) & 0x20)
/* Field MD_EXITEN - Move Data Exit enable. This bit enables the MD_EXIT interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_MD_EXITEN_SHIFT 6
#define IMX_USB3_USBSS_EP_STS_EN_MD_EXITEN_MASK 0x40
#define IMX_USB3_USBSS_EP_STS_EN_MD_EXITEN(v) (((v) << 0x6) & 0x40)
/* Field TRBERREN - TRB enable. This bit enables the TRBERR interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_TRBERREN_SHIFT 7
#define IMX_USB3_USBSS_EP_STS_EN_TRBERREN_MASK 0x80
#define IMX_USB3_USBSS_EP_STS_EN_TRBERREN(v) (((v) << 0x7) & 0x80)
/* Field NRDYEN - NRDY enable. This bit enables the NRDY interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_NRDYEN_SHIFT 8
#define IMX_USB3_USBSS_EP_STS_EN_NRDYEN_MASK 0x100
#define IMX_USB3_USBSS_EP_STS_EN_NRDYEN(v) (((v) << 0x8) & 0x100)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED1_SHIFT 9
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED1_MASK 0xE00
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED1(v) (((v) << 0x9) & 0xE00)
/* Field PRIMEEN - Prime enable. This bit enables the PRIME interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_PRIMEEN_SHIFT 12
#define IMX_USB3_USBSS_EP_STS_EN_PRIMEEN_MASK 0x1000
#define IMX_USB3_USBSS_EP_STS_EN_PRIMEEN(v) (((v) << 0xC) & 0x1000)
/* Field SIDERREN - Stream error enable. This bit enables the SIDERR interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_SIDERREN_SHIFT 13
#define IMX_USB3_USBSS_EP_STS_EN_SIDERREN_MASK 0x2000
#define IMX_USB3_USBSS_EP_STS_EN_SIDERREN(v) (((v) << 0xD) & 0x2000)
/* Field OUTSMMEN - OUT size mismatch enable. This bit enables the OUTSMM interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_OUTSMMEN_SHIFT 14
#define IMX_USB3_USBSS_EP_STS_EN_OUTSMMEN_MASK 0x4000
#define IMX_USB3_USBSS_EP_STS_EN_OUTSMMEN(v) (((v) << 0xE) & 0x4000)
/* Field ISOERREN - ISO transmission error enable. This bit enables the ISOERR interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_ISOERREN_SHIFT 15
#define IMX_USB3_USBSS_EP_STS_EN_ISOERREN_MASK 0x8000
#define IMX_USB3_USBSS_EP_STS_EN_ISOERREN(v) (((v) << 0xF) & 0x8000)
/* Field RESERVED2 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED2_SHIFT 16
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED2_MASK 0x70000
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED2(v) (((v) << 0x10) & 0x70000)
/* Field IOTEN - Interrupt on Transmission complete enable. This bit enables the IOT interrupt. */
#define IMX_USB3_USBSS_EP_STS_EN_IOTEN_SHIFT 19
#define IMX_USB3_USBSS_EP_STS_EN_IOTEN_MASK 0x80000
#define IMX_USB3_USBSS_EP_STS_EN_IOTEN(v) (((v) << 0x13) & 0x80000)
/* Field RESERVED3 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED3_SHIFT 20
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED3_MASK 0x7FF00000
#define IMX_USB3_USBSS_EP_STS_EN_RESERVED3(v) (((v) << 0x14) & 0x7FF00000)
/* Field STPWAITEN - Setup Wait interrupt enable. This bit enables the STPWAIT interrupt. Valid only for EP0 */
#define IMX_USB3_USBSS_EP_STS_EN_STPWAITEN_SHIFT 31
#define IMX_USB3_USBSS_EP_STS_EN_STPWAITEN_MASK 0x80000000
#define IMX_USB3_USBSS_EP_STS_EN_STPWAITEN(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_DRBL - Doorbell Register - used for initiating transfers with one access to USBSS-DEV, without use of the EP_SEL register(+EP_CMD. */
typedef union IMX_USB3_USBSS_DRBL_union_t {
    uint32_t R;
    struct {
        uint32_t DRBL0O      :1;                 /* DRBL0O */
        uint32_t DRBL1O      :1;                 /* DRBL1O */
        uint32_t DRBL2O      :1;                 /* DRBL2O */
        uint32_t DRBL3O      :1;                 /* DRBL3O */
        uint32_t DRBL4O      :1;                 /* DRBL4O */
        uint32_t DRBL5O      :1;                 /* DRBL5O */
        uint32_t DRBL6O      :1;                 /* DRBL6O */
        uint32_t DRBL7O      :1;                 /* DRBL7O */
        uint32_t RESERVED8   :1;                 /* reserved8 */
        uint32_t RESERVED9   :1;                 /* reserved9 */
        uint32_t RESERVED10  :1;                 /* reserved10 */
        uint32_t RESERVED11  :1;                 /* reserved11 */
        uint32_t RESERVED12  :1;                 /* reserved12 */
        uint32_t RESERVED13  :1;                 /* reserved13 */
        uint32_t RESERVED14  :1;                 /* reserved14 */
        uint32_t RESERVED15  :1;                 /* reserved15 */
        uint32_t DRBL0I      :1;                 /* DRBL0I */
        uint32_t DRBL1I      :1;                 /* DRBL1I */
        uint32_t DRBL2I      :1;                 /* DRBL2I */
        uint32_t DRBL3I      :1;                 /* DRBL3I */
        uint32_t DRBL4I      :1;                 /* DRBL4I */
        uint32_t DRBL5I      :1;                 /* DRBL5I */
        uint32_t DRBL6I      :1;                 /* DRBL6I */
        uint32_t DRBL7I      :1;                 /* DRBL7I */
        uint32_t RESERVED24  :1;                 /* reserved24 */
        uint32_t RESERVED25  :1;                 /* reserved25 */
        uint32_t RESERVED26  :1;                 /* reserved26 */
        uint32_t RESERVED27  :1;                 /* reserved27 */
        uint32_t RESERVED28  :1;                 /* reserved28 */
        uint32_t RESERVED29  :1;                 /* reserved29 */
        uint32_t RESERVED30  :1;                 /* reserved30 */
        uint32_t RESERVED31  :1;                 /* reserved31 */
    } B;
} IMX_USB3_USBSS_DRBL_t;

/* Register DRBL - Doorbell Register - used for initiating transfers with one access to USBSS-DEV, without use of the EP_SEL register(+EP_CMD. */
#define IMX_USB3_USBSS_DRBL_OFFSET 0x20038
/* Field DRBL0O - DRBL0O */
#define IMX_USB3_USBSS_DRBL_DRBL0O_SHIFT 0
#define IMX_USB3_USBSS_DRBL_DRBL0O_MASK 0x1
#define IMX_USB3_USBSS_DRBL_DRBL0O(v) (((v) << 0) & 0x1)
/* Field DRBL1O - DRBL1O */
#define IMX_USB3_USBSS_DRBL_DRBL1O_SHIFT 1
#define IMX_USB3_USBSS_DRBL_DRBL1O_MASK 0x2
#define IMX_USB3_USBSS_DRBL_DRBL1O(v) (((v) << 0x1) & 0x2)
/* Field DRBL2O - DRBL2O */
#define IMX_USB3_USBSS_DRBL_DRBL2O_SHIFT 2
#define IMX_USB3_USBSS_DRBL_DRBL2O_MASK 0x4
#define IMX_USB3_USBSS_DRBL_DRBL2O(v) (((v) << 0x2) & 0x4)
/* Field DRBL3O - DRBL3O */
#define IMX_USB3_USBSS_DRBL_DRBL3O_SHIFT 3
#define IMX_USB3_USBSS_DRBL_DRBL3O_MASK 0x8
#define IMX_USB3_USBSS_DRBL_DRBL3O(v) (((v) << 0x3) & 0x8)
/* Field DRBL4O - DRBL4O */
#define IMX_USB3_USBSS_DRBL_DRBL4O_SHIFT 4
#define IMX_USB3_USBSS_DRBL_DRBL4O_MASK 0x10
#define IMX_USB3_USBSS_DRBL_DRBL4O(v) (((v) << 0x4) & 0x10)
/* Field DRBL5O - DRBL5O */
#define IMX_USB3_USBSS_DRBL_DRBL5O_SHIFT 5
#define IMX_USB3_USBSS_DRBL_DRBL5O_MASK 0x20
#define IMX_USB3_USBSS_DRBL_DRBL5O(v) (((v) << 0x5) & 0x20)
/* Field DRBL6O - DRBL6O */
#define IMX_USB3_USBSS_DRBL_DRBL6O_SHIFT 6
#define IMX_USB3_USBSS_DRBL_DRBL6O_MASK 0x40
#define IMX_USB3_USBSS_DRBL_DRBL6O(v) (((v) << 0x6) & 0x40)
/* Field DRBL7O - DRBL7O */
#define IMX_USB3_USBSS_DRBL_DRBL7O_SHIFT 7
#define IMX_USB3_USBSS_DRBL_DRBL7O_MASK 0x80
#define IMX_USB3_USBSS_DRBL_DRBL7O(v) (((v) << 0x7) & 0x80)
/* Field RESERVED8 - reserved8 */
#define IMX_USB3_USBSS_DRBL_RESERVED8_SHIFT 8
#define IMX_USB3_USBSS_DRBL_RESERVED8_MASK 0x100
#define IMX_USB3_USBSS_DRBL_RESERVED8(v) (((v) << 0x8) & 0x100)
/* Field RESERVED9 - reserved9 */
#define IMX_USB3_USBSS_DRBL_RESERVED9_SHIFT 9
#define IMX_USB3_USBSS_DRBL_RESERVED9_MASK 0x200
#define IMX_USB3_USBSS_DRBL_RESERVED9(v) (((v) << 0x9) & 0x200)
/* Field RESERVED10 - reserved10 */
#define IMX_USB3_USBSS_DRBL_RESERVED10_SHIFT 10
#define IMX_USB3_USBSS_DRBL_RESERVED10_MASK 0x400
#define IMX_USB3_USBSS_DRBL_RESERVED10(v) (((v) << 0xA) & 0x400)
/* Field RESERVED11 - reserved11 */
#define IMX_USB3_USBSS_DRBL_RESERVED11_SHIFT 11
#define IMX_USB3_USBSS_DRBL_RESERVED11_MASK 0x800
#define IMX_USB3_USBSS_DRBL_RESERVED11(v) (((v) << 0xB) & 0x800)
/* Field RESERVED12 - reserved12 */
#define IMX_USB3_USBSS_DRBL_RESERVED12_SHIFT 12
#define IMX_USB3_USBSS_DRBL_RESERVED12_MASK 0x1000
#define IMX_USB3_USBSS_DRBL_RESERVED12(v) (((v) << 0xC) & 0x1000)
/* Field RESERVED13 - reserved13 */
#define IMX_USB3_USBSS_DRBL_RESERVED13_SHIFT 13
#define IMX_USB3_USBSS_DRBL_RESERVED13_MASK 0x2000
#define IMX_USB3_USBSS_DRBL_RESERVED13(v) (((v) << 0xD) & 0x2000)
/* Field RESERVED14 - reserved14 */
#define IMX_USB3_USBSS_DRBL_RESERVED14_SHIFT 14
#define IMX_USB3_USBSS_DRBL_RESERVED14_MASK 0x4000
#define IMX_USB3_USBSS_DRBL_RESERVED14(v) (((v) << 0xE) & 0x4000)
/* Field RESERVED15 - reserved15 */
#define IMX_USB3_USBSS_DRBL_RESERVED15_SHIFT 15
#define IMX_USB3_USBSS_DRBL_RESERVED15_MASK 0x8000
#define IMX_USB3_USBSS_DRBL_RESERVED15(v) (((v) << 0xF) & 0x8000)
/* Field DRBL0I - DRBL0I */
#define IMX_USB3_USBSS_DRBL_DRBL0I_SHIFT 16
#define IMX_USB3_USBSS_DRBL_DRBL0I_MASK 0x10000
#define IMX_USB3_USBSS_DRBL_DRBL0I(v) (((v) << 0x10) & 0x10000)
/* Field DRBL1I - DRBL1I */
#define IMX_USB3_USBSS_DRBL_DRBL1I_SHIFT 17
#define IMX_USB3_USBSS_DRBL_DRBL1I_MASK 0x20000
#define IMX_USB3_USBSS_DRBL_DRBL1I(v) (((v) << 0x11) & 0x20000)
/* Field DRBL2I - DRBL2I */
#define IMX_USB3_USBSS_DRBL_DRBL2I_SHIFT 18
#define IMX_USB3_USBSS_DRBL_DRBL2I_MASK 0x40000
#define IMX_USB3_USBSS_DRBL_DRBL2I(v) (((v) << 0x12) & 0x40000)
/* Field DRBL3I - DRBL3I */
#define IMX_USB3_USBSS_DRBL_DRBL3I_SHIFT 19
#define IMX_USB3_USBSS_DRBL_DRBL3I_MASK 0x80000
#define IMX_USB3_USBSS_DRBL_DRBL3I(v) (((v) << 0x13) & 0x80000)
/* Field DRBL4I - DRBL4I */
#define IMX_USB3_USBSS_DRBL_DRBL4I_SHIFT 20
#define IMX_USB3_USBSS_DRBL_DRBL4I_MASK 0x100000
#define IMX_USB3_USBSS_DRBL_DRBL4I(v) (((v) << 0x14) & 0x100000)
/* Field DRBL5I - DRBL5I */
#define IMX_USB3_USBSS_DRBL_DRBL5I_SHIFT 21
#define IMX_USB3_USBSS_DRBL_DRBL5I_MASK 0x200000
#define IMX_USB3_USBSS_DRBL_DRBL5I(v) (((v) << 0x15) & 0x200000)
/* Field DRBL6I - DRBL6I */
#define IMX_USB3_USBSS_DRBL_DRBL6I_SHIFT 22
#define IMX_USB3_USBSS_DRBL_DRBL6I_MASK 0x400000
#define IMX_USB3_USBSS_DRBL_DRBL6I(v) (((v) << 0x16) & 0x400000)
/* Field DRBL7I - DRBL7I */
#define IMX_USB3_USBSS_DRBL_DRBL7I_SHIFT 23
#define IMX_USB3_USBSS_DRBL_DRBL7I_MASK 0x800000
#define IMX_USB3_USBSS_DRBL_DRBL7I(v) (((v) << 0x17) & 0x800000)
/* Field RESERVED24 - reserved24 */
#define IMX_USB3_USBSS_DRBL_RESERVED24_SHIFT 24
#define IMX_USB3_USBSS_DRBL_RESERVED24_MASK 0x1000000
#define IMX_USB3_USBSS_DRBL_RESERVED24(v) (((v) << 0x18) & 0x1000000)
/* Field RESERVED25 - reserved25 */
#define IMX_USB3_USBSS_DRBL_RESERVED25_SHIFT 25
#define IMX_USB3_USBSS_DRBL_RESERVED25_MASK 0x2000000
#define IMX_USB3_USBSS_DRBL_RESERVED25(v) (((v) << 0x19) & 0x2000000)
/* Field RESERVED26 - reserved26 */
#define IMX_USB3_USBSS_DRBL_RESERVED26_SHIFT 26
#define IMX_USB3_USBSS_DRBL_RESERVED26_MASK 0x4000000
#define IMX_USB3_USBSS_DRBL_RESERVED26(v) (((v) << 0x1A) & 0x4000000)
/* Field RESERVED27 - reserved27 */
#define IMX_USB3_USBSS_DRBL_RESERVED27_SHIFT 27
#define IMX_USB3_USBSS_DRBL_RESERVED27_MASK 0x8000000
#define IMX_USB3_USBSS_DRBL_RESERVED27(v) (((v) << 0x1B) & 0x8000000)
/* Field RESERVED28 - reserved28 */
#define IMX_USB3_USBSS_DRBL_RESERVED28_SHIFT 28
#define IMX_USB3_USBSS_DRBL_RESERVED28_MASK 0x10000000
#define IMX_USB3_USBSS_DRBL_RESERVED28(v) (((v) << 0x1C) & 0x10000000)
/* Field RESERVED29 - reserved29 */
#define IMX_USB3_USBSS_DRBL_RESERVED29_SHIFT 29
#define IMX_USB3_USBSS_DRBL_RESERVED29_MASK 0x20000000
#define IMX_USB3_USBSS_DRBL_RESERVED29(v) (((v) << 0x1D) & 0x20000000)
/* Field RESERVED30 - reserved30 */
#define IMX_USB3_USBSS_DRBL_RESERVED30_SHIFT 30
#define IMX_USB3_USBSS_DRBL_RESERVED30_MASK 0x40000000
#define IMX_USB3_USBSS_DRBL_RESERVED30(v) (((v) << 0x1E) & 0x40000000)
/* Field RESERVED31 - reserved31 */
#define IMX_USB3_USBSS_DRBL_RESERVED31_SHIFT 31
#define IMX_USB3_USBSS_DRBL_RESERVED31_MASK 0x80000000
#define IMX_USB3_USBSS_DRBL_RESERVED31(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_EP_IEN - Endpoints Interrupt Enable Register (1 - enables interrupt, 0 - disables interrupt) */
typedef union IMX_USB3_USBSS_EP_IEN_union_t {
    uint32_t R;
    struct {
        uint32_t EOUTEN0     :1;                 /* EOUTEN0 */
        uint32_t EOUTEN1     :1;                 /* EOUTEN1 */
        uint32_t EOUTEN2     :1;                 /* EOUTEN2 */
        uint32_t EOUTEN3     :1;                 /* EOUTEN3 */
        uint32_t EOUTEN4     :1;                 /* EOUTEN4 */
        uint32_t EOUTEN5     :1;                 /* EOUTEN5 */
        uint32_t EOUTEN6     :1;                 /* EOUTEN6 */
        uint32_t EOUTEN7     :1;                 /* EOUTEN7 */
        uint32_t RESERVED8   :1;                 /* reserved8 */
        uint32_t RESERVED9   :1;                 /* reserved9 */
        uint32_t RESERVED10  :1;                 /* reserved10 */
        uint32_t RESERVED11  :1;                 /* reserved11 */
        uint32_t RESERVED12  :1;                 /* reserved12 */
        uint32_t RESERVED13  :1;                 /* reserved13 */
        uint32_t RESERVED14  :1;                 /* reserved14 */
        uint32_t RESERVED15  :1;                 /* reserved15 */
        uint32_t EINEN0      :1;                 /* EINEN0 */
        uint32_t EINEN1      :1;                 /* EINEN1 */
        uint32_t EINEN2      :1;                 /* EINEN2 */
        uint32_t EINEN3      :1;                 /* EINEN3 */
        uint32_t EINEN4      :1;                 /* EINEN4 */
        uint32_t EINEN5      :1;                 /* EINEN5 */
        uint32_t EINEN6      :1;                 /* EINEN6 */
        uint32_t EINEN7      :1;                 /* EINEN7 */
        uint32_t RESERVED24  :1;                 /* reserved24 */
        uint32_t RESERVED25  :1;                 /* reserved25 */
        uint32_t RESERVED26  :1;                 /* reserved26 */
        uint32_t RESERVED27  :1;                 /* reserved27 */
        uint32_t RESERVED28  :1;                 /* reserved28 */
        uint32_t RESERVED29  :1;                 /* reserved29 */
        uint32_t RESERVED30  :1;                 /* reserved30 */
        uint32_t RESERVED31  :1;                 /* reserved31 */
    } B;
} IMX_USB3_USBSS_EP_IEN_t;

/* Register EP_IEN - Endpoints Interrupt Enable Register (1 - enables interrupt, 0 - disables interrupt) */
#define IMX_USB3_USBSS_EP_IEN_OFFSET 0x2003C
/* Field EOUTEN0 - EOUTEN0 */
#define IMX_USB3_USBSS_EP_IEN_EOUTEN0_SHIFT 0
#define IMX_USB3_USBSS_EP_IEN_EOUTEN0_MASK 0x1
#define IMX_USB3_USBSS_EP_IEN_EOUTEN0(v) (((v) << 0) & 0x1)
/* Field EOUTEN1 - EOUTEN1 */
#define IMX_USB3_USBSS_EP_IEN_EOUTEN1_SHIFT 1
#define IMX_USB3_USBSS_EP_IEN_EOUTEN1_MASK 0x2
#define IMX_USB3_USBSS_EP_IEN_EOUTEN1(v) (((v) << 0x1) & 0x2)
/* Field EOUTEN2 - EOUTEN2 */
#define IMX_USB3_USBSS_EP_IEN_EOUTEN2_SHIFT 2
#define IMX_USB3_USBSS_EP_IEN_EOUTEN2_MASK 0x4
#define IMX_USB3_USBSS_EP_IEN_EOUTEN2(v) (((v) << 0x2) & 0x4)
/* Field EOUTEN3 - EOUTEN3 */
#define IMX_USB3_USBSS_EP_IEN_EOUTEN3_SHIFT 3
#define IMX_USB3_USBSS_EP_IEN_EOUTEN3_MASK 0x8
#define IMX_USB3_USBSS_EP_IEN_EOUTEN3(v) (((v) << 0x3) & 0x8)
/* Field EOUTEN4 - EOUTEN4 */
#define IMX_USB3_USBSS_EP_IEN_EOUTEN4_SHIFT 4
#define IMX_USB3_USBSS_EP_IEN_EOUTEN4_MASK 0x10
#define IMX_USB3_USBSS_EP_IEN_EOUTEN4(v) (((v) << 0x4) & 0x10)
/* Field EOUTEN5 - EOUTEN5 */
#define IMX_USB3_USBSS_EP_IEN_EOUTEN5_SHIFT 5
#define IMX_USB3_USBSS_EP_IEN_EOUTEN5_MASK 0x20
#define IMX_USB3_USBSS_EP_IEN_EOUTEN5(v) (((v) << 0x5) & 0x20)
/* Field EOUTEN6 - EOUTEN6 */
#define IMX_USB3_USBSS_EP_IEN_EOUTEN6_SHIFT 6
#define IMX_USB3_USBSS_EP_IEN_EOUTEN6_MASK 0x40
#define IMX_USB3_USBSS_EP_IEN_EOUTEN6(v) (((v) << 0x6) & 0x40)
/* Field EOUTEN7 - EOUTEN7 */
#define IMX_USB3_USBSS_EP_IEN_EOUTEN7_SHIFT 7
#define IMX_USB3_USBSS_EP_IEN_EOUTEN7_MASK 0x80
#define IMX_USB3_USBSS_EP_IEN_EOUTEN7(v) (((v) << 0x7) & 0x80)
/* Field RESERVED8 - reserved8 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED8_SHIFT 8
#define IMX_USB3_USBSS_EP_IEN_RESERVED8_MASK 0x100
#define IMX_USB3_USBSS_EP_IEN_RESERVED8(v) (((v) << 0x8) & 0x100)
/* Field RESERVED9 - reserved9 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED9_SHIFT 9
#define IMX_USB3_USBSS_EP_IEN_RESERVED9_MASK 0x200
#define IMX_USB3_USBSS_EP_IEN_RESERVED9(v) (((v) << 0x9) & 0x200)
/* Field RESERVED10 - reserved10 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED10_SHIFT 10
#define IMX_USB3_USBSS_EP_IEN_RESERVED10_MASK 0x400
#define IMX_USB3_USBSS_EP_IEN_RESERVED10(v) (((v) << 0xA) & 0x400)
/* Field RESERVED11 - reserved11 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED11_SHIFT 11
#define IMX_USB3_USBSS_EP_IEN_RESERVED11_MASK 0x800
#define IMX_USB3_USBSS_EP_IEN_RESERVED11(v) (((v) << 0xB) & 0x800)
/* Field RESERVED12 - reserved12 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED12_SHIFT 12
#define IMX_USB3_USBSS_EP_IEN_RESERVED12_MASK 0x1000
#define IMX_USB3_USBSS_EP_IEN_RESERVED12(v) (((v) << 0xC) & 0x1000)
/* Field RESERVED13 - reserved13 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED13_SHIFT 13
#define IMX_USB3_USBSS_EP_IEN_RESERVED13_MASK 0x2000
#define IMX_USB3_USBSS_EP_IEN_RESERVED13(v) (((v) << 0xD) & 0x2000)
/* Field RESERVED14 - reserved14 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED14_SHIFT 14
#define IMX_USB3_USBSS_EP_IEN_RESERVED14_MASK 0x4000
#define IMX_USB3_USBSS_EP_IEN_RESERVED14(v) (((v) << 0xE) & 0x4000)
/* Field RESERVED15 - reserved15 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED15_SHIFT 15
#define IMX_USB3_USBSS_EP_IEN_RESERVED15_MASK 0x8000
#define IMX_USB3_USBSS_EP_IEN_RESERVED15(v) (((v) << 0xF) & 0x8000)
/* Field EINEN0 - EINEN0 */
#define IMX_USB3_USBSS_EP_IEN_EINEN0_SHIFT 16
#define IMX_USB3_USBSS_EP_IEN_EINEN0_MASK 0x10000
#define IMX_USB3_USBSS_EP_IEN_EINEN0(v) (((v) << 0x10) & 0x10000)
/* Field EINEN1 - EINEN1 */
#define IMX_USB3_USBSS_EP_IEN_EINEN1_SHIFT 17
#define IMX_USB3_USBSS_EP_IEN_EINEN1_MASK 0x20000
#define IMX_USB3_USBSS_EP_IEN_EINEN1(v) (((v) << 0x11) & 0x20000)
/* Field EINEN2 - EINEN2 */
#define IMX_USB3_USBSS_EP_IEN_EINEN2_SHIFT 18
#define IMX_USB3_USBSS_EP_IEN_EINEN2_MASK 0x40000
#define IMX_USB3_USBSS_EP_IEN_EINEN2(v) (((v) << 0x12) & 0x40000)
/* Field EINEN3 - EINEN3 */
#define IMX_USB3_USBSS_EP_IEN_EINEN3_SHIFT 19
#define IMX_USB3_USBSS_EP_IEN_EINEN3_MASK 0x80000
#define IMX_USB3_USBSS_EP_IEN_EINEN3(v) (((v) << 0x13) & 0x80000)
/* Field EINEN4 - EINEN4 */
#define IMX_USB3_USBSS_EP_IEN_EINEN4_SHIFT 20
#define IMX_USB3_USBSS_EP_IEN_EINEN4_MASK 0x100000
#define IMX_USB3_USBSS_EP_IEN_EINEN4(v) (((v) << 0x14) & 0x100000)
/* Field EINEN5 - EINEN5 */
#define IMX_USB3_USBSS_EP_IEN_EINEN5_SHIFT 21
#define IMX_USB3_USBSS_EP_IEN_EINEN5_MASK 0x200000
#define IMX_USB3_USBSS_EP_IEN_EINEN5(v) (((v) << 0x15) & 0x200000)
/* Field EINEN6 - EINEN6 */
#define IMX_USB3_USBSS_EP_IEN_EINEN6_SHIFT 22
#define IMX_USB3_USBSS_EP_IEN_EINEN6_MASK 0x400000
#define IMX_USB3_USBSS_EP_IEN_EINEN6(v) (((v) << 0x16) & 0x400000)
/* Field EINEN7 - EINEN7 */
#define IMX_USB3_USBSS_EP_IEN_EINEN7_SHIFT 23
#define IMX_USB3_USBSS_EP_IEN_EINEN7_MASK 0x800000
#define IMX_USB3_USBSS_EP_IEN_EINEN7(v) (((v) << 0x17) & 0x800000)
/* Field RESERVED24 - reserved24 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED24_SHIFT 24
#define IMX_USB3_USBSS_EP_IEN_RESERVED24_MASK 0x1000000
#define IMX_USB3_USBSS_EP_IEN_RESERVED24(v) (((v) << 0x18) & 0x1000000)
/* Field RESERVED25 - reserved25 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED25_SHIFT 25
#define IMX_USB3_USBSS_EP_IEN_RESERVED25_MASK 0x2000000
#define IMX_USB3_USBSS_EP_IEN_RESERVED25(v) (((v) << 0x19) & 0x2000000)
/* Field RESERVED26 - reserved26 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED26_SHIFT 26
#define IMX_USB3_USBSS_EP_IEN_RESERVED26_MASK 0x4000000
#define IMX_USB3_USBSS_EP_IEN_RESERVED26(v) (((v) << 0x1A) & 0x4000000)
/* Field RESERVED27 - reserved27 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED27_SHIFT 27
#define IMX_USB3_USBSS_EP_IEN_RESERVED27_MASK 0x8000000
#define IMX_USB3_USBSS_EP_IEN_RESERVED27(v) (((v) << 0x1B) & 0x8000000)
/* Field RESERVED28 - reserved28 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED28_SHIFT 28
#define IMX_USB3_USBSS_EP_IEN_RESERVED28_MASK 0x10000000
#define IMX_USB3_USBSS_EP_IEN_RESERVED28(v) (((v) << 0x1C) & 0x10000000)
/* Field RESERVED29 - reserved29 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED29_SHIFT 29
#define IMX_USB3_USBSS_EP_IEN_RESERVED29_MASK 0x20000000
#define IMX_USB3_USBSS_EP_IEN_RESERVED29(v) (((v) << 0x1D) & 0x20000000)
/* Field RESERVED30 - reserved30 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED30_SHIFT 30
#define IMX_USB3_USBSS_EP_IEN_RESERVED30_MASK 0x40000000
#define IMX_USB3_USBSS_EP_IEN_RESERVED30(v) (((v) << 0x1E) & 0x40000000)
/* Field RESERVED31 - reserved31 */
#define IMX_USB3_USBSS_EP_IEN_RESERVED31_SHIFT 31
#define IMX_USB3_USBSS_EP_IEN_RESERVED31_MASK 0x80000000
#define IMX_USB3_USBSS_EP_IEN_RESERVED31(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_EP_ISTS - Endpoints Interrupt Status Register. */
typedef union IMX_USB3_USBSS_EP_ISTS_union_t {
    uint32_t R;
    struct {
        uint32_t EOUT0       :1;                 /* EOUT0 */
        uint32_t EOUT1       :1;                 /* EOUT1 */
        uint32_t EOUT2       :1;                 /* EOUT2 */
        uint32_t EOUT3       :1;                 /* EOUT3 */
        uint32_t EOUT4       :1;                 /* EOUT4 */
        uint32_t EOUT5       :1;                 /* EOUT5 */
        uint32_t EOUT6       :1;                 /* EOUT6 */
        uint32_t EOUT7       :1;                 /* EOUT7 */
        uint32_t RESERVED8   :1;                 /* reserved8 */
        uint32_t RESERVED9   :1;                 /* reserved9 */
        uint32_t RESERVED10  :1;                 /* reserved10 */
        uint32_t RESERVED11  :1;                 /* reserved11 */
        uint32_t RESERVED12  :1;                 /* reserved12 */
        uint32_t RESERVED13  :1;                 /* reserved13 */
        uint32_t RESERVED14  :1;                 /* reserved14 */
        uint32_t RESERVED15  :1;                 /* reserved15 */
        uint32_t EIN0        :1;                 /* EIN0 */
        uint32_t EIN1        :1;                 /* EIN1 */
        uint32_t EIN2        :1;                 /* EIN2 */
        uint32_t EIN3        :1;                 /* EIN3 */
        uint32_t EIN4        :1;                 /* EIN4 */
        uint32_t EIN5        :1;                 /* EIN5 */
        uint32_t EIN6        :1;                 /* EIN6 */
        uint32_t EIN7        :1;                 /* EIN7 */
        uint32_t RESERVED24  :1;                 /* reserved24 */
        uint32_t RESERVED25  :1;                 /* reserved25 */
        uint32_t RESERVED26  :1;                 /* reserved26 */
        uint32_t RESERVED27  :1;                 /* reserved27 */
        uint32_t RESERVED28  :1;                 /* reserved28 */
        uint32_t RESERVED29  :1;                 /* reserved29 */
        uint32_t RESERVED30  :1;                 /* reserved30 */
        uint32_t RESERVED31  :1;                 /* reserved31 */
    } B;
} IMX_USB3_USBSS_EP_ISTS_t;

/* Register EP_ISTS - Endpoints Interrupt Status Register. */
#define IMX_USB3_USBSS_EP_ISTS_OFFSET 0x20040
/* Field EOUT0 - EOUT0 */
#define IMX_USB3_USBSS_EP_ISTS_EOUT0_SHIFT 0
#define IMX_USB3_USBSS_EP_ISTS_EOUT0_MASK 0x1
#define IMX_USB3_USBSS_EP_ISTS_EOUT0(v) (((v) << 0) & 0x1)
/* Field EOUT1 - EOUT1 */
#define IMX_USB3_USBSS_EP_ISTS_EOUT1_SHIFT 1
#define IMX_USB3_USBSS_EP_ISTS_EOUT1_MASK 0x2
#define IMX_USB3_USBSS_EP_ISTS_EOUT1(v) (((v) << 0x1) & 0x2)
/* Field EOUT2 - EOUT2 */
#define IMX_USB3_USBSS_EP_ISTS_EOUT2_SHIFT 2
#define IMX_USB3_USBSS_EP_ISTS_EOUT2_MASK 0x4
#define IMX_USB3_USBSS_EP_ISTS_EOUT2(v) (((v) << 0x2) & 0x4)
/* Field EOUT3 - EOUT3 */
#define IMX_USB3_USBSS_EP_ISTS_EOUT3_SHIFT 3
#define IMX_USB3_USBSS_EP_ISTS_EOUT3_MASK 0x8
#define IMX_USB3_USBSS_EP_ISTS_EOUT3(v) (((v) << 0x3) & 0x8)
/* Field EOUT4 - EOUT4 */
#define IMX_USB3_USBSS_EP_ISTS_EOUT4_SHIFT 4
#define IMX_USB3_USBSS_EP_ISTS_EOUT4_MASK 0x10
#define IMX_USB3_USBSS_EP_ISTS_EOUT4(v) (((v) << 0x4) & 0x10)
/* Field EOUT5 - EOUT5 */
#define IMX_USB3_USBSS_EP_ISTS_EOUT5_SHIFT 5
#define IMX_USB3_USBSS_EP_ISTS_EOUT5_MASK 0x20
#define IMX_USB3_USBSS_EP_ISTS_EOUT5(v) (((v) << 0x5) & 0x20)
/* Field EOUT6 - EOUT6 */
#define IMX_USB3_USBSS_EP_ISTS_EOUT6_SHIFT 6
#define IMX_USB3_USBSS_EP_ISTS_EOUT6_MASK 0x40
#define IMX_USB3_USBSS_EP_ISTS_EOUT6(v) (((v) << 0x6) & 0x40)
/* Field EOUT7 - EOUT7 */
#define IMX_USB3_USBSS_EP_ISTS_EOUT7_SHIFT 7
#define IMX_USB3_USBSS_EP_ISTS_EOUT7_MASK 0x80
#define IMX_USB3_USBSS_EP_ISTS_EOUT7(v) (((v) << 0x7) & 0x80)
/* Field RESERVED8 - reserved8 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED8_SHIFT 8
#define IMX_USB3_USBSS_EP_ISTS_RESERVED8_MASK 0x100
#define IMX_USB3_USBSS_EP_ISTS_RESERVED8(v) (((v) << 0x8) & 0x100)
/* Field RESERVED9 - reserved9 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED9_SHIFT 9
#define IMX_USB3_USBSS_EP_ISTS_RESERVED9_MASK 0x200
#define IMX_USB3_USBSS_EP_ISTS_RESERVED9(v) (((v) << 0x9) & 0x200)
/* Field RESERVED10 - reserved10 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED10_SHIFT 10
#define IMX_USB3_USBSS_EP_ISTS_RESERVED10_MASK 0x400
#define IMX_USB3_USBSS_EP_ISTS_RESERVED10(v) (((v) << 0xA) & 0x400)
/* Field RESERVED11 - reserved11 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED11_SHIFT 11
#define IMX_USB3_USBSS_EP_ISTS_RESERVED11_MASK 0x800
#define IMX_USB3_USBSS_EP_ISTS_RESERVED11(v) (((v) << 0xB) & 0x800)
/* Field RESERVED12 - reserved12 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED12_SHIFT 12
#define IMX_USB3_USBSS_EP_ISTS_RESERVED12_MASK 0x1000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED12(v) (((v) << 0xC) & 0x1000)
/* Field RESERVED13 - reserved13 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED13_SHIFT 13
#define IMX_USB3_USBSS_EP_ISTS_RESERVED13_MASK 0x2000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED13(v) (((v) << 0xD) & 0x2000)
/* Field RESERVED14 - reserved14 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED14_SHIFT 14
#define IMX_USB3_USBSS_EP_ISTS_RESERVED14_MASK 0x4000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED14(v) (((v) << 0xE) & 0x4000)
/* Field RESERVED15 - reserved15 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED15_SHIFT 15
#define IMX_USB3_USBSS_EP_ISTS_RESERVED15_MASK 0x8000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED15(v) (((v) << 0xF) & 0x8000)
/* Field EIN0 - EIN0 */
#define IMX_USB3_USBSS_EP_ISTS_EIN0_SHIFT 16
#define IMX_USB3_USBSS_EP_ISTS_EIN0_MASK 0x10000
#define IMX_USB3_USBSS_EP_ISTS_EIN0(v) (((v) << 0x10) & 0x10000)
/* Field EIN1 - EIN1 */
#define IMX_USB3_USBSS_EP_ISTS_EIN1_SHIFT 17
#define IMX_USB3_USBSS_EP_ISTS_EIN1_MASK 0x20000
#define IMX_USB3_USBSS_EP_ISTS_EIN1(v) (((v) << 0x11) & 0x20000)
/* Field EIN2 - EIN2 */
#define IMX_USB3_USBSS_EP_ISTS_EIN2_SHIFT 18
#define IMX_USB3_USBSS_EP_ISTS_EIN2_MASK 0x40000
#define IMX_USB3_USBSS_EP_ISTS_EIN2(v) (((v) << 0x12) & 0x40000)
/* Field EIN3 - EIN3 */
#define IMX_USB3_USBSS_EP_ISTS_EIN3_SHIFT 19
#define IMX_USB3_USBSS_EP_ISTS_EIN3_MASK 0x80000
#define IMX_USB3_USBSS_EP_ISTS_EIN3(v) (((v) << 0x13) & 0x80000)
/* Field EIN4 - EIN4 */
#define IMX_USB3_USBSS_EP_ISTS_EIN4_SHIFT 20
#define IMX_USB3_USBSS_EP_ISTS_EIN4_MASK 0x100000
#define IMX_USB3_USBSS_EP_ISTS_EIN4(v) (((v) << 0x14) & 0x100000)
/* Field EIN5 - EIN5 */
#define IMX_USB3_USBSS_EP_ISTS_EIN5_SHIFT 21
#define IMX_USB3_USBSS_EP_ISTS_EIN5_MASK 0x200000
#define IMX_USB3_USBSS_EP_ISTS_EIN5(v) (((v) << 0x15) & 0x200000)
/* Field EIN6 - EIN6 */
#define IMX_USB3_USBSS_EP_ISTS_EIN6_SHIFT 22
#define IMX_USB3_USBSS_EP_ISTS_EIN6_MASK 0x400000
#define IMX_USB3_USBSS_EP_ISTS_EIN6(v) (((v) << 0x16) & 0x400000)
/* Field EIN7 - EIN7 */
#define IMX_USB3_USBSS_EP_ISTS_EIN7_SHIFT 23
#define IMX_USB3_USBSS_EP_ISTS_EIN7_MASK 0x800000
#define IMX_USB3_USBSS_EP_ISTS_EIN7(v) (((v) << 0x17) & 0x800000)
/* Field RESERVED24 - reserved24 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED24_SHIFT 24
#define IMX_USB3_USBSS_EP_ISTS_RESERVED24_MASK 0x1000000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED24(v) (((v) << 0x18) & 0x1000000)
/* Field RESERVED25 - reserved25 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED25_SHIFT 25
#define IMX_USB3_USBSS_EP_ISTS_RESERVED25_MASK 0x2000000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED25(v) (((v) << 0x19) & 0x2000000)
/* Field RESERVED26 - reserved26 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED26_SHIFT 26
#define IMX_USB3_USBSS_EP_ISTS_RESERVED26_MASK 0x4000000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED26(v) (((v) << 0x1A) & 0x4000000)
/* Field RESERVED27 - reserved27 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED27_SHIFT 27
#define IMX_USB3_USBSS_EP_ISTS_RESERVED27_MASK 0x8000000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED27(v) (((v) << 0x1B) & 0x8000000)
/* Field RESERVED28 - reserved28 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED28_SHIFT 28
#define IMX_USB3_USBSS_EP_ISTS_RESERVED28_MASK 0x10000000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED28(v) (((v) << 0x1C) & 0x10000000)
/* Field RESERVED29 - reserved29 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED29_SHIFT 29
#define IMX_USB3_USBSS_EP_ISTS_RESERVED29_MASK 0x20000000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED29(v) (((v) << 0x1D) & 0x20000000)
/* Field RESERVED30 - reserved30 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED30_SHIFT 30
#define IMX_USB3_USBSS_EP_ISTS_RESERVED30_MASK 0x40000000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED30(v) (((v) << 0x1E) & 0x40000000)
/* Field RESERVED31 - reserved31 */
#define IMX_USB3_USBSS_EP_ISTS_RESERVED31_SHIFT 31
#define IMX_USB3_USBSS_EP_ISTS_RESERVED31_MASK 0x80000000
#define IMX_USB3_USBSS_EP_ISTS_RESERVED31(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_USB_PWR - Global power configuration register */
typedef union IMX_USB3_USBSS_USB_PWR_union_t {
    uint32_t R;
    struct {
        uint32_t PSO_EN      :1;                 /* Power Shut Off capability enable. Writing '1' to this bit enables dower domains switching capability and clears the PSO_DS bit. The Domain will be switched off if both PSO_EN will be set and the USB controller will be in the in the U3 state. It is recommended to set this bit in U3ENTI interrupt service, after software ensures that no data transfer is pending. If this bit will be always set, the controller will automatically switch off the power in the switchable PD after USB controller will enter U3 state. */
        uint32_t PSO_DS      :1;                 /* Power Shut Off capability disable. Writing '1' to this bit disables power domains switching capability and clears the PSO_EN bit. It is recommended to set this bit after during U3EXTI interrupt service. */
        uint32_t RESERVED0   :6;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t STB_CLK_SWITCH_EN :1;           /* Enables turning-off Reference Clock. This bit is optional and implemented only when support for OTG is implemented (indicated by OTG_READY bit set to 1). */
        uint32_t STB_CLK_SWITCH_DONE :1;         /* Status bit indicating that operation required by STB_CLK_SWITCH_EN write is completed. This bit is optional and implemented only when support for OTG is implemented (indicated by OTG_READY bit set to 1). */
        uint32_t RESERVED1   :20;                /* Reserved field. Write ignored. 0 when read */
        uint32_t FAST_REG_ACCESS_STAT :1;        /* Fast Registers Access status. This bit informs if Fast Registers Access is enabled. It should be used as described in FAST_REG_ACCESS bit. */
        uint32_t FAST_REG_ACCESS :1;             /* Fast Registers Access. When Device Port is in a low power state (U3/L2/Not Connected), accesses to registers listed in section 2.3 of USBSS-DEV design specification may take long time. In order to enable fast register access in that case, user can use this register in the following way: - set FAST_REG_ACCESS bit - wait until FAST_REG_ACCESS_STAT bit is set - perform required accesses - clear FAST_REG_ACCESS bit Note that to enable USBSS-DEV low power state entry (U3/L2), the FAST_REG_ACCESS bit has to be cleared. */
    } B;
} IMX_USB3_USBSS_USB_PWR_t;

/* Register USB_PWR - Global power configuration register */
#define IMX_USB3_USBSS_USB_PWR_OFFSET 0x20044
/* Field PSO_EN - Power Shut Off capability enable. Writing '1' to this bit enables dower domains switching capability and clears the PSO_DS bit. The Domain will be switched off if both PSO_EN will be set and the USB controller will be in the in the U3 state. It is recommended to set this bit in U3ENTI interrupt service, after software ensures that no data transfer is pending. If this bit will be always set, the controller will automatically switch off the power in the switchable PD after USB controller will enter U3 state. */
#define IMX_USB3_USBSS_USB_PWR_PSO_EN_SHIFT 0
#define IMX_USB3_USBSS_USB_PWR_PSO_EN_MASK 0x1
#define IMX_USB3_USBSS_USB_PWR_PSO_EN(v) (((v) << 0) & 0x1)
/* Field PSO_DS - Power Shut Off capability disable. Writing '1' to this bit disables power domains switching capability and clears the PSO_EN bit. It is recommended to set this bit after during U3EXTI interrupt service. */
#define IMX_USB3_USBSS_USB_PWR_PSO_DS_SHIFT 1
#define IMX_USB3_USBSS_USB_PWR_PSO_DS_MASK 0x2
#define IMX_USB3_USBSS_USB_PWR_PSO_DS(v) (((v) << 0x1) & 0x2)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_PWR_RESERVED0_SHIFT 2
#define IMX_USB3_USBSS_USB_PWR_RESERVED0_MASK 0xFC
#define IMX_USB3_USBSS_USB_PWR_RESERVED0(v) (((v) << 0x2) & 0xFC)
/* Field STB_CLK_SWITCH_EN - Enables turning-off Reference Clock. This bit is optional and implemented only when support for OTG is implemented (indicated by OTG_READY bit set to 1). */
#define IMX_USB3_USBSS_USB_PWR_STB_CLK_SWITCH_EN_SHIFT 8
#define IMX_USB3_USBSS_USB_PWR_STB_CLK_SWITCH_EN_MASK 0x100
#define IMX_USB3_USBSS_USB_PWR_STB_CLK_SWITCH_EN(v) (((v) << 0x8) & 0x100)
/* Field STB_CLK_SWITCH_DONE - Status bit indicating that operation required by STB_CLK_SWITCH_EN write is completed. This bit is optional and implemented only when support for OTG is implemented (indicated by OTG_READY bit set to 1). */
#define IMX_USB3_USBSS_USB_PWR_STB_CLK_SWITCH_DONE_SHIFT 9
#define IMX_USB3_USBSS_USB_PWR_STB_CLK_SWITCH_DONE_MASK 0x200
#define IMX_USB3_USBSS_USB_PWR_STB_CLK_SWITCH_DONE(v) (((v) << 0x9) & 0x200)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_PWR_RESERVED1_SHIFT 10
#define IMX_USB3_USBSS_USB_PWR_RESERVED1_MASK 0x3FFFFC00
#define IMX_USB3_USBSS_USB_PWR_RESERVED1(v) (((v) << 0xA) & 0x3FFFFC00)
/* Field FAST_REG_ACCESS_STAT - Fast Registers Access status. This bit informs if Fast Registers Access is enabled. It should be used as described in FAST_REG_ACCESS bit. */
#define IMX_USB3_USBSS_USB_PWR_FAST_REG_ACCESS_STAT_SHIFT 30
#define IMX_USB3_USBSS_USB_PWR_FAST_REG_ACCESS_STAT_MASK 0x40000000
#define IMX_USB3_USBSS_USB_PWR_FAST_REG_ACCESS_STAT(v) (((v) << 0x1E) & 0x40000000)
/* Field FAST_REG_ACCESS - Fast Registers Access. When Device Port is in a low power state (U3/L2/Not Connected), accesses to registers listed in section 2.3 of USBSS-DEV design specification may take long time. In order to enable fast register access in that case, user can use this register in the following way: - set FAST_REG_ACCESS bit - wait until FAST_REG_ACCESS_STAT bit is set - perform required accesses - clear FAST_REG_ACCESS bit Note that to enable USBSS-DEV low power state entry (U3/L2), the FAST_REG_ACCESS bit has to be cleared. */
#define IMX_USB3_USBSS_USB_PWR_FAST_REG_ACCESS_SHIFT 31
#define IMX_USB3_USBSS_USB_PWR_FAST_REG_ACCESS_MASK 0x80000000
#define IMX_USB3_USBSS_USB_PWR_FAST_REG_ACCESS(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_USB_CONF2 - USB configuration register 2 */
typedef union IMX_USB3_USBSS_USB_CONF2_union_t {
    uint32_t R;
    struct {
        uint32_t AHB_RETRY_EN :1;                /* AHB retry enable. This bit enables the AHB retrys for AHB slave interface. This bit has no effect when AHB slave interface is not implemented. */
        uint32_t RESERVED    :31;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_USB_CONF2_t;

/* Register USB_CONF2 - USB configuration register 2 */
#define IMX_USB3_USBSS_USB_CONF2_OFFSET 0x20048
/* Field AHB_RETRY_EN - AHB retry enable. This bit enables the AHB retrys for AHB slave interface. This bit has no effect when AHB slave interface is not implemented. */
#define IMX_USB3_USBSS_USB_CONF2_AHB_RETRY_EN_SHIFT 0
#define IMX_USB3_USBSS_USB_CONF2_AHB_RETRY_EN_MASK 0x1
#define IMX_USB3_USBSS_USB_CONF2_AHB_RETRY_EN(v) (((v) << 0) & 0x1)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_USB_CONF2_RESERVED_SHIFT 1
#define IMX_USB3_USBSS_USB_CONF2_RESERVED_MASK 0xFFFFFFFE
#define IMX_USB3_USBSS_USB_CONF2_RESERVED(v) (((v) << 0x1) & 0xFFFFFFFE)

/* IMX_USB3_USBSS_USB_CAP1 - USB Capability Register 1 */
typedef union IMX_USB3_USBSS_USB_CAP1_union_t {
    uint32_t R;
    struct {
        uint32_t SFR_TYPE    :4;                 /* SFR Interface type. This field reflects type of SFR interface implemented: 0x0 - OCP, 0x1 - AHB, 0x2 - PLB, 0x3 - AXI, 0x4-0xF - reserved. */
        uint32_t SFR_WIDTH   :4;                 /* SFR Interface width. This field reflects width of SFR interface implemented: - 0x0: 8 bit interface, - 0x1: 16 bit interface, - 0x2: 32 bit interface, - 0x3: 64 bit interface, - 0x4-0xF: reserved */
        uint32_t DMA_TYPE    :4;                 /* DMA Interface type. This field reflects type of DMA interface implemented: - 0x0: OCP, - 0x1: AHB, - 0x2: PLB, - 0x3: AXI, - 0x4-0xF: reserved */
        uint32_t DMA_WIDTH   :4;                 /* DMA Interface width. This field reflects width of DMA interface implemented: - 0x0: reserved, - 0x1: reserved, - 0x2: 32 bit interface, - 0x3: 64 bit interface, - 0x4-0xF: reserved */
        uint32_t U3PHY_TYPE  :4;                 /* USB3 PHY Interface type. This field reflects type of USB3 PHY interface implemented: - 0x0: USB PIPE, - 0x1: RMMI, - 0x2-0xF: reserved */
        uint32_t U3PHY_WIDTH :4;                 /* USB3 PHY Interface width. This field reflects width of USB3 PHY interface implemented: - 0x0: 8 bit PIPE interface, - 0x1: 16 bit PIPE interface, - 0x2: 32 bit PIPE interface, - 0x3: 64 bit PIPE interface, - 0x4-0xF: reserved. Note: When SSIC interface is implemented this field shows the width of internal PIPE interface. The RMMI interface is always 20-bit wide. */
        uint32_t U2PHY_EN    :1;                 /* USB2 PHY Interface enable. This field informs if USB2 PHY interface is implemented: - interface NOT implemented: 0x0, - interface implemented: 0x1. */
        uint32_t U2PHY_TYPE  :1;                 /* USB2 PHY Interface type. This field reflects type of USB2 PHY interface implemented: - UTMI: 0x0, - ULPI: 0x1. */
        uint32_t U2PHY_WIDTH :1;                 /* USB2 PHY Interface width. This field reflects width of USB2 PHY interface implemented: - 8 bit interface: 0x0, - 16 bit interface: 0x1. Note: The ULPI interface is always 8-bit wide. */
        uint32_t OTG_READY   :1;                 /* This field informs if device is OTG ready: - pure device mode: 0x0, - some features and ports for CDNS USB OTG controller are implemented: 0x1. */
        uint32_t RESERVED    :4;                 /* This field is reserved and it is always 0 when reading. */
    } B;
} IMX_USB3_USBSS_USB_CAP1_t;

/* Register USB_CAP1 - USB Capability Register 1 */
#define IMX_USB3_USBSS_USB_CAP1_OFFSET 0x2004C
/* Field SFR_TYPE - SFR Interface type. This field reflects type of SFR interface implemented: 0x0 - OCP, 0x1 - AHB, 0x2 - PLB, 0x3 - AXI, 0x4-0xF - reserved. */
#define IMX_USB3_USBSS_USB_CAP1_SFR_TYPE_SHIFT 0
#define IMX_USB3_USBSS_USB_CAP1_SFR_TYPE_MASK 0xF
#define IMX_USB3_USBSS_USB_CAP1_SFR_TYPE(v) (((v) << 0) & 0xF)
/* Field SFR_WIDTH - SFR Interface width. This field reflects width of SFR interface implemented: - 0x0: 8 bit interface, - 0x1: 16 bit interface, - 0x2: 32 bit interface, - 0x3: 64 bit interface, - 0x4-0xF: reserved */
#define IMX_USB3_USBSS_USB_CAP1_SFR_WIDTH_SHIFT 4
#define IMX_USB3_USBSS_USB_CAP1_SFR_WIDTH_MASK 0xF0
#define IMX_USB3_USBSS_USB_CAP1_SFR_WIDTH(v) (((v) << 0x4) & 0xF0)
/* Field DMA_TYPE - DMA Interface type. This field reflects type of DMA interface implemented: - 0x0: OCP, - 0x1: AHB, - 0x2: PLB, - 0x3: AXI, - 0x4-0xF: reserved */
#define IMX_USB3_USBSS_USB_CAP1_DMA_TYPE_SHIFT 8
#define IMX_USB3_USBSS_USB_CAP1_DMA_TYPE_MASK 0xF00
#define IMX_USB3_USBSS_USB_CAP1_DMA_TYPE(v) (((v) << 0x8) & 0xF00)
/* Field DMA_WIDTH - DMA Interface width. This field reflects width of DMA interface implemented: - 0x0: reserved, - 0x1: reserved, - 0x2: 32 bit interface, - 0x3: 64 bit interface, - 0x4-0xF: reserved */
#define IMX_USB3_USBSS_USB_CAP1_DMA_WIDTH_SHIFT 12
#define IMX_USB3_USBSS_USB_CAP1_DMA_WIDTH_MASK 0xF000
#define IMX_USB3_USBSS_USB_CAP1_DMA_WIDTH(v) (((v) << 0xC) & 0xF000)
/* Field U3PHY_TYPE - USB3 PHY Interface type. This field reflects type of USB3 PHY interface implemented: - 0x0: USB PIPE, - 0x1: RMMI, - 0x2-0xF: reserved */
#define IMX_USB3_USBSS_USB_CAP1_U3PHY_TYPE_SHIFT 16
#define IMX_USB3_USBSS_USB_CAP1_U3PHY_TYPE_MASK 0xF0000
#define IMX_USB3_USBSS_USB_CAP1_U3PHY_TYPE(v) (((v) << 0x10) & 0xF0000)
/* Field U3PHY_WIDTH - USB3 PHY Interface width. This field reflects width of USB3 PHY interface implemented: - 0x0: 8 bit PIPE interface, - 0x1: 16 bit PIPE interface, - 0x2: 32 bit PIPE interface, - 0x3: 64 bit PIPE interface, - 0x4-0xF: reserved. Note: When SSIC interface is implemented this field shows the width of internal PIPE interface. The RMMI interface is always 20-bit wide. */
#define IMX_USB3_USBSS_USB_CAP1_U3PHY_WIDTH_SHIFT 20
#define IMX_USB3_USBSS_USB_CAP1_U3PHY_WIDTH_MASK 0xF00000
#define IMX_USB3_USBSS_USB_CAP1_U3PHY_WIDTH(v) (((v) << 0x14) & 0xF00000)
/* Field U2PHY_EN - USB2 PHY Interface enable. This field informs if USB2 PHY interface is implemented: - interface NOT implemented: 0x0, - interface implemented: 0x1. */
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_EN_SHIFT 24
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_EN_MASK 0x1000000
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_EN(v) (((v) << 0x18) & 0x1000000)
/* Field U2PHY_TYPE - USB2 PHY Interface type. This field reflects type of USB2 PHY interface implemented: - UTMI: 0x0, - ULPI: 0x1. */
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_TYPE_SHIFT 25
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_TYPE_MASK 0x2000000
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_TYPE(v) (((v) << 0x19) & 0x2000000)
/* Field U2PHY_WIDTH - USB2 PHY Interface width. This field reflects width of USB2 PHY interface implemented: - 8 bit interface: 0x0, - 16 bit interface: 0x1. Note: The ULPI interface is always 8-bit wide. */
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_WIDTH_SHIFT 26
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_WIDTH_MASK 0x4000000
#define IMX_USB3_USBSS_USB_CAP1_U2PHY_WIDTH(v) (((v) << 0x1A) & 0x4000000)
/* Field OTG_READY - This field informs if device is OTG ready: - pure device mode: 0x0, - some features and ports for CDNS USB OTG controller are implemented: 0x1. */
#define IMX_USB3_USBSS_USB_CAP1_OTG_READY_SHIFT 27
#define IMX_USB3_USBSS_USB_CAP1_OTG_READY_MASK 0x8000000
#define IMX_USB3_USBSS_USB_CAP1_OTG_READY(v) (((v) << 0x1B) & 0x8000000)
/* Field RESERVED - This field is reserved and it is always 0 when reading. */
#define IMX_USB3_USBSS_USB_CAP1_RESERVED_SHIFT 28
#define IMX_USB3_USBSS_USB_CAP1_RESERVED_MASK 0xF0000000
#define IMX_USB3_USBSS_USB_CAP1_RESERVED(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_USB_CAP2 - USB Capability Register */
typedef union IMX_USB3_USBSS_USB_CAP2_union_t {
    uint32_t R;
    struct {
        uint32_t ACTUAL_MEM_SIZE :8;             /* The actual size of the connected On-chip RAM memory in kB: - 0 means 256 kB (max supported mem size) - value other than 0 reflects the mem size in kB. This value reflects the CDNS_USBSSDEV_ATTACHED_MEM_SIZE parameter defined in the usbss_dev_defines.v file. This value has to be adequately set before synthesis by engineer who connects the on-chip memory for controller. */
        uint32_t MAX_MEM_SIZE :5;                /* Max supported mem size. This field reflects width of on-chip RAM address bus width, which determines max supported mem size: 0x0-0x7 reserved, 0x8 - support for 4kB mem, 0x9 - support for 8kB mem, 0xA - support for 16kB mem, 0xB - support for 32kB mem, 0xC - support for 64kB mem, 0xD - support for 128kB mem, 0xE - support for 256kB mem, 0xF - reserved. */
        uint32_t RESERVED    :19;                /* RESERVED */
    } B;
} IMX_USB3_USBSS_USB_CAP2_t;

/* Register USB_CAP2 - USB Capability Register */
#define IMX_USB3_USBSS_USB_CAP2_OFFSET 0x20050
/* Field ACTUAL_MEM_SIZE - The actual size of the connected On-chip RAM memory in kB: - 0 means 256 kB (max supported mem size) - value other than 0 reflects the mem size in kB. This value reflects the CDNS_USBSSDEV_ATTACHED_MEM_SIZE parameter defined in the usbss_dev_defines.v file. This value has to be adequately set before synthesis by engineer who connects the on-chip memory for controller. */
#define IMX_USB3_USBSS_USB_CAP2_ACTUAL_MEM_SIZE_SHIFT 0
#define IMX_USB3_USBSS_USB_CAP2_ACTUAL_MEM_SIZE_MASK 0xFF
#define IMX_USB3_USBSS_USB_CAP2_ACTUAL_MEM_SIZE(v) (((v) << 0) & 0xFF)
/* Field MAX_MEM_SIZE - Max supported mem size. This field reflects width of on-chip RAM address bus width, which determines max supported mem size: 0x0-0x7 reserved, 0x8 - support for 4kB mem, 0x9 - support for 8kB mem, 0xA - support for 16kB mem, 0xB - support for 32kB mem, 0xC - support for 64kB mem, 0xD - support for 128kB mem, 0xE - support for 256kB mem, 0xF - reserved. */
#define IMX_USB3_USBSS_USB_CAP2_MAX_MEM_SIZE_SHIFT 8
#define IMX_USB3_USBSS_USB_CAP2_MAX_MEM_SIZE_MASK 0x1F00
#define IMX_USB3_USBSS_USB_CAP2_MAX_MEM_SIZE(v) (((v) << 0x8) & 0x1F00)
/* Field RESERVED - RESERVED */
#define IMX_USB3_USBSS_USB_CAP2_RESERVED_SHIFT 13
#define IMX_USB3_USBSS_USB_CAP2_RESERVED_MASK 0xFFFFE000
#define IMX_USB3_USBSS_USB_CAP2_RESERVED(v) (((v) << 0xD) & 0xFFFFE000)

/* IMX_USB3_USBSS_USB_CAP3 - USB Capability Register 3. */
typedef union IMX_USB3_USBSS_USB_CAP3_union_t {
    uint32_t R;
    struct {
        uint32_t EPOUT_N     :16;                /* EPOUT_N */
        uint32_t EPIN_N      :16;                /* EPIN_N */
    } B;
} IMX_USB3_USBSS_USB_CAP3_t;

/* Register USB_CAP3 - USB Capability Register 3. */
#define IMX_USB3_USBSS_USB_CAP3_OFFSET 0x20054
/* Field EPOUT_N - EPOUT_N */
#define IMX_USB3_USBSS_USB_CAP3_EPOUT_N_SHIFT 0
#define IMX_USB3_USBSS_USB_CAP3_EPOUT_N_MASK 0xFFFF
#define IMX_USB3_USBSS_USB_CAP3_EPOUT_N(v) (((v) << 0) & 0xFFFF)
/* Field EPIN_N - EPIN_N */
#define IMX_USB3_USBSS_USB_CAP3_EPIN_N_SHIFT 16
#define IMX_USB3_USBSS_USB_CAP3_EPIN_N_MASK 0xFFFF0000
#define IMX_USB3_USBSS_USB_CAP3_EPIN_N(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_USB_CAP4 - ISO HW support for Endpoints implemented EPINI. */
typedef union IMX_USB3_USBSS_USB_CAP4_union_t {
    uint32_t R;
    struct {
        uint32_t EPOUTI_N    :16;                /* EPOUTI_N */
        uint32_t EPINI_N     :16;                /* EPINI_N */
    } B;
} IMX_USB3_USBSS_USB_CAP4_t;

/* Register USB_CAP4 - ISO HW support for Endpoints implemented EPINI. */
#define IMX_USB3_USBSS_USB_CAP4_OFFSET 0x20058
/* Field EPOUTI_N - EPOUTI_N */
#define IMX_USB3_USBSS_USB_CAP4_EPOUTI_N_SHIFT 0
#define IMX_USB3_USBSS_USB_CAP4_EPOUTI_N_MASK 0xFFFF
#define IMX_USB3_USBSS_USB_CAP4_EPOUTI_N(v) (((v) << 0) & 0xFFFF)
/* Field EPINI_N - EPINI_N */
#define IMX_USB3_USBSS_USB_CAP4_EPINI_N_SHIFT 16
#define IMX_USB3_USBSS_USB_CAP4_EPINI_N_MASK 0xFFFF0000
#define IMX_USB3_USBSS_USB_CAP4_EPINI_N(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_USB_CAP5 - Bulk Stream HW support for Endpoints implemented. */
typedef union IMX_USB3_USBSS_USB_CAP5_union_t {
    uint32_t R;
    struct {
        uint32_t EPOUTI_N    :16;                /* EPOUTI_N */
        uint32_t EPINI_N     :16;                /* EPINI_N */
    } B;
} IMX_USB3_USBSS_USB_CAP5_t;

/* Register USB_CAP5 - Bulk Stream HW support for Endpoints implemented. */
#define IMX_USB3_USBSS_USB_CAP5_OFFSET 0x2005C
/* Field EPOUTI_N - EPOUTI_N */
#define IMX_USB3_USBSS_USB_CAP5_EPOUTI_N_SHIFT 0
#define IMX_USB3_USBSS_USB_CAP5_EPOUTI_N_MASK 0xFFFF
#define IMX_USB3_USBSS_USB_CAP5_EPOUTI_N(v) (((v) << 0) & 0xFFFF)
/* Field EPINI_N - EPINI_N */
#define IMX_USB3_USBSS_USB_CAP5_EPINI_N_SHIFT 16
#define IMX_USB3_USBSS_USB_CAP5_EPINI_N_MASK 0xFFFF0000
#define IMX_USB3_USBSS_USB_CAP5_EPINI_N(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_USB_CAP6 - Device controller version. */
typedef union IMX_USB3_USBSS_USB_CAP6_union_t {
    uint32_t R;
    struct {
        uint32_t VERSION     :32;                /* VERSION */
    } B;
} IMX_USB3_USBSS_USB_CAP6_t;

/* Register USB_CAP6 - Device controller version. */
#define IMX_USB3_USBSS_USB_CAP6_OFFSET 0x20060
/* Field VERSION - VERSION */
#define IMX_USB3_USBSS_USB_CAP6_VERSION_SHIFT 0
#define IMX_USB3_USBSS_USB_CAP6_VERSION_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_USB_CAP6_VERSION(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_USB_CPKT1 - Custom Packet value. */
typedef union IMX_USB3_USBSS_USB_CPKT1_union_t {
    uint32_t R;
    struct {
        uint32_t CPKT1       :32;                /* CPKT1 */
    } B;
} IMX_USB3_USBSS_USB_CPKT1_t;

/* Register USB_CPKT1 - Custom Packet value. */
#define IMX_USB3_USBSS_USB_CPKT1_OFFSET 0x20064
/* Field CPKT1 - CPKT1 */
#define IMX_USB3_USBSS_USB_CPKT1_CPKT1_SHIFT 0
#define IMX_USB3_USBSS_USB_CPKT1_CPKT1_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_USB_CPKT1_CPKT1(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_USB_CPKT2 - Custom Packet value. */
typedef union IMX_USB3_USBSS_USB_CPKT2_union_t {
    uint32_t R;
    struct {
        uint32_t CPKT2       :32;                /* CPKT2 */
    } B;
} IMX_USB3_USBSS_USB_CPKT2_t;

/* Register USB_CPKT2 - Custom Packet value. */
#define IMX_USB3_USBSS_USB_CPKT2_OFFSET 0x20068
/* Field CPKT2 - CPKT2 */
#define IMX_USB3_USBSS_USB_CPKT2_CPKT2_SHIFT 0
#define IMX_USB3_USBSS_USB_CPKT2_CPKT2_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_USB_CPKT2_CPKT2(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_USB_CPKT3 - Custom Packet value. */
typedef union IMX_USB3_USBSS_USB_CPKT3_union_t {
    uint32_t R;
    struct {
        uint32_t CPKT3       :32;                /* CPKT3 */
    } B;
} IMX_USB3_USBSS_USB_CPKT3_t;

/* Register USB_CPKT3 - Custom Packet value. */
#define IMX_USB3_USBSS_USB_CPKT3_OFFSET 0x2006C
/* Field CPKT3 - CPKT3 */
#define IMX_USB3_USBSS_USB_CPKT3_CPKT3_SHIFT 0
#define IMX_USB3_USBSS_USB_CPKT3_CPKT3_MASK 0xFFFFFFFF
#define IMX_USB3_USBSS_USB_CPKT3_CPKT3(v) (((v) << 0) & 0xFFFFFFFF)

/* IMX_USB3_USBSS_CFG_REG1 - VBUS debouncer Configuration Register 1 */
typedef union IMX_USB3_USBSS_CFG_REG1_union_t {
    uint32_t R;
    struct {
        uint32_t DEBOUNCER_CNT :18;              /* This parameter defines the VBUS debouncer delay i.e. the time interval between the VBUS detection on device input and the start of using it internally. Resolution of this parameter is 128 ns. For simulation purposes it is recommended to set the value 1 (128ns) For synthesis purposes it is recommended to set the value 230000 (~30ms) */
        uint32_t RESERVED    :14;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG1_t;

/* Register CFG_REG1 - VBUS debouncer Configuration Register 1 */
#define IMX_USB3_USBSS_CFG_REG1_OFFSET 0x20100
/* Field DEBOUNCER_CNT - This parameter defines the VBUS debouncer delay i.e. the time interval between the VBUS detection on device input and the start of using it internally. Resolution of this parameter is 128 ns. For simulation purposes it is recommended to set the value 1 (128ns) For synthesis purposes it is recommended to set the value 230000 (~30ms) */
#define IMX_USB3_USBSS_CFG_REG1_DEBOUNCER_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG1_DEBOUNCER_CNT_MASK 0x3FFFF
#define IMX_USB3_USBSS_CFG_REG1_DEBOUNCER_CNT(v) (((v) << 0) & 0x3FFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG1_RESERVED_SHIFT 18
#define IMX_USB3_USBSS_CFG_REG1_RESERVED_MASK 0xFFFC0000
#define IMX_USB3_USBSS_CFG_REG1_RESERVED(v) (((v) << 0x12) & 0xFFFC0000)

/* IMX_USB3_USBSS_DBG_LINK1 - USB3. */
typedef union IMX_USB3_USBSS_DBG_LINK1_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_MIN_DET_U1_EXIT :8;        /* LFPS_MIN_DET_U1_EXIT value This parameter configures the minimum time required for decoding the received LFPS as an LFPS.U1_Exit. Example is shown in the chapter 4. This field is saved to the device only when the field LFPS_MIN_DET_U1_EXIT_SET is set to '1' during write to the DBG_LINK1 register. Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 36 (~300ns). For synthesis purposes it is recommended to set the value 36 (~300ns). */
        uint32_t LFPS_MIN_GEN_U1_EXIT :8;        /* LFPS_MIN_GEN_U1_EXIT value This parameter configures the minimum time for phytxelecidle deassertion when LFPS.U1_Exit signalling is generated as shown in the chapter 4. This field is saved to the device only when the field LFPS_MIN_GEN_U1_EXIT_SET is set to '1' during write to the DBG_LINK1 register. Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 87 (~696ns) For synthesis purposes it is recommended to set the value 87 (~696ns) */
        uint32_t RXDET_BREAK_DIS :1;             /* RXDET_BREAK_DIS value This parameter configures terminating the Far-end Receiver termination detection sequence: '0': it is possible that USBSS_DEV will terminate Far-end receiver termination detection sequence '1': USBSS_DEV will not terminate Far-end receiver termination detection sequence The impact of the bit to the link behaviour is shown in chapter 4. This field is saved to the device only when the field RXDET_BREAK_DIS_SET is set to '1' during write to the DBG_LINK1 register. */
        uint32_t LFPS_GEN_PING :5;               /* LFPS_GEN_PING value This parameter configures the LFPS.Ping generation time as shown in the chapter 4. This field is saved to the device only when the field LFPS_GEN_PING_SET is set to '1' during write to the DBG_LINK1 register. Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 24 (~200ns) For synthesis purposes it is recommended to set the value 24 (~200ns) */
        uint32_t RESERVED0   :2;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t LFPS_MIN_DET_U1_EXIT_SET :1;    /* Set the LFPS_MIN_DET_U1_EXIT value Writing '1' to this bit writes the LFPS_MIN_DET_U1_EXIT field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
        uint32_t LFPS_MIN_GEN_U1_EXIT_SET :1;    /* Set the LFPS_MIN_GEN_U1_EXIT value Writing '1' to this bit writes the LFPS_MIN_GEN_U1_EXIT field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
        uint32_t RXDET_BREAK_DIS_SET :1;         /* Set the RXDET_BREAK_DIS value Writing '1' to this bit writes the RXDET_BREAK_DIS field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
        uint32_t LFPS_GEN_PING_SET :1;           /* Set the LFPS_GEN_PING_SET value Writing '1' to this bit writes the LFPS_GEN_PING field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
        uint32_t RESERVED1   :4;                 /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_DBG_LINK1_t;

/* Register DBG_LINK1 - USB3. */
#define IMX_USB3_USBSS_DBG_LINK1_OFFSET 0x20104
/* Field LFPS_MIN_DET_U1_EXIT - LFPS_MIN_DET_U1_EXIT value This parameter configures the minimum time required for decoding the received LFPS as an LFPS.U1_Exit. Example is shown in the chapter 4. This field is saved to the device only when the field LFPS_MIN_DET_U1_EXIT_SET is set to '1' during write to the DBG_LINK1 register. Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 36 (~300ns). For synthesis purposes it is recommended to set the value 36 (~300ns). */
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_DET_U1_EXIT_SHIFT 0
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_DET_U1_EXIT_MASK 0xFF
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_DET_U1_EXIT(v) (((v) << 0) & 0xFF)
/* Field LFPS_MIN_GEN_U1_EXIT - LFPS_MIN_GEN_U1_EXIT value This parameter configures the minimum time for phytxelecidle deassertion when LFPS.U1_Exit signalling is generated as shown in the chapter 4. This field is saved to the device only when the field LFPS_MIN_GEN_U1_EXIT_SET is set to '1' during write to the DBG_LINK1 register. Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 87 (~696ns) For synthesis purposes it is recommended to set the value 87 (~696ns) */
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_GEN_U1_EXIT_SHIFT 8
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_GEN_U1_EXIT_MASK 0xFF00
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_GEN_U1_EXIT(v) (((v) << 0x8) & 0xFF00)
/* Field RXDET_BREAK_DIS - RXDET_BREAK_DIS value This parameter configures terminating the Far-end Receiver termination detection sequence: '0': it is possible that USBSS_DEV will terminate Far-end receiver termination detection sequence '1': USBSS_DEV will not terminate Far-end receiver termination detection sequence The impact of the bit to the link behaviour is shown in chapter 4. This field is saved to the device only when the field RXDET_BREAK_DIS_SET is set to '1' during write to the DBG_LINK1 register. */
#define IMX_USB3_USBSS_DBG_LINK1_RXDET_BREAK_DIS_SHIFT 16
#define IMX_USB3_USBSS_DBG_LINK1_RXDET_BREAK_DIS_MASK 0x10000
#define IMX_USB3_USBSS_DBG_LINK1_RXDET_BREAK_DIS(v) (((v) << 0x10) & 0x10000)
/* Field LFPS_GEN_PING - LFPS_GEN_PING value This parameter configures the LFPS.Ping generation time as shown in the chapter 4. This field is saved to the device only when the field LFPS_GEN_PING_SET is set to '1' during write to the DBG_LINK1 register. Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 24 (~200ns) For synthesis purposes it is recommended to set the value 24 (~200ns) */
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_GEN_PING_SHIFT 17
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_GEN_PING_MASK 0x3E0000
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_GEN_PING(v) (((v) << 0x11) & 0x3E0000)
/* Field RESERVED0 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_DBG_LINK1_RESERVED0_SHIFT 22
#define IMX_USB3_USBSS_DBG_LINK1_RESERVED0_MASK 0xC00000
#define IMX_USB3_USBSS_DBG_LINK1_RESERVED0(v) (((v) << 0x16) & 0xC00000)
/* Field LFPS_MIN_DET_U1_EXIT_SET - Set the LFPS_MIN_DET_U1_EXIT value Writing '1' to this bit writes the LFPS_MIN_DET_U1_EXIT field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_DET_U1_EXIT_SET_SHIFT 24
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_DET_U1_EXIT_SET_MASK 0x1000000
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_DET_U1_EXIT_SET(v) (((v) << 0x18) & 0x1000000)
/* Field LFPS_MIN_GEN_U1_EXIT_SET - Set the LFPS_MIN_GEN_U1_EXIT value Writing '1' to this bit writes the LFPS_MIN_GEN_U1_EXIT field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_GEN_U1_EXIT_SET_SHIFT 25
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_GEN_U1_EXIT_SET_MASK 0x2000000
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_MIN_GEN_U1_EXIT_SET(v) (((v) << 0x19) & 0x2000000)
/* Field RXDET_BREAK_DIS_SET - Set the RXDET_BREAK_DIS value Writing '1' to this bit writes the RXDET_BREAK_DIS field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
#define IMX_USB3_USBSS_DBG_LINK1_RXDET_BREAK_DIS_SET_SHIFT 26
#define IMX_USB3_USBSS_DBG_LINK1_RXDET_BREAK_DIS_SET_MASK 0x4000000
#define IMX_USB3_USBSS_DBG_LINK1_RXDET_BREAK_DIS_SET(v) (((v) << 0x1A) & 0x4000000)
/* Field LFPS_GEN_PING_SET - Set the LFPS_GEN_PING_SET value Writing '1' to this bit writes the LFPS_GEN_PING field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_GEN_PING_SET_SHIFT 27
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_GEN_PING_SET_MASK 0x8000000
#define IMX_USB3_USBSS_DBG_LINK1_LFPS_GEN_PING_SET(v) (((v) << 0x1B) & 0x8000000)
/* Field RESERVED1 - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_DBG_LINK1_RESERVED1_SHIFT 28
#define IMX_USB3_USBSS_DBG_LINK1_RESERVED1_MASK 0xF0000000
#define IMX_USB3_USBSS_DBG_LINK1_RESERVED1(v) (((v) << 0x1C) & 0xF0000000)

/* IMX_USB3_USBSS_DBG_LINK2 - USB3. */
typedef union IMX_USB3_USBSS_DBG_LINK2_union_t {
    uint32_t R;
    struct {
        uint32_t RXEQTR_AVAL :8;                 /* Rxeqtraining assertion value This parameter configures phyrxeqtraining asserting time as shown in the chapter 4. This field is saved to the device only when the field RXEQTR_AVAL_SET is set to '1' during write to the DBG_LINK2 register. */
        uint32_t RXEQTR_DVAL :8;                 /* Rxeqtraining deassertion value This parameter configures phyrxeqtraining deasserting time as shown in the chapter 4. This field is saved to the device only when the field RXEQTR_DVAL_SET is set to '1' during write to the DBG_LINK2 register. */
        uint32_t PHYRXVAL_DVAL :8;               /* Phyrxvalid latency deassertion value This parameter enables extending internal phyrxdata and phyrxdatak validity as shown in the chapter 4. This field is saved to the device only when the field PHYRXVAL_DVAL_SET is set to '1' during write to the DBG_LINK2 register. */
        uint32_t TXDET_DVAL  :3;                 /* TXDET deassertion value This parameter configures the phytxdetrx_loop deassertion time after phystatus deassertion during Far-end receiver termination sequence as shown in the chapter 4. This field is saved to the device only when the field TXDET_DVAL_SET is set to '1' during write to the DBG_LINK2 register. */
        uint32_t RESERVED    :1;                 /* Reserved field. Write ignored. 0 when read */
        uint32_t RXEQTR_AVAL_SET :1;             /* Set the rxeqtraining assertion value Writing '1' to this bit writes the RXEQTR_AVAL field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
        uint32_t RXEQTR_DVAL_SET :1;             /* Set the rxeqtraining deassertion value Writing '1' to this bit writes the RXEQTR_DVAL field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
        uint32_t PHYRXVAL_DVAL_SET :1;           /* Set the Phyrxvalid latency deassertion value Writing '1' to this bit writes the PHYRXVAL_DVAL field value to the device. This bit is automatically cleared. Writing '0' has no effect.0 */
        uint32_t TXDET_DVAL_SET :1;              /* Set the TXDET deassertion value Writing '1' to this bit writes the TXDET_DVAL field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
    } B;
} IMX_USB3_USBSS_DBG_LINK2_t;

/* Register DBG_LINK2 - USB3. */
#define IMX_USB3_USBSS_DBG_LINK2_OFFSET 0x20108
/* Field RXEQTR_AVAL - Rxeqtraining assertion value This parameter configures phyrxeqtraining asserting time as shown in the chapter 4. This field is saved to the device only when the field RXEQTR_AVAL_SET is set to '1' during write to the DBG_LINK2 register. */
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_AVAL_SHIFT 0
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_AVAL_MASK 0xFF
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_AVAL(v) (((v) << 0) & 0xFF)
/* Field RXEQTR_DVAL - Rxeqtraining deassertion value This parameter configures phyrxeqtraining deasserting time as shown in the chapter 4. This field is saved to the device only when the field RXEQTR_DVAL_SET is set to '1' during write to the DBG_LINK2 register. */
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_DVAL_SHIFT 8
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_DVAL_MASK 0xFF00
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_DVAL(v) (((v) << 0x8) & 0xFF00)
/* Field PHYRXVAL_DVAL - Phyrxvalid latency deassertion value This parameter enables extending internal phyrxdata and phyrxdatak validity as shown in the chapter 4. This field is saved to the device only when the field PHYRXVAL_DVAL_SET is set to '1' during write to the DBG_LINK2 register. */
#define IMX_USB3_USBSS_DBG_LINK2_PHYRXVAL_DVAL_SHIFT 16
#define IMX_USB3_USBSS_DBG_LINK2_PHYRXVAL_DVAL_MASK 0xFF0000
#define IMX_USB3_USBSS_DBG_LINK2_PHYRXVAL_DVAL(v) (((v) << 0x10) & 0xFF0000)
/* Field TXDET_DVAL - TXDET deassertion value This parameter configures the phytxdetrx_loop deassertion time after phystatus deassertion during Far-end receiver termination sequence as shown in the chapter 4. This field is saved to the device only when the field TXDET_DVAL_SET is set to '1' during write to the DBG_LINK2 register. */
#define IMX_USB3_USBSS_DBG_LINK2_TXDET_DVAL_SHIFT 24
#define IMX_USB3_USBSS_DBG_LINK2_TXDET_DVAL_MASK 0x7000000
#define IMX_USB3_USBSS_DBG_LINK2_TXDET_DVAL(v) (((v) << 0x18) & 0x7000000)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_DBG_LINK2_RESERVED_SHIFT 27
#define IMX_USB3_USBSS_DBG_LINK2_RESERVED_MASK 0x8000000
#define IMX_USB3_USBSS_DBG_LINK2_RESERVED(v) (((v) << 0x1B) & 0x8000000)
/* Field RXEQTR_AVAL_SET - Set the rxeqtraining assertion value Writing '1' to this bit writes the RXEQTR_AVAL field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_AVAL_SET_SHIFT 28
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_AVAL_SET_MASK 0x10000000
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_AVAL_SET(v) (((v) << 0x1C) & 0x10000000)
/* Field RXEQTR_DVAL_SET - Set the rxeqtraining deassertion value Writing '1' to this bit writes the RXEQTR_DVAL field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_DVAL_SET_SHIFT 29
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_DVAL_SET_MASK 0x20000000
#define IMX_USB3_USBSS_DBG_LINK2_RXEQTR_DVAL_SET(v) (((v) << 0x1D) & 0x20000000)
/* Field PHYRXVAL_DVAL_SET - Set the Phyrxvalid latency deassertion value Writing '1' to this bit writes the PHYRXVAL_DVAL field value to the device. This bit is automatically cleared. Writing '0' has no effect.0 */
#define IMX_USB3_USBSS_DBG_LINK2_PHYRXVAL_DVAL_SET_SHIFT 30
#define IMX_USB3_USBSS_DBG_LINK2_PHYRXVAL_DVAL_SET_MASK 0x40000000
#define IMX_USB3_USBSS_DBG_LINK2_PHYRXVAL_DVAL_SET(v) (((v) << 0x1E) & 0x40000000)
/* Field TXDET_DVAL_SET - Set the TXDET deassertion value Writing '1' to this bit writes the TXDET_DVAL field value to the device. This bit is automatically cleared. Writing '0' has no effect. */
#define IMX_USB3_USBSS_DBG_LINK2_TXDET_DVAL_SET_SHIFT 31
#define IMX_USB3_USBSS_DBG_LINK2_TXDET_DVAL_SET_MASK 0x80000000
#define IMX_USB3_USBSS_DBG_LINK2_TXDET_DVAL_SET(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_CFG_REG4 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG4_union_t {
    uint32_t R;
    struct {
        uint32_t RXDETECT_QUIET_TIMEOUT :8;      /* RXDETECT_QUIET_TIMEOUT value Resolution of this parameter is selected by RXDETECT_QUIET_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 13*1us =~12us (VIP based ENV) For synthesis purposes it is recommended to set the value 121*100us =~12ms */
        uint32_t RESERVED    :22;                /* Reserved field. Write ignored. 0 when read */
        uint32_t RXDETECT_QUIET_TIMEOUT_PRESCALE :2; /* PRESCALER for RXDETECT_QUIET_TIMEOUT : - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG4_t;

/* Register CFG_REG4 - USB3. */
#define IMX_USB3_USBSS_CFG_REG4_OFFSET 0x2010C
/* Field RXDETECT_QUIET_TIMEOUT - RXDETECT_QUIET_TIMEOUT value Resolution of this parameter is selected by RXDETECT_QUIET_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 13*1us =~12us (VIP based ENV) For synthesis purposes it is recommended to set the value 121*100us =~12ms */
#define IMX_USB3_USBSS_CFG_REG4_RXDETECT_QUIET_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG4_RXDETECT_QUIET_TIMEOUT_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG4_RXDETECT_QUIET_TIMEOUT(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG4_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG4_RESERVED_MASK 0x3FFFFF00
#define IMX_USB3_USBSS_CFG_REG4_RESERVED(v) (((v) << 0x8) & 0x3FFFFF00)
/* Field RXDETECT_QUIET_TIMEOUT_PRESCALE - PRESCALER for RXDETECT_QUIET_TIMEOUT : - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG4_RXDETECT_QUIET_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG4_RXDETECT_QUIET_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG4_RXDETECT_QUIET_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG5 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG5_union_t {
    uint32_t R;
    struct {
        uint32_t U3_HDSK_FAIL_TIMEOUT :11;       /* U3_HDSK_FAIL_TIMEOUT value Resolution of this parameter is selected by U3_HDSK_FAIL_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 11*100us =~1ms (VIP based ENV) For synthesis purposes it is recommended to set the value 1001*100us =~100ms */
        uint32_t RESERVED    :19;                /* Reserved field. Write ignored. 0 when read */
        uint32_t U3_HDSK_FAIL_TIMEOUT_PRESCALE :2; /* PRESCALER for U3_HDSK_FAIL_TIMEOUT : - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG5_t;

/* Register CFG_REG5 - USB3. */
#define IMX_USB3_USBSS_CFG_REG5_OFFSET 0x20110
/* Field U3_HDSK_FAIL_TIMEOUT - U3_HDSK_FAIL_TIMEOUT value Resolution of this parameter is selected by U3_HDSK_FAIL_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 11*100us =~1ms (VIP based ENV) For synthesis purposes it is recommended to set the value 1001*100us =~100ms */
#define IMX_USB3_USBSS_CFG_REG5_U3_HDSK_FAIL_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG5_U3_HDSK_FAIL_TIMEOUT_MASK 0x7FF
#define IMX_USB3_USBSS_CFG_REG5_U3_HDSK_FAIL_TIMEOUT(v) (((v) << 0) & 0x7FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG5_RESERVED_SHIFT 11
#define IMX_USB3_USBSS_CFG_REG5_RESERVED_MASK 0x3FFFF800
#define IMX_USB3_USBSS_CFG_REG5_RESERVED(v) (((v) << 0xB) & 0x3FFFF800)
/* Field U3_HDSK_FAIL_TIMEOUT_PRESCALE - PRESCALER for U3_HDSK_FAIL_TIMEOUT : - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG5_U3_HDSK_FAIL_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG5_U3_HDSK_FAIL_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG5_U3_HDSK_FAIL_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG6 - Configuration Register 6 */
typedef union IMX_USB3_USBSS_CFG_REG6_union_t {
    uint32_t R;
    struct {
        uint32_t SSINACTIVE_QUIET_TIMEOUT :8;    /* SSINACTIVE_QUIET_TIMEOUT value Resolution of this parameter is selected by SSINACTIVE_QUIET_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 13*1us =~12us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
        uint32_t RESERVED    :22;                /* Reserved field. Write ignored. 0 when read */
        uint32_t SSINACTIVE_QUIET_TIMEOUT_PRESCALE :2; /* PRESCALER for SSINACTIVE_QUIET_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG6_t;

/* Register CFG_REG6 - Configuration Register 6 */
#define IMX_USB3_USBSS_CFG_REG6_OFFSET 0x20114
/* Field SSINACTIVE_QUIET_TIMEOUT - SSINACTIVE_QUIET_TIMEOUT value Resolution of this parameter is selected by SSINACTIVE_QUIET_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 13*1us =~12us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
#define IMX_USB3_USBSS_CFG_REG6_SSINACTIVE_QUIET_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG6_SSINACTIVE_QUIET_TIMEOUT_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG6_SSINACTIVE_QUIET_TIMEOUT(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG6_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG6_RESERVED_MASK 0x3FFFFF00
#define IMX_USB3_USBSS_CFG_REG6_RESERVED(v) (((v) << 0x8) & 0x3FFFFF00)
/* Field SSINACTIVE_QUIET_TIMEOUT_PRESCALE - PRESCALER for SSINACTIVE_QUIET_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG6_SSINACTIVE_QUIET_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG6_SSINACTIVE_QUIET_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG6_SSINACTIVE_QUIET_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG7 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG7_union_t {
    uint32_t R;
    struct {
        uint32_t POLLING_LFPS_TIMEOUT :13;       /* POLLING_LFPS_TIMEOUT value Resolution of this parameter is selected by POLLING_LFPS_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 481*1us =~480us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 3601*100us =~360ms */
        uint32_t RESERVED    :17;                /* Reserved field. Write ignored. 0 when read */
        uint32_t POLLING_LFPS_TIMEOUT_PRESCALE :2; /* PRESCALER for POLLING_LFPS_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG7_t;

/* Register CFG_REG7 - USB3. */
#define IMX_USB3_USBSS_CFG_REG7_OFFSET 0x20118
/* Field POLLING_LFPS_TIMEOUT - POLLING_LFPS_TIMEOUT value Resolution of this parameter is selected by POLLING_LFPS_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 481*1us =~480us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 3601*100us =~360ms */
#define IMX_USB3_USBSS_CFG_REG7_POLLING_LFPS_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG7_POLLING_LFPS_TIMEOUT_MASK 0x1FFF
#define IMX_USB3_USBSS_CFG_REG7_POLLING_LFPS_TIMEOUT(v) (((v) << 0) & 0x1FFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG7_RESERVED_SHIFT 13
#define IMX_USB3_USBSS_CFG_REG7_RESERVED_MASK 0x3FFFE000
#define IMX_USB3_USBSS_CFG_REG7_RESERVED(v) (((v) << 0xD) & 0x3FFFE000)
/* Field POLLING_LFPS_TIMEOUT_PRESCALE - PRESCALER for POLLING_LFPS_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG7_POLLING_LFPS_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG7_POLLING_LFPS_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG7_POLLING_LFPS_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG8 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG8_union_t {
    uint32_t R;
    struct {
        uint32_t POLLING_ACTIVE_TIMEOUT :10;     /* POLLING_ACTIVE_TIMEOUT value Resolution of this parameter is selected by POLLING_ACTIVE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 31*1us =~30us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
        uint32_t RESERVED    :20;                /* Reserved field. Write ignored. 0 when read */
        uint32_t POLLING_ACTIVE_TIMEOUT_PRESCALE :2; /* PRESCALER for POLLING_ACTIVE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG8_t;

/* Register CFG_REG8 - USB3. */
#define IMX_USB3_USBSS_CFG_REG8_OFFSET 0x2011C
/* Field POLLING_ACTIVE_TIMEOUT - POLLING_ACTIVE_TIMEOUT value Resolution of this parameter is selected by POLLING_ACTIVE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 31*1us =~30us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
#define IMX_USB3_USBSS_CFG_REG8_POLLING_ACTIVE_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG8_POLLING_ACTIVE_TIMEOUT_MASK 0x3FF
#define IMX_USB3_USBSS_CFG_REG8_POLLING_ACTIVE_TIMEOUT(v) (((v) << 0) & 0x3FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG8_RESERVED_SHIFT 10
#define IMX_USB3_USBSS_CFG_REG8_RESERVED_MASK 0x3FFFFC00
#define IMX_USB3_USBSS_CFG_REG8_RESERVED(v) (((v) << 0xA) & 0x3FFFFC00)
/* Field POLLING_ACTIVE_TIMEOUT_PRESCALE - PRESCALER for POLLING_ACTIVE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG8_POLLING_ACTIVE_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG8_POLLING_ACTIVE_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG8_POLLING_ACTIVE_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG9 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG9_union_t {
    uint32_t R;
    struct {
        uint32_t POLLING_IDLE_TIMEOUT :5;        /* POLLING_IDLE_TIMEOUT value Resolution of this parameter is selected by POLLING_IDLE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 21*100us =~2ms (SystemC device ENV) - 3*1us =~2us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 21*100us =~2ms */
        uint32_t RESERVED    :25;                /* Reserved field. Write ignored. 0 when read */
        uint32_t POLLING_IDLE_TIMEOUT_PRESCALE :2; /* PRESCALER for POLLING_IDLE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG9_t;

/* Register CFG_REG9 - USB3. */
#define IMX_USB3_USBSS_CFG_REG9_OFFSET 0x20120
/* Field POLLING_IDLE_TIMEOUT - POLLING_IDLE_TIMEOUT value Resolution of this parameter is selected by POLLING_IDLE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 21*100us =~2ms (SystemC device ENV) - 3*1us =~2us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 21*100us =~2ms */
#define IMX_USB3_USBSS_CFG_REG9_POLLING_IDLE_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG9_POLLING_IDLE_TIMEOUT_MASK 0x1F
#define IMX_USB3_USBSS_CFG_REG9_POLLING_IDLE_TIMEOUT(v) (((v) << 0) & 0x1F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG9_RESERVED_SHIFT 5
#define IMX_USB3_USBSS_CFG_REG9_RESERVED_MASK 0x3FFFFFE0
#define IMX_USB3_USBSS_CFG_REG9_RESERVED(v) (((v) << 0x5) & 0x3FFFFFE0)
/* Field POLLING_IDLE_TIMEOUT_PRESCALE - PRESCALER for POLLING_IDLE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG9_POLLING_IDLE_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG9_POLLING_IDLE_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG9_POLLING_IDLE_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG10 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG10_union_t {
    uint32_t R;
    struct {
        uint32_t POLLING_CONF_TIMEOUT :8;        /* POLLING_CONF_TIMEOUT value Resolution of this parameter is selected by POLLING_CONF_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 31*1us =~30us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
        uint32_t RESERVED    :22;                /* Reserved field. Write ignored. 0 when read */
        uint32_t POLLING_CONF_TIMEOUT_PRESCALE :2; /* PRESCALER for POLLING_CONF_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG10_t;

/* Register CFG_REG10 - USB3. */
#define IMX_USB3_USBSS_CFG_REG10_OFFSET 0x20124
/* Field POLLING_CONF_TIMEOUT - POLLING_CONF_TIMEOUT value Resolution of this parameter is selected by POLLING_CONF_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 31*1us =~30us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
#define IMX_USB3_USBSS_CFG_REG10_POLLING_CONF_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG10_POLLING_CONF_TIMEOUT_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG10_POLLING_CONF_TIMEOUT(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG10_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG10_RESERVED_MASK 0x3FFFFF00
#define IMX_USB3_USBSS_CFG_REG10_RESERVED(v) (((v) << 0x8) & 0x3FFFFF00)
/* Field POLLING_CONF_TIMEOUT_PRESCALE - PRESCALER for POLLING_CONF_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG10_POLLING_CONF_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG10_POLLING_CONF_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG10_POLLING_CONF_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG11 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG11_union_t {
    uint32_t R;
    struct {
        uint32_t RECOVERY_ACTIVE_TIMEOUT :8;     /* RECOVERY_ACTIVE_TIMEOUT value Resolution of this parameter is selected by RECOVERY_ACTIVE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 101*1us =~100us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
        uint32_t RESERVED    :22;                /* Reserved field. Write ignored. 0 when read */
        uint32_t RECOVERY_ACTIVE_TIMEOUT_PRESCALE :2; /* PRESCALER for RECOVERY_ACTIVE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG11_t;

/* Register CFG_REG11 - USB3. */
#define IMX_USB3_USBSS_CFG_REG11_OFFSET 0x20128
/* Field RECOVERY_ACTIVE_TIMEOUT - RECOVERY_ACTIVE_TIMEOUT value Resolution of this parameter is selected by RECOVERY_ACTIVE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 101*1us =~100us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
#define IMX_USB3_USBSS_CFG_REG11_RECOVERY_ACTIVE_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG11_RECOVERY_ACTIVE_TIMEOUT_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG11_RECOVERY_ACTIVE_TIMEOUT(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG11_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG11_RESERVED_MASK 0x3FFFFF00
#define IMX_USB3_USBSS_CFG_REG11_RESERVED(v) (((v) << 0x8) & 0x3FFFFF00)
/* Field RECOVERY_ACTIVE_TIMEOUT_PRESCALE - PRESCALER for RECOVERY_ACTIVE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG11_RECOVERY_ACTIVE_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG11_RECOVERY_ACTIVE_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG11_RECOVERY_ACTIVE_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG12 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG12_union_t {
    uint32_t R;
    struct {
        uint32_t RECOVERY_CONF_TIMEOUT :8;       /* RECOVERY_CONF_TIMEOUT value Resolution of this parameter is selected by RECOVERY_CONF_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 101*1us =~100us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 61*100us =~6ms */
        uint32_t RESERVED    :22;                /* Reserved field. Write ignored. 0 when read */
        uint32_t RECOVERY_CONF_TIMEOUT_PRESCALE :2; /* PRESCALER for RECOVERY_CONF_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG12_t;

/* Register CFG_REG12 - USB3. */
#define IMX_USB3_USBSS_CFG_REG12_OFFSET 0x2012C
/* Field RECOVERY_CONF_TIMEOUT - RECOVERY_CONF_TIMEOUT value Resolution of this parameter is selected by RECOVERY_CONF_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 101*1us =~100us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 61*100us =~6ms */
#define IMX_USB3_USBSS_CFG_REG12_RECOVERY_CONF_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG12_RECOVERY_CONF_TIMEOUT_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG12_RECOVERY_CONF_TIMEOUT(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG12_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG12_RESERVED_MASK 0x3FFFFF00
#define IMX_USB3_USBSS_CFG_REG12_RESERVED(v) (((v) << 0x8) & 0x3FFFFF00)
/* Field RECOVERY_CONF_TIMEOUT_PRESCALE - PRESCALER for RECOVERY_CONF_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG12_RECOVERY_CONF_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG12_RECOVERY_CONF_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG12_RECOVERY_CONF_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG13 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG13_union_t {
    uint32_t R;
    struct {
        uint32_t RECOVERY_IDLE_TIMEOUT :5;       /* RECOVERY_IDLE_TIMEOUT value Resolution of this parameter is selected by RECOVERY_IDLE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 21*100us =~2ms (SystemC device ENV) - 3*1us =~3us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 21*100us =~2ms */
        uint32_t RESERVED    :23;                /* Reserved field. Write ignored. 0 when read */
        uint32_t _unused28   :2;
        uint32_t RECOVERY_IDLE_TIMEOUT_PRESCALE :2; /* PRESCALER for RECOVERY_IDLE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG13_t;

/* Register CFG_REG13 - USB3. */
#define IMX_USB3_USBSS_CFG_REG13_OFFSET 0x20130
/* Field RECOVERY_IDLE_TIMEOUT - RECOVERY_IDLE_TIMEOUT value Resolution of this parameter is selected by RECOVERY_IDLE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 21*100us =~2ms (SystemC device ENV) - 3*1us =~3us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 21*100us =~2ms */
#define IMX_USB3_USBSS_CFG_REG13_RECOVERY_IDLE_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG13_RECOVERY_IDLE_TIMEOUT_MASK 0x1F
#define IMX_USB3_USBSS_CFG_REG13_RECOVERY_IDLE_TIMEOUT(v) (((v) << 0) & 0x1F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG13_RESERVED_SHIFT 5
#define IMX_USB3_USBSS_CFG_REG13_RESERVED_MASK 0xFFFFFE0
#define IMX_USB3_USBSS_CFG_REG13_RESERVED(v) (((v) << 0x5) & 0xFFFFFE0)
/* Field RECOVERY_IDLE_TIMEOUT_PRESCALE - PRESCALER for RECOVERY_IDLE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG13_RECOVERY_IDLE_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG13_RECOVERY_IDLE_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG13_RECOVERY_IDLE_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG14 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG14_union_t {
    uint32_t R;
    struct {
        uint32_t HOTRESET_ACTIVE_TIMEOUT :8;     /* HOTRESET_ACTIVE_TIMEOUT value Resolution of this parameter is selected by HOTRESET_ACTIVE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 21*100us =~2ms (SystemC device ENV) - 13*1us =~13us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
        uint32_t RESERVED    :22;                /* Reserved field. Write ignored. 0 when read */
        uint32_t HOTRESET_ACTIVE_TIMEOUT_PRESCALE :2; /* PRESCALER for HOTRESET_ACTIVE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG14_t;

/* Register CFG_REG14 - USB3. */
#define IMX_USB3_USBSS_CFG_REG14_OFFSET 0x20134
/* Field HOTRESET_ACTIVE_TIMEOUT - HOTRESET_ACTIVE_TIMEOUT value Resolution of this parameter is selected by HOTRESET_ACTIVE_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 21*100us =~2ms (SystemC device ENV) - 13*1us =~13us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 121*100us =~12ms */
#define IMX_USB3_USBSS_CFG_REG14_HOTRESET_ACTIVE_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG14_HOTRESET_ACTIVE_TIMEOUT_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG14_HOTRESET_ACTIVE_TIMEOUT(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG14_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG14_RESERVED_MASK 0x3FFFFF00
#define IMX_USB3_USBSS_CFG_REG14_RESERVED(v) (((v) << 0x8) & 0x3FFFFF00)
/* Field HOTRESET_ACTIVE_TIMEOUT_PRESCALE - PRESCALER for HOTRESET_ACTIVE_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG14_HOTRESET_ACTIVE_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG14_HOTRESET_ACTIVE_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG14_HOTRESET_ACTIVE_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG15 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG15_union_t {
    uint32_t R;
    struct {
        uint32_t HOTRESET_EXIT_TIMEOUT :5;       /* HOTRESET_EXIT_TIMEOUT value Resolution of this parameter is selected by HOTRESET_EXIT_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 21*100us =~2ms (SystemC device ENV) - 3*1us =~3us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 21*100us =~2ms */
        uint32_t RESERVED    :25;                /* Reserved field. Write ignored. 0 when read */
        uint32_t HOTRESET_EXIT_TIMEOUT_PRESCALE :2; /* PRESCALER for HOTRESET_EXIT_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG15_t;

/* Register CFG_REG15 - USB3. */
#define IMX_USB3_USBSS_CFG_REG15_OFFSET 0x20138
/* Field HOTRESET_EXIT_TIMEOUT - HOTRESET_EXIT_TIMEOUT value Resolution of this parameter is selected by HOTRESET_EXIT_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 21*100us =~2ms (SystemC device ENV) - 3*1us =~3us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 21*100us =~2ms */
#define IMX_USB3_USBSS_CFG_REG15_HOTRESET_EXIT_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG15_HOTRESET_EXIT_TIMEOUT_MASK 0x1F
#define IMX_USB3_USBSS_CFG_REG15_HOTRESET_EXIT_TIMEOUT(v) (((v) << 0) & 0x1F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG15_RESERVED_SHIFT 5
#define IMX_USB3_USBSS_CFG_REG15_RESERVED_MASK 0x3FFFFFE0
#define IMX_USB3_USBSS_CFG_REG15_RESERVED(v) (((v) << 0x5) & 0x3FFFFFE0)
/* Field HOTRESET_EXIT_TIMEOUT_PRESCALE - PRESCALER for HOTRESET_EXIT_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG15_HOTRESET_EXIT_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG15_HOTRESET_EXIT_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG15_HOTRESET_EXIT_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG16 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG16_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_PING_REPEAT :12;           /* LFPS_PING_REPEAT value Resolution of this parameter is selected by LFPS_PING_REPEAT_PRESCALE. For simulation purposes it is recommended to set the value: - 6*100us =~0.5ms (SystemC device ENV) - 4*100us =~400us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 2001*100us =~200ms */
        uint32_t RESERVED    :18;                /* Reserved field. Write ignored. 0 when read */
        uint32_t LFPS_PING_REPEAT_PRESCALE :2;   /* PRESCALER for LFPS_PING_REPEAT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG16_t;

/* Register CFG_REG16 - USB3. */
#define IMX_USB3_USBSS_CFG_REG16_OFFSET 0x2013C
/* Field LFPS_PING_REPEAT - LFPS_PING_REPEAT value Resolution of this parameter is selected by LFPS_PING_REPEAT_PRESCALE. For simulation purposes it is recommended to set the value: - 6*100us =~0.5ms (SystemC device ENV) - 4*100us =~400us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 2001*100us =~200ms */
#define IMX_USB3_USBSS_CFG_REG16_LFPS_PING_REPEAT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG16_LFPS_PING_REPEAT_MASK 0xFFF
#define IMX_USB3_USBSS_CFG_REG16_LFPS_PING_REPEAT(v) (((v) << 0) & 0xFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG16_RESERVED_SHIFT 12
#define IMX_USB3_USBSS_CFG_REG16_RESERVED_MASK 0x3FFFF000
#define IMX_USB3_USBSS_CFG_REG16_RESERVED(v) (((v) << 0xC) & 0x3FFFF000)
/* Field LFPS_PING_REPEAT_PRESCALE - PRESCALER for LFPS_PING_REPEAT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG16_LFPS_PING_REPEAT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG16_LFPS_PING_REPEAT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG16_LFPS_PING_REPEAT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG17 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG17_union_t {
    uint32_t R;
    struct {
        uint32_t PENDING_HP_TIMEOUT :10;         /* PENDING_HP_TIMEOUT value Resolution of this parameter is selected by PENDING_HP_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 437*8ns =~3.5us (SystemC device ENV) - 437*8ns =~3.5us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 437*8ns =~3.5us */
        uint32_t RESERVED    :20;                /* Reserved field. Write ignored. 0 when read */
        uint32_t PENDING_HP_TIMEOUT_PRESCALE :2; /* PRESCALER for PENDING_HP_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG17_t;

/* Register CFG_REG17 - USB3. */
#define IMX_USB3_USBSS_CFG_REG17_OFFSET 0x20140
/* Field PENDING_HP_TIMEOUT - PENDING_HP_TIMEOUT value Resolution of this parameter is selected by PENDING_HP_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 437*8ns =~3.5us (SystemC device ENV) - 437*8ns =~3.5us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 437*8ns =~3.5us */
#define IMX_USB3_USBSS_CFG_REG17_PENDING_HP_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG17_PENDING_HP_TIMEOUT_MASK 0x3FF
#define IMX_USB3_USBSS_CFG_REG17_PENDING_HP_TIMEOUT(v) (((v) << 0) & 0x3FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG17_RESERVED_SHIFT 10
#define IMX_USB3_USBSS_CFG_REG17_RESERVED_MASK 0x3FFFFC00
#define IMX_USB3_USBSS_CFG_REG17_RESERVED(v) (((v) << 0xA) & 0x3FFFFC00)
/* Field PENDING_HP_TIMEOUT_PRESCALE - PRESCALER for PENDING_HP_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG17_PENDING_HP_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG17_PENDING_HP_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG17_PENDING_HP_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG18 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG18_union_t {
    uint32_t R;
    struct {
        uint32_t CREDIT_HP_TIMEOUT :7;           /* CREDIT_HP_TIMEOUT value Resolution of this parameter is selected by CREDIT_HP_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 11*100us =~1ms (VIP based ENV) For synthesis purposes it is recommended to set the value: - 52*100us =~5.1ms */
        uint32_t RESERVED    :23;                /* Reserved field. Write ignored. 0 when read */
        uint32_t CREDIT_HP_TIMEOUT_PRESCALE :2;  /* PRESCALER for CREDIT_HP_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG18_t;

/* Register CFG_REG18 - USB3. */
#define IMX_USB3_USBSS_CFG_REG18_OFFSET 0x20144
/* Field CREDIT_HP_TIMEOUT - CREDIT_HP_TIMEOUT value Resolution of this parameter is selected by CREDIT_HP_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 11*100us =~1ms (VIP based ENV) For synthesis purposes it is recommended to set the value: - 52*100us =~5.1ms */
#define IMX_USB3_USBSS_CFG_REG18_CREDIT_HP_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG18_CREDIT_HP_TIMEOUT_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG18_CREDIT_HP_TIMEOUT(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG18_RESERVED_SHIFT 7
#define IMX_USB3_USBSS_CFG_REG18_RESERVED_MASK 0x3FFFFF80
#define IMX_USB3_USBSS_CFG_REG18_RESERVED(v) (((v) << 0x7) & 0x3FFFFF80)
/* Field CREDIT_HP_TIMEOUT_PRESCALE - PRESCALER for CREDIT_HP_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG18_CREDIT_HP_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG18_CREDIT_HP_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG18_CREDIT_HP_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG19 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG19_union_t {
    uint32_t R;
    struct {
        uint32_t LUP_TIMEOUT :10;                /* LUP_TIMEOUT value Resolution of this parameter is selected by LUP_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*1us =~11us (SystemC device ENV) - 11*1us =~11us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 11*1us =~11us */
        uint32_t RESERVED    :20;                /* Reserved field. Write ignored. 0 when read */
        uint32_t LUP_TIMEOUT_PRESCALE :2;        /* PRESCALER for LUP_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG19_t;

/* Register CFG_REG19 - USB3. */
#define IMX_USB3_USBSS_CFG_REG19_OFFSET 0x20148
/* Field LUP_TIMEOUT - LUP_TIMEOUT value Resolution of this parameter is selected by LUP_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*1us =~11us (SystemC device ENV) - 11*1us =~11us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 11*1us =~11us */
#define IMX_USB3_USBSS_CFG_REG19_LUP_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG19_LUP_TIMEOUT_MASK 0x3FF
#define IMX_USB3_USBSS_CFG_REG19_LUP_TIMEOUT(v) (((v) << 0) & 0x3FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG19_RESERVED_SHIFT 10
#define IMX_USB3_USBSS_CFG_REG19_RESERVED_MASK 0x3FFFFC00
#define IMX_USB3_USBSS_CFG_REG19_RESERVED(v) (((v) << 0xA) & 0x3FFFFC00)
/* Field LUP_TIMEOUT_PRESCALE - PRESCALER for LUP_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG19_LUP_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG19_LUP_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG19_LUP_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG20 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG20_union_t {
    uint32_t R;
    struct {
        uint32_t LDN_TIMEOUT :8;                 /* LDN_TIMEOUT value Resolution of this parameter is selected by LDN_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 129*1us =~129us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 11*100us =~1ms */
        uint32_t RESERVED    :22;                /* Reserved field. Write ignored. 0 when read */
        uint32_t LDN_TIMEOUT_PRESCALE :2;        /* PRESCALER for LDN_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG20_t;

/* Register CFG_REG20 - USB3. */
#define IMX_USB3_USBSS_CFG_REG20_OFFSET 0x2014C
/* Field LDN_TIMEOUT - LDN_TIMEOUT value Resolution of this parameter is selected by LDN_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 11*100us =~1ms (SystemC device ENV) - 129*1us =~129us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 11*100us =~1ms */
#define IMX_USB3_USBSS_CFG_REG20_LDN_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG20_LDN_TIMEOUT_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG20_LDN_TIMEOUT(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG20_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG20_RESERVED_MASK 0x3FFFFF00
#define IMX_USB3_USBSS_CFG_REG20_RESERVED(v) (((v) << 0x8) & 0x3FFFFF00)
/* Field LDN_TIMEOUT_PRESCALE - PRESCALER for LDN_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG20_LDN_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG20_LDN_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG20_LDN_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG21 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG21_union_t {
    uint32_t R;
    struct {
        uint32_t PM_LC_TIMEOUT :10;              /* PM_LC_TIMEOUT value Resolution of this parameter is selected by PM_LC_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 400*8ns =~3.2us (SystemC device ENV) - 400*8ns =~3.2us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 400*8ns =~3.2us */
        uint32_t RESERVED    :20;                /* Reserved field. Write ignored. 0 when read */
        uint32_t PM_LC_TIMEOUT_PRESCALE :2;      /* PRESCALER for PM_LC_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG21_t;

/* Register CFG_REG21 - USB3. */
#define IMX_USB3_USBSS_CFG_REG21_OFFSET 0x20150
/* Field PM_LC_TIMEOUT - PM_LC_TIMEOUT value Resolution of this parameter is selected by PM_LC_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 400*8ns =~3.2us (SystemC device ENV) - 400*8ns =~3.2us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 400*8ns =~3.2us */
#define IMX_USB3_USBSS_CFG_REG21_PM_LC_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG21_PM_LC_TIMEOUT_MASK 0x3FF
#define IMX_USB3_USBSS_CFG_REG21_PM_LC_TIMEOUT(v) (((v) << 0) & 0x3FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG21_RESERVED_SHIFT 10
#define IMX_USB3_USBSS_CFG_REG21_RESERVED_MASK 0x3FFFFC00
#define IMX_USB3_USBSS_CFG_REG21_RESERVED(v) (((v) << 0xA) & 0x3FFFFC00)
/* Field PM_LC_TIMEOUT_PRESCALE - PRESCALER for PM_LC_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG21_PM_LC_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG21_PM_LC_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG21_PM_LC_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG22 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG22_union_t {
    uint32_t R;
    struct {
        uint32_t PM_ENTRY_TIMEOUT :11;           /* PM_ENTRY_TIMEOUT value Resolution of this parameter is selected by PM_ENTRY_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 800*8ns =~6.4us (SystemC device ENV) - 800*8ns =~6.4us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 800*8ns =~6.4us */
        uint32_t RESERVED    :19;                /* Reserved field. Write ignored. 0 when read */
        uint32_t PM_ENTRY_TIMEOUT_PRESCALE :2;   /* PRESCALER for PM_ENTRY_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG22_t;

/* Register CFG_REG22 - USB3. */
#define IMX_USB3_USBSS_CFG_REG22_OFFSET 0x20154
/* Field PM_ENTRY_TIMEOUT - PM_ENTRY_TIMEOUT value Resolution of this parameter is selected by PM_ENTRY_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 800*8ns =~6.4us (SystemC device ENV) - 800*8ns =~6.4us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 800*8ns =~6.4us */
#define IMX_USB3_USBSS_CFG_REG22_PM_ENTRY_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG22_PM_ENTRY_TIMEOUT_MASK 0x7FF
#define IMX_USB3_USBSS_CFG_REG22_PM_ENTRY_TIMEOUT(v) (((v) << 0) & 0x7FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG22_RESERVED_SHIFT 11
#define IMX_USB3_USBSS_CFG_REG22_RESERVED_MASK 0x3FFFF800
#define IMX_USB3_USBSS_CFG_REG22_RESERVED(v) (((v) << 0xB) & 0x3FFFF800)
/* Field PM_ENTRY_TIMEOUT_PRESCALE - PRESCALER for PM_ENTRY_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG22_PM_ENTRY_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG22_PM_ENTRY_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG22_PM_ENTRY_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG23 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG23_union_t {
    uint32_t R;
    struct {
        uint32_t UX_EXIT_TIMEOUT :7;             /* UX_EXIT_TIMEOUT value Resolution of this parameter is selected by UX_EXIT_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 8*100us =~800us (SystemC device ENV) - 3*100us =~300us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 62*100us =~6.2ms */
        uint32_t RESERVED    :23;                /* Reserved field. Write ignored. 0 when read */
        uint32_t UX_EXIT_TIMEOUT_PRESCALE :2;    /* PRESCALER for UX_EXIT_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG23_t;

/* Register CFG_REG23 - USB3. */
#define IMX_USB3_USBSS_CFG_REG23_OFFSET 0x20158
/* Field UX_EXIT_TIMEOUT - UX_EXIT_TIMEOUT value Resolution of this parameter is selected by UX_EXIT_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 8*100us =~800us (SystemC device ENV) - 3*100us =~300us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 62*100us =~6.2ms */
#define IMX_USB3_USBSS_CFG_REG23_UX_EXIT_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG23_UX_EXIT_TIMEOUT_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG23_UX_EXIT_TIMEOUT(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG23_RESERVED_SHIFT 7
#define IMX_USB3_USBSS_CFG_REG23_RESERVED_MASK 0x3FFFFF80
#define IMX_USB3_USBSS_CFG_REG23_RESERVED(v) (((v) << 0x7) & 0x3FFFFF80)
/* Field UX_EXIT_TIMEOUT_PRESCALE - PRESCALER for UX_EXIT_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG23_UX_EXIT_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG23_UX_EXIT_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG23_UX_EXIT_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG24 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG24_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_RESET_MIN :23;         /* LFPS_DET_RESET_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 395833 (~3.16ms) For synthesis purposes it is recommended to set the value 2375000 (~19ms) */
        uint32_t RESERVED    :9;                 /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG24_t;

/* Register CFG_REG24 - USB3. */
#define IMX_USB3_USBSS_CFG_REG24_OFFSET 0x2015C
/* Field LFPS_DET_RESET_MIN - LFPS_DET_RESET_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 395833 (~3.16ms) For synthesis purposes it is recommended to set the value 2375000 (~19ms) */
#define IMX_USB3_USBSS_CFG_REG24_LFPS_DET_RESET_MIN_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG24_LFPS_DET_RESET_MIN_MASK 0x7FFFFF
#define IMX_USB3_USBSS_CFG_REG24_LFPS_DET_RESET_MIN(v) (((v) << 0) & 0x7FFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG24_RESERVED_SHIFT 23
#define IMX_USB3_USBSS_CFG_REG24_RESERVED_MASK 0xFF800000
#define IMX_USB3_USBSS_CFG_REG24_RESERVED(v) (((v) << 0x17) & 0xFF800000)

/* IMX_USB3_USBSS_CFG_REG25 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG25_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_RESET_MAX :24;         /* LFPS_DET_RESET_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 5000000 (~40ms) For synthesis purposes it is recommended to set the value 15000000 (~120ms) */
        uint32_t RESERVED    :8;                 /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG25_t;

/* Register CFG_REG25 - USB3. */
#define IMX_USB3_USBSS_CFG_REG25_OFFSET 0x20160
/* Field LFPS_DET_RESET_MAX - LFPS_DET_RESET_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 5000000 (~40ms) For synthesis purposes it is recommended to set the value 15000000 (~120ms) */
#define IMX_USB3_USBSS_CFG_REG25_LFPS_DET_RESET_MAX_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG25_LFPS_DET_RESET_MAX_MASK 0xFFFFFF
#define IMX_USB3_USBSS_CFG_REG25_LFPS_DET_RESET_MAX(v) (((v) << 0) & 0xFFFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG25_RESERVED_SHIFT 24
#define IMX_USB3_USBSS_CFG_REG25_RESERVED_MASK 0xFF000000
#define IMX_USB3_USBSS_CFG_REG25_RESERVED(v) (((v) << 0x18) & 0xFF000000)

/* IMX_USB3_USBSS_CFG_REG26 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG26_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_POLLING_MIN :7;        /* LFPS_DET_POLLING_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 75 (~0.6us) For synthesis purposes it is recommended to set the value 75 (~0.6us) */
        uint32_t RESERVED    :25;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG26_t;

/* Register CFG_REG26 - USB3. */
#define IMX_USB3_USBSS_CFG_REG26_OFFSET 0x20164
/* Field LFPS_DET_POLLING_MIN - LFPS_DET_POLLING_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 75 (~0.6us) For synthesis purposes it is recommended to set the value 75 (~0.6us) */
#define IMX_USB3_USBSS_CFG_REG26_LFPS_DET_POLLING_MIN_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG26_LFPS_DET_POLLING_MIN_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG26_LFPS_DET_POLLING_MIN(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG26_RESERVED_SHIFT 7
#define IMX_USB3_USBSS_CFG_REG26_RESERVED_MASK 0xFFFFFF80
#define IMX_USB3_USBSS_CFG_REG26_RESERVED(v) (((v) << 0x7) & 0xFFFFFF80)

/* IMX_USB3_USBSS_CFG_REG27 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG27_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_POLLING_MAX :8;        /* LFPS_DET_POLLING_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 175 (~1.4us) For synthesis purposes it is recommended to set the value 175 (~1.4us) */
        uint32_t RESERVED    :24;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG27_t;

/* Register CFG_REG27 - USB3. */
#define IMX_USB3_USBSS_CFG_REG27_OFFSET 0x20168
/* Field LFPS_DET_POLLING_MAX - LFPS_DET_POLLING_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 175 (~1.4us) For synthesis purposes it is recommended to set the value 175 (~1.4us) */
#define IMX_USB3_USBSS_CFG_REG27_LFPS_DET_POLLING_MAX_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG27_LFPS_DET_POLLING_MAX_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG27_LFPS_DET_POLLING_MAX(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG27_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG27_RESERVED_MASK 0xFFFFFF00
#define IMX_USB3_USBSS_CFG_REG27_RESERVED(v) (((v) << 0x8) & 0xFFFFFF00)

/* IMX_USB3_USBSS_CFG_REG28 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG28_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_PING_MIN :3;           /* LFPS_DET_PING_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 4 (~40ns) For synthesis purposes it is recommended to set the value 4 (~40ns) */
        uint32_t RESERVED    :29;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG28_t;

/* Register CFG_REG28 - USB3. */
#define IMX_USB3_USBSS_CFG_REG28_OFFSET 0x2016C
/* Field LFPS_DET_PING_MIN - LFPS_DET_PING_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 4 (~40ns) For synthesis purposes it is recommended to set the value 4 (~40ns) */
#define IMX_USB3_USBSS_CFG_REG28_LFPS_DET_PING_MIN_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG28_LFPS_DET_PING_MIN_MASK 0x7
#define IMX_USB3_USBSS_CFG_REG28_LFPS_DET_PING_MIN(v) (((v) << 0) & 0x7)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG28_RESERVED_SHIFT 3
#define IMX_USB3_USBSS_CFG_REG28_RESERVED_MASK 0xFFFFFFF8
#define IMX_USB3_USBSS_CFG_REG28_RESERVED(v) (((v) << 0x3) & 0xFFFFFFF8)

/* IMX_USB3_USBSS_CFG_REG29 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG29_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_PING_MAX :5;           /* LFPS_DET_PING_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 23 (~200ns) For synthesis purposes it is recommended to set the value 23 (~200ns) */
        uint32_t RESERVED    :27;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG29_t;

/* Register CFG_REG29 - USB3. */
#define IMX_USB3_USBSS_CFG_REG29_OFFSET 0x20170
/* Field LFPS_DET_PING_MAX - LFPS_DET_PING_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 23 (~200ns) For synthesis purposes it is recommended to set the value 23 (~200ns) */
#define IMX_USB3_USBSS_CFG_REG29_LFPS_DET_PING_MAX_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG29_LFPS_DET_PING_MAX_MASK 0x1F
#define IMX_USB3_USBSS_CFG_REG29_LFPS_DET_PING_MAX(v) (((v) << 0) & 0x1F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG29_RESERVED_SHIFT 5
#define IMX_USB3_USBSS_CFG_REG29_RESERVED_MASK 0xFFFFFFE0
#define IMX_USB3_USBSS_CFG_REG29_RESERVED(v) (((v) << 0x5) & 0xFFFFFFE0)

/* IMX_USB3_USBSS_CFG_REG30 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG30_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_U1EXIT_MIN :6;         /* LFPS_DET_U1EXIT_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 36 (~300ns) For synthesis purposes it is recommended to set the value 36 (~300ns) */
        uint32_t RESERVED    :26;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG30_t;

/* Register CFG_REG30 - USB3. */
#define IMX_USB3_USBSS_CFG_REG30_OFFSET 0x20174
/* Field LFPS_DET_U1EXIT_MIN - LFPS_DET_U1EXIT_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 36 (~300ns) For synthesis purposes it is recommended to set the value 36 (~300ns) */
#define IMX_USB3_USBSS_CFG_REG30_LFPS_DET_U1EXIT_MIN_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG30_LFPS_DET_U1EXIT_MIN_MASK 0x3F
#define IMX_USB3_USBSS_CFG_REG30_LFPS_DET_U1EXIT_MIN(v) (((v) << 0) & 0x3F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG30_RESERVED_SHIFT 6
#define IMX_USB3_USBSS_CFG_REG30_RESERVED_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_CFG_REG30_RESERVED(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_CFG_REG31 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG31_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_U1EXIT_MAX :7;         /* LFPS_DET_U1EXIT_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 111 (~900ns) For synthesis purposes it is recommended to set the value 111 (~900ns) */
        uint32_t RESERVED    :25;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG31_t;

/* Register CFG_REG31 - USB3. */
#define IMX_USB3_USBSS_CFG_REG31_OFFSET 0x20178
/* Field LFPS_DET_U1EXIT_MAX - LFPS_DET_U1EXIT_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 111 (~900ns) For synthesis purposes it is recommended to set the value 111 (~900ns) */
#define IMX_USB3_USBSS_CFG_REG31_LFPS_DET_U1EXIT_MAX_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG31_LFPS_DET_U1EXIT_MAX_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG31_LFPS_DET_U1EXIT_MAX(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG31_RESERVED_SHIFT 7
#define IMX_USB3_USBSS_CFG_REG31_RESERVED_MASK 0xFFFFFF80
#define IMX_USB3_USBSS_CFG_REG31_RESERVED(v) (((v) << 0x7) & 0xFFFFFF80)

/* IMX_USB3_USBSS_CFG_REG32 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG32_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_U2EXIT_MIN :6;         /* LFPS_DET_U2EXIT_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 36 (~300ns) For synthesis purposes it is recommended to set the value 36 (~300ns) */
        uint32_t RESERVED    :26;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG32_t;

/* Register CFG_REG32 - USB3. */
#define IMX_USB3_USBSS_CFG_REG32_OFFSET 0x2017C
/* Field LFPS_DET_U2EXIT_MIN - LFPS_DET_U2EXIT_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 36 (~300ns) For synthesis purposes it is recommended to set the value 36 (~300ns) */
#define IMX_USB3_USBSS_CFG_REG32_LFPS_DET_U2EXIT_MIN_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG32_LFPS_DET_U2EXIT_MIN_MASK 0x3F
#define IMX_USB3_USBSS_CFG_REG32_LFPS_DET_U2EXIT_MIN(v) (((v) << 0) & 0x3F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG32_RESERVED_SHIFT 6
#define IMX_USB3_USBSS_CFG_REG32_RESERVED_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_CFG_REG32_RESERVED(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_CFG_REG33 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG33_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_U2EXIT_MAX :18;        /* LFPS_DET_U2EXIT_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 250000 (~2ms) For synthesis purposes it is recommended to set the value 250000 (~2ms) */
        uint32_t RESERVED    :14;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG33_t;

/* Register CFG_REG33 - USB3. */
#define IMX_USB3_USBSS_CFG_REG33_OFFSET 0x20180
/* Field LFPS_DET_U2EXIT_MAX - LFPS_DET_U2EXIT_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 250000 (~2ms) For synthesis purposes it is recommended to set the value 250000 (~2ms) */
#define IMX_USB3_USBSS_CFG_REG33_LFPS_DET_U2EXIT_MAX_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG33_LFPS_DET_U2EXIT_MAX_MASK 0x3FFFF
#define IMX_USB3_USBSS_CFG_REG33_LFPS_DET_U2EXIT_MAX(v) (((v) << 0) & 0x3FFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG33_RESERVED_SHIFT 18
#define IMX_USB3_USBSS_CFG_REG33_RESERVED_MASK 0xFFFC0000
#define IMX_USB3_USBSS_CFG_REG33_RESERVED(v) (((v) << 0x12) & 0xFFFC0000)

/* IMX_USB3_USBSS_CFG_REG34 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG34_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_U3EXIT_MIN :6;         /* LFPS_DET_U3EXIT_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 36 (~300ns) For synthesis purposes it is recommended to set the value 36 (~300ns) */
        uint32_t RESERVED    :26;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG34_t;

/* Register CFG_REG34 - USB3. */
#define IMX_USB3_USBSS_CFG_REG34_OFFSET 0x20184
/* Field LFPS_DET_U3EXIT_MIN - LFPS_DET_U3EXIT_MIN value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 36 (~300ns) For synthesis purposes it is recommended to set the value 36 (~300ns) */
#define IMX_USB3_USBSS_CFG_REG34_LFPS_DET_U3EXIT_MIN_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG34_LFPS_DET_U3EXIT_MIN_MASK 0x3F
#define IMX_USB3_USBSS_CFG_REG34_LFPS_DET_U3EXIT_MIN(v) (((v) << 0) & 0x3F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG34_RESERVED_SHIFT 6
#define IMX_USB3_USBSS_CFG_REG34_RESERVED_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_CFG_REG34_RESERVED(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_CFG_REG35 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG35_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DET_U3EXIT_MAX :21;        /* LFPS_DET_U3EXIT_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 1250000 (~10ms) For synthesis purposes it is recommended to set the value 1250000 (~10ms) */
        uint32_t RESERVED    :11;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG35_t;

/* Register CFG_REG35 - USB3. */
#define IMX_USB3_USBSS_CFG_REG35_OFFSET 0x20188
/* Field LFPS_DET_U3EXIT_MAX - LFPS_DET_U3EXIT_MAX value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 1250000 (~10ms) For synthesis purposes it is recommended to set the value 1250000 (~10ms) */
#define IMX_USB3_USBSS_CFG_REG35_LFPS_DET_U3EXIT_MAX_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG35_LFPS_DET_U3EXIT_MAX_MASK 0x1FFFFF
#define IMX_USB3_USBSS_CFG_REG35_LFPS_DET_U3EXIT_MAX(v) (((v) << 0) & 0x1FFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG35_RESERVED_SHIFT 21
#define IMX_USB3_USBSS_CFG_REG35_RESERVED_MASK 0xFFE00000
#define IMX_USB3_USBSS_CFG_REG35_RESERVED(v) (((v) << 0x15) & 0xFFE00000)

/* IMX_USB3_USBSS_CFG_REG36 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG36_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_GEN_PING :5;               /* LFPS_GEN_PING value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 24 (~200ns) For synthesis purposes it is recommended to set the value 24 (~200ns) */
        uint32_t RESERVED    :27;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG36_t;

/* Register CFG_REG36 - USB3. */
#define IMX_USB3_USBSS_CFG_REG36_OFFSET 0x201AC
/* Field LFPS_GEN_PING - LFPS_GEN_PING value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 24 (~200ns) For synthesis purposes it is recommended to set the value 24 (~200ns) */
#define IMX_USB3_USBSS_CFG_REG36_LFPS_GEN_PING_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG36_LFPS_GEN_PING_MASK 0x1F
#define IMX_USB3_USBSS_CFG_REG36_LFPS_GEN_PING(v) (((v) << 0) & 0x1F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG36_RESERVED_SHIFT 5
#define IMX_USB3_USBSS_CFG_REG36_RESERVED_MASK 0xFFFFFFE0
#define IMX_USB3_USBSS_CFG_REG36_RESERVED(v) (((v) << 0x5) & 0xFFFFFFE0)

/* IMX_USB3_USBSS_CFG_REG37 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG37_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_GEN_POLLING :8;            /* LFPS_GEN_POLLING value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 125 (~1us) For synthesis purposes it is recommended to set the value 125 (~1us) */
        uint32_t RESERVED    :24;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG37_t;

/* Register CFG_REG37 - USB3. */
#define IMX_USB3_USBSS_CFG_REG37_OFFSET 0x201B0
/* Field LFPS_GEN_POLLING - LFPS_GEN_POLLING value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 125 (~1us) For synthesis purposes it is recommended to set the value 125 (~1us) */
#define IMX_USB3_USBSS_CFG_REG37_LFPS_GEN_POLLING_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG37_LFPS_GEN_POLLING_MASK 0xFF
#define IMX_USB3_USBSS_CFG_REG37_LFPS_GEN_POLLING(v) (((v) << 0) & 0xFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG37_RESERVED_SHIFT 8
#define IMX_USB3_USBSS_CFG_REG37_RESERVED_MASK 0xFFFFFF00
#define IMX_USB3_USBSS_CFG_REG37_RESERVED(v) (((v) << 0x8) & 0xFFFFFF00)

/* IMX_USB3_USBSS_CFG_REG38 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG38_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_GEN_U1EXIT :18;            /* LFPS_GEN_U1EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 62500 (~500us) For synthesis purposes it is recommended to set the value 250000 (~2ms) */
        uint32_t RESERVED    :14;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG38_t;

/* Register CFG_REG38 - USB3. */
#define IMX_USB3_USBSS_CFG_REG38_OFFSET 0x201B4
/* Field LFPS_GEN_U1EXIT - LFPS_GEN_U1EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 62500 (~500us) For synthesis purposes it is recommended to set the value 250000 (~2ms) */
#define IMX_USB3_USBSS_CFG_REG38_LFPS_GEN_U1EXIT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG38_LFPS_GEN_U1EXIT_MASK 0x3FFFF
#define IMX_USB3_USBSS_CFG_REG38_LFPS_GEN_U1EXIT(v) (((v) << 0) & 0x3FFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG38_RESERVED_SHIFT 18
#define IMX_USB3_USBSS_CFG_REG38_RESERVED_MASK 0xFFFC0000
#define IMX_USB3_USBSS_CFG_REG38_RESERVED(v) (((v) << 0x12) & 0xFFFC0000)

/* IMX_USB3_USBSS_CFG_REG39 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG39_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_GEN_U3EXIT :21;            /* LFPS_GEN_U3EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 125000 (~1ms) For synthesis purposes it is recommended to set the value 1250000 (~10ms) */
        uint32_t RESERVED    :11;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG39_t;

/* Register CFG_REG39 - USB3. */
#define IMX_USB3_USBSS_CFG_REG39_OFFSET 0x201B8
/* Field LFPS_GEN_U3EXIT - LFPS_GEN_U3EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 125000 (~1ms) For synthesis purposes it is recommended to set the value 1250000 (~10ms) */
#define IMX_USB3_USBSS_CFG_REG39_LFPS_GEN_U3EXIT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG39_LFPS_GEN_U3EXIT_MASK 0x1FFFFF
#define IMX_USB3_USBSS_CFG_REG39_LFPS_GEN_U3EXIT(v) (((v) << 0) & 0x1FFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG39_RESERVED_SHIFT 21
#define IMX_USB3_USBSS_CFG_REG39_RESERVED_MASK 0xFFE00000
#define IMX_USB3_USBSS_CFG_REG39_RESERVED(v) (((v) << 0x15) & 0xFFE00000)

/* IMX_USB3_USBSS_CFG_REG40 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG40_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_MIN_GEN_U1EXIT :7;         /* LFPS_MIN_GEN_U1EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 87 (~696ns) For synthesis purposes it is recommended to set the value 87 (~696ns) */
        uint32_t RESERVED    :25;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG40_t;

/* Register CFG_REG40 - USB3. */
#define IMX_USB3_USBSS_CFG_REG40_OFFSET 0x201BC
/* Field LFPS_MIN_GEN_U1EXIT - LFPS_MIN_GEN_U1EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 87 (~696ns) For synthesis purposes it is recommended to set the value 87 (~696ns) */
#define IMX_USB3_USBSS_CFG_REG40_LFPS_MIN_GEN_U1EXIT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG40_LFPS_MIN_GEN_U1EXIT_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG40_LFPS_MIN_GEN_U1EXIT(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG40_RESERVED_SHIFT 7
#define IMX_USB3_USBSS_CFG_REG40_RESERVED_MASK 0xFFFFFF80
#define IMX_USB3_USBSS_CFG_REG40_RESERVED(v) (((v) << 0x7) & 0xFFFFFF80)

/* IMX_USB3_USBSS_CFG_REG41 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG41_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_MIN_GEN_U2EXIT :15;        /* LFPS_MIN_GEN_U2EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 12500 (~100us) For synthesis purposes it is recommended to set the value 12500 (~100us) */
        uint32_t RESERVED    :17;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG41_t;

/* Register CFG_REG41 - USB3. */
#define IMX_USB3_USBSS_CFG_REG41_OFFSET 0x201C0
/* Field LFPS_MIN_GEN_U2EXIT - LFPS_MIN_GEN_U2EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 12500 (~100us) For synthesis purposes it is recommended to set the value 12500 (~100us) */
#define IMX_USB3_USBSS_CFG_REG41_LFPS_MIN_GEN_U2EXIT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG41_LFPS_MIN_GEN_U2EXIT_MASK 0x7FFF
#define IMX_USB3_USBSS_CFG_REG41_LFPS_MIN_GEN_U2EXIT(v) (((v) << 0) & 0x7FFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG41_RESERVED_SHIFT 15
#define IMX_USB3_USBSS_CFG_REG41_RESERVED_MASK 0xFFFF8000
#define IMX_USB3_USBSS_CFG_REG41_RESERVED(v) (((v) << 0xF) & 0xFFFF8000)

/* IMX_USB3_USBSS_CFG_REG42 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG42_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_POLLING_REPEAT :11;        /* LFPS_POLLING_REPEAT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 1250 (~10us) For synthesis purposes it is recommended to set the value 1250 (~10us) */
        uint32_t RESERVED    :21;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG42_t;

/* Register CFG_REG42 - USB3. */
#define IMX_USB3_USBSS_CFG_REG42_OFFSET 0x201C4
/* Field LFPS_POLLING_REPEAT - LFPS_POLLING_REPEAT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 1250 (~10us) For synthesis purposes it is recommended to set the value 1250 (~10us) */
#define IMX_USB3_USBSS_CFG_REG42_LFPS_POLLING_REPEAT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG42_LFPS_POLLING_REPEAT_MASK 0x7FF
#define IMX_USB3_USBSS_CFG_REG42_LFPS_POLLING_REPEAT(v) (((v) << 0) & 0x7FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG42_RESERVED_SHIFT 11
#define IMX_USB3_USBSS_CFG_REG42_RESERVED_MASK 0xFFFFF800
#define IMX_USB3_USBSS_CFG_REG42_RESERVED(v) (((v) << 0xB) & 0xFFFFF800)

/* IMX_USB3_USBSS_CFG_REG43 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG43_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_POLLING_MAX_TREPEAT :11;   /* LFPS_POLLING_MAX_TREPEAT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 1750 (~14us) For synthesis purposes it is recommended to set the value 1750 (~14us) */
        uint32_t RESERVED    :21;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG43_t;

/* Register CFG_REG43 - USB3. */
#define IMX_USB3_USBSS_CFG_REG43_OFFSET 0x201C8
/* Field LFPS_POLLING_MAX_TREPEAT - LFPS_POLLING_MAX_TREPEAT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 1750 (~14us) For synthesis purposes it is recommended to set the value 1750 (~14us) */
#define IMX_USB3_USBSS_CFG_REG43_LFPS_POLLING_MAX_TREPEAT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG43_LFPS_POLLING_MAX_TREPEAT_MASK 0x7FF
#define IMX_USB3_USBSS_CFG_REG43_LFPS_POLLING_MAX_TREPEAT(v) (((v) << 0) & 0x7FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG43_RESERVED_SHIFT 11
#define IMX_USB3_USBSS_CFG_REG43_RESERVED_MASK 0xFFFFF800
#define IMX_USB3_USBSS_CFG_REG43_RESERVED(v) (((v) << 0xB) & 0xFFFFF800)

/* IMX_USB3_USBSS_CFG_REG44 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG44_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_POLLING_MIN_TREPEAT :11;   /* LFPS_POLLING_MIN_TREPEAT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 748 (~6us) For synthesis purposes it is recommended to set the value 748 (~6us) */
        uint32_t RESERVED    :21;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG44_t;

/* Register CFG_REG44 - USB3. */
#define IMX_USB3_USBSS_CFG_REG44_OFFSET 0x201CC
/* Field LFPS_POLLING_MIN_TREPEAT - LFPS_POLLING_MIN_TREPEAT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 748 (~6us) For synthesis purposes it is recommended to set the value 748 (~6us) */
#define IMX_USB3_USBSS_CFG_REG44_LFPS_POLLING_MIN_TREPEAT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG44_LFPS_POLLING_MIN_TREPEAT_MASK 0x7FF
#define IMX_USB3_USBSS_CFG_REG44_LFPS_POLLING_MIN_TREPEAT(v) (((v) << 0) & 0x7FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG44_RESERVED_SHIFT 11
#define IMX_USB3_USBSS_CFG_REG44_RESERVED_MASK 0xFFFFF800
#define IMX_USB3_USBSS_CFG_REG44_RESERVED(v) (((v) << 0xB) & 0xFFFFF800)

/* IMX_USB3_USBSS_CFG_REG45 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG45_union_t {
    uint32_t R;
    struct {
        uint32_t ITP_WAKEUP_TIMEOUT :7;          /* ITP_WAKEUP_TIMEOUT value Resolution of this parameter is selected by ITP_WAKEUP_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 101*1us =~100us (SystemC device ENV) - 101*1us =~100us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 101*1us =~100us */
        uint32_t RESERVED    :23;                /* Reserved field. Write ignored. 0 when read */
        uint32_t ITP_WAKEUP_TIMEOUT_PRESCALE :2; /* PRESCALER for ITP_WAKEUP_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG45_t;

/* Register CFG_REG45 - USB3. */
#define IMX_USB3_USBSS_CFG_REG45_OFFSET 0x201D0
/* Field ITP_WAKEUP_TIMEOUT - ITP_WAKEUP_TIMEOUT value Resolution of this parameter is selected by ITP_WAKEUP_TIMEOUT_PRESCALE. For simulation purposes it is recommended to set the value: - 101*1us =~100us (SystemC device ENV) - 101*1us =~100us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 101*1us =~100us */
#define IMX_USB3_USBSS_CFG_REG45_ITP_WAKEUP_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG45_ITP_WAKEUP_TIMEOUT_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG45_ITP_WAKEUP_TIMEOUT(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG45_RESERVED_SHIFT 7
#define IMX_USB3_USBSS_CFG_REG45_RESERVED_MASK 0x3FFFFF80
#define IMX_USB3_USBSS_CFG_REG45_RESERVED(v) (((v) << 0x7) & 0x3FFFFF80)
/* Field ITP_WAKEUP_TIMEOUT_PRESCALE - PRESCALER for ITP_WAKEUP_TIMEOUT value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG45_ITP_WAKEUP_TIMEOUT_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG45_ITP_WAKEUP_TIMEOUT_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG45_ITP_WAKEUP_TIMEOUT_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG46 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG46_union_t {
    uint32_t R;
    struct {
        uint32_t TSEQ_QUANTITY :16;              /* TSEQ_QUANTITY value This parameter defines the number of TSEQ training sequences to be sent during Polling.RxEq state. For simulation purposes it is recommended to set the value 655 For synthesis purposes it is recommended to set the value 65535. */
        uint32_t RESERVED    :16;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG46_t;

/* Register CFG_REG46 - USB3. */
#define IMX_USB3_USBSS_CFG_REG46_OFFSET 0x201D4
/* Field TSEQ_QUANTITY - TSEQ_QUANTITY value This parameter defines the number of TSEQ training sequences to be sent during Polling.RxEq state. For simulation purposes it is recommended to set the value 655 For synthesis purposes it is recommended to set the value 65535. */
#define IMX_USB3_USBSS_CFG_REG46_TSEQ_QUANTITY_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG46_TSEQ_QUANTITY_MASK 0xFFFF
#define IMX_USB3_USBSS_CFG_REG46_TSEQ_QUANTITY(v) (((v) << 0) & 0xFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG46_RESERVED_SHIFT 16
#define IMX_USB3_USBSS_CFG_REG46_RESERVED_MASK 0xFFFF0000
#define IMX_USB3_USBSS_CFG_REG46_RESERVED(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_CFG_REG47 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG47_union_t {
    uint32_t R;
    struct {
        uint32_t ERDY_TIMEOUT_CNT :20;           /* ERDY_TIMEOUT_CNT value Resolution of this parameter is 1 us. For simulation purposes it is recommended to set the value 16 (~15 us) For synthesis purposes it is recommended to set the value ~512001 (~512ms) */
        uint32_t RESERVED    :12;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG47_t;

/* Register CFG_REG47 - USB3. */
#define IMX_USB3_USBSS_CFG_REG47_OFFSET 0x201D8
/* Field ERDY_TIMEOUT_CNT - ERDY_TIMEOUT_CNT value Resolution of this parameter is 1 us. For simulation purposes it is recommended to set the value 16 (~15 us) For synthesis purposes it is recommended to set the value ~512001 (~512ms) */
#define IMX_USB3_USBSS_CFG_REG47_ERDY_TIMEOUT_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG47_ERDY_TIMEOUT_CNT_MASK 0xFFFFF
#define IMX_USB3_USBSS_CFG_REG47_ERDY_TIMEOUT_CNT(v) (((v) << 0) & 0xFFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG47_RESERVED_SHIFT 20
#define IMX_USB3_USBSS_CFG_REG47_RESERVED_MASK 0xFFF00000
#define IMX_USB3_USBSS_CFG_REG47_RESERVED(v) (((v) << 0x14) & 0xFFF00000)

/* IMX_USB3_USBSS_CFG_REG48 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG48_union_t {
    uint32_t R;
    struct {
        uint32_t TWTRSTFS_J_CNT :18;             /* TWTRSTFS_J_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 98304 (~3.28ms) For synthesis purposes it is recommended to set the value 98304 (~3.28ms) */
        uint32_t RESERVED    :14;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG48_t;

/* Register CFG_REG48 - USB2. */
#define IMX_USB3_USBSS_CFG_REG48_OFFSET 0x201DC
/* Field TWTRSTFS_J_CNT - TWTRSTFS_J_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 98304 (~3.28ms) For synthesis purposes it is recommended to set the value 98304 (~3.28ms) */
#define IMX_USB3_USBSS_CFG_REG48_TWTRSTFS_J_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG48_TWTRSTFS_J_CNT_MASK 0x3FFFF
#define IMX_USB3_USBSS_CFG_REG48_TWTRSTFS_J_CNT(v) (((v) << 0) & 0x3FFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG48_RESERVED_SHIFT 18
#define IMX_USB3_USBSS_CFG_REG48_RESERVED_MASK 0xFFFC0000
#define IMX_USB3_USBSS_CFG_REG48_RESERVED(v) (((v) << 0x12) & 0xFFFC0000)

/* IMX_USB3_USBSS_CFG_REG49 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG49_union_t {
    uint32_t R;
    struct {
        uint32_t TUCH_CNT    :16;                /* TUCH_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 129 (~4.3us) For synthesis purposes it is recommended to set the value 35584 (~1.19ms) */
        uint32_t RESERVED    :16;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG49_t;

/* Register CFG_REG49 - USB2. */
#define IMX_USB3_USBSS_CFG_REG49_OFFSET 0x201E0
/* Field TUCH_CNT - TUCH_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 129 (~4.3us) For synthesis purposes it is recommended to set the value 35584 (~1.19ms) */
#define IMX_USB3_USBSS_CFG_REG49_TUCH_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG49_TUCH_CNT_MASK 0xFFFF
#define IMX_USB3_USBSS_CFG_REG49_TUCH_CNT(v) (((v) << 0) & 0xFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG49_RESERVED_SHIFT 16
#define IMX_USB3_USBSS_CFG_REG49_RESERVED_MASK 0xFFFF0000
#define IMX_USB3_USBSS_CFG_REG49_RESERVED(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_CFG_REG50 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG50_union_t {
    uint32_t R;
    struct {
        uint32_t TWAITCHK_CNT :12;               /* TWAITCHK_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 30 (~1us) For synthesis purposes it is recommended to set the value 2400 (~80us) */
        uint32_t RESERVED    :20;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG50_t;

/* Register CFG_REG50 - USB2. */
#define IMX_USB3_USBSS_CFG_REG50_OFFSET 0x201E4
/* Field TWAITCHK_CNT - TWAITCHK_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 30 (~1us) For synthesis purposes it is recommended to set the value 2400 (~80us) */
#define IMX_USB3_USBSS_CFG_REG50_TWAITCHK_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG50_TWAITCHK_CNT_MASK 0xFFF
#define IMX_USB3_USBSS_CFG_REG50_TWAITCHK_CNT(v) (((v) << 0) & 0xFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG50_RESERVED_SHIFT 12
#define IMX_USB3_USBSS_CFG_REG50_RESERVED_MASK 0xFFFFF000
#define IMX_USB3_USBSS_CFG_REG50_RESERVED(v) (((v) << 0xC) & 0xFFFFF000)

/* IMX_USB3_USBSS_CFG_REG51 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG51_union_t {
    uint32_t R;
    struct {
        uint32_t TWTFS_CNT   :17;                /* TWTFS_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 1000 (~33.3us) For synthesis purposes it is recommended to set the value 104963 (~3.5ms) */
        uint32_t RESERVED    :15;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG51_t;

/* Register CFG_REG51 - USB2. */
#define IMX_USB3_USBSS_CFG_REG51_OFFSET 0x201E8
/* Field TWTFS_CNT - TWTFS_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 1000 (~33.3us) For synthesis purposes it is recommended to set the value 104963 (~3.5ms) */
#define IMX_USB3_USBSS_CFG_REG51_TWTFS_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG51_TWTFS_CNT_MASK 0x1FFFF
#define IMX_USB3_USBSS_CFG_REG51_TWTFS_CNT(v) (((v) << 0) & 0x1FFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG51_RESERVED_SHIFT 17
#define IMX_USB3_USBSS_CFG_REG51_RESERVED_MASK 0xFFFE0000
#define IMX_USB3_USBSS_CFG_REG51_RESERVED(v) (((v) << 0x11) & 0xFFFE0000)

/* IMX_USB3_USBSS_CFG_REG52 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG52_union_t {
    uint32_t R;
    struct {
        uint32_t TWTREV_CNT  :17;                /* TWTREV_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 90112 (~3ms) For synthesis purposes it is recommended to set the value 90112 (~3ms) */
        uint32_t RESERVED    :15;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG52_t;

/* Register CFG_REG52 - USB2. */
#define IMX_USB3_USBSS_CFG_REG52_OFFSET 0x201EC
/* Field TWTREV_CNT - TWTREV_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 90112 (~3ms) For synthesis purposes it is recommended to set the value 90112 (~3ms) */
#define IMX_USB3_USBSS_CFG_REG52_TWTREV_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG52_TWTREV_CNT_MASK 0x1FFFF
#define IMX_USB3_USBSS_CFG_REG52_TWTREV_CNT(v) (((v) << 0) & 0x1FFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG52_RESERVED_SHIFT 17
#define IMX_USB3_USBSS_CFG_REG52_RESERVED_MASK 0xFFFE0000
#define IMX_USB3_USBSS_CFG_REG52_RESERVED(v) (((v) << 0x11) & 0xFFFE0000)

/* IMX_USB3_USBSS_CFG_REG53 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG53_union_t {
    uint32_t R;
    struct {
        uint32_t TWTRSTHS_CNT :15;               /* TWTRSTHS_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 23552 (~785us) For synthesis purposes it is recommended to set the value 23552 (~785us) */
        uint32_t RESERVED    :17;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG53_t;

/* Register CFG_REG53 - USB2. */
#define IMX_USB3_USBSS_CFG_REG53_OFFSET 0x201F0
/* Field TWTRSTHS_CNT - TWTRSTHS_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 23552 (~785us) For synthesis purposes it is recommended to set the value 23552 (~785us) */
#define IMX_USB3_USBSS_CFG_REG53_TWTRSTHS_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG53_TWTRSTHS_CNT_MASK 0x7FFF
#define IMX_USB3_USBSS_CFG_REG53_TWTRSTHS_CNT(v) (((v) << 0) & 0x7FFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG53_RESERVED_SHIFT 15
#define IMX_USB3_USBSS_CFG_REG53_RESERVED_MASK 0xFFFF8000
#define IMX_USB3_USBSS_CFG_REG53_RESERVED(v) (((v) << 0xF) & 0xFFFF8000)

/* IMX_USB3_USBSS_CFG_REG54 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG54_union_t {
    uint32_t R;
    struct {
        uint32_t TWTRSM_CNT  :18;                /* TWTRSM_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 150016 (~5ms) For synthesis purposes it is recommended to set the value 150016 (~5ms) */
        uint32_t RESERVED    :14;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG54_t;

/* Register CFG_REG54 - USB2. */
#define IMX_USB3_USBSS_CFG_REG54_OFFSET 0x201F4
/* Field TWTRSM_CNT - TWTRSM_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 150016 (~5ms) For synthesis purposes it is recommended to set the value 150016 (~5ms) */
#define IMX_USB3_USBSS_CFG_REG54_TWTRSM_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG54_TWTRSM_CNT_MASK 0x3FFFF
#define IMX_USB3_USBSS_CFG_REG54_TWTRSM_CNT(v) (((v) << 0) & 0x3FFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG54_RESERVED_SHIFT 18
#define IMX_USB3_USBSS_CFG_REG54_RESERVED_MASK 0xFFFC0000
#define IMX_USB3_USBSS_CFG_REG54_RESERVED(v) (((v) << 0x12) & 0xFFFC0000)

/* IMX_USB3_USBSS_CFG_REG55 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG55_union_t {
    uint32_t R;
    struct {
        uint32_t TDRSMUP_CNT :16;                /* TDRSMUP_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 32768 (~1.1ms) For synthesis purposes it is recommended to set the value 32768 (~1.1ms) */
        uint32_t RESERVED    :16;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG55_t;

/* Register CFG_REG55 - USB2. */
#define IMX_USB3_USBSS_CFG_REG55_OFFSET 0x201F8
/* Field TDRSMUP_CNT - TDRSMUP_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 32768 (~1.1ms) For synthesis purposes it is recommended to set the value 32768 (~1.1ms) */
#define IMX_USB3_USBSS_CFG_REG55_TDRSMUP_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG55_TDRSMUP_CNT_MASK 0xFFFF
#define IMX_USB3_USBSS_CFG_REG55_TDRSMUP_CNT(v) (((v) << 0) & 0xFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG55_RESERVED_SHIFT 16
#define IMX_USB3_USBSS_CFG_REG55_RESERVED_MASK 0xFFFF0000
#define IMX_USB3_USBSS_CFG_REG55_RESERVED(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_CFG_REG56 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG56_union_t {
    uint32_t R;
    struct {
        uint32_t TOUTHS_CNT  :6;                 /* TOUTHS_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 48 (~1.6us) For synthesis purposes it is recommended to set the value 48 (~1.6us) */
        uint32_t RESERVED    :26;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG56_t;

/* Register CFG_REG56 - USB2. */
#define IMX_USB3_USBSS_CFG_REG56_OFFSET 0x201FC
/* Field TOUTHS_CNT - TOUTHS_CNT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value 48 (~1.6us) For synthesis purposes it is recommended to set the value 48 (~1.6us) */
#define IMX_USB3_USBSS_CFG_REG56_TOUTHS_CNT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG56_TOUTHS_CNT_MASK 0x3F
#define IMX_USB3_USBSS_CFG_REG56_TOUTHS_CNT(v) (((v) << 0) & 0x3F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG56_RESERVED_SHIFT 6
#define IMX_USB3_USBSS_CFG_REG56_RESERVED_MASK 0xFFFFFFC0
#define IMX_USB3_USBSS_CFG_REG56_RESERVED(v) (((v) << 0x6) & 0xFFFFFFC0)

/* IMX_USB3_USBSS_CFG_REG57 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG57_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_DEB_WIDTH :2;              /* LFPS_DEB_WIDTH value This parameter defines the LFPS debouncer delay. Only two values are allowed: 0x1 or 0x2. For simulation purposes it is recommended to set the value 1. For synthesis purposes it is recommended to set the value 2. */
        uint32_t RESERVED    :30;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG57_t;

/* Register CFG_REG57 - USB3. */
#define IMX_USB3_USBSS_CFG_REG57_OFFSET 0x20200
/* Field LFPS_DEB_WIDTH - LFPS_DEB_WIDTH value This parameter defines the LFPS debouncer delay. Only two values are allowed: 0x1 or 0x2. For simulation purposes it is recommended to set the value 1. For synthesis purposes it is recommended to set the value 2. */
#define IMX_USB3_USBSS_CFG_REG57_LFPS_DEB_WIDTH_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG57_LFPS_DEB_WIDTH_MASK 0x3
#define IMX_USB3_USBSS_CFG_REG57_LFPS_DEB_WIDTH(v) (((v) << 0) & 0x3)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG57_RESERVED_SHIFT 2
#define IMX_USB3_USBSS_CFG_REG57_RESERVED_MASK 0xFFFFFFFC
#define IMX_USB3_USBSS_CFG_REG57_RESERVED(v) (((v) << 0x2) & 0xFFFFFFFC)

/* IMX_USB3_USBSS_CFG_REG58 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG58_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_GEN_U2EXIT :18;            /* LFPS_GEN_U2EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 62500 (~500us) For synthesis purposes it is recommended to set the value 250000 (~2ms) */
        uint32_t RESERVED    :14;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG58_t;

/* Register CFG_REG58 - USB3. */
#define IMX_USB3_USBSS_CFG_REG58_OFFSET 0x20204
/* Field LFPS_GEN_U2EXIT - LFPS_GEN_U2EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 62500 (~500us) For synthesis purposes it is recommended to set the value 250000 (~2ms) */
#define IMX_USB3_USBSS_CFG_REG58_LFPS_GEN_U2EXIT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG58_LFPS_GEN_U2EXIT_MASK 0x3FFFF
#define IMX_USB3_USBSS_CFG_REG58_LFPS_GEN_U2EXIT(v) (((v) << 0) & 0x3FFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG58_RESERVED_SHIFT 18
#define IMX_USB3_USBSS_CFG_REG58_RESERVED_MASK 0xFFFC0000
#define IMX_USB3_USBSS_CFG_REG58_RESERVED(v) (((v) << 0x12) & 0xFFFC0000)

/* IMX_USB3_USBSS_CFG_REG59 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG59_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_MIN_GEN_U3EXIT :16;        /* LFPS_MIN_GEN_U3EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 12500 (~100us) For synthesis purposes it is recommended to set the value 12500 (~100us) */
        uint32_t RESERVED    :16;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG59_t;

/* Register CFG_REG59 - USB3. */
#define IMX_USB3_USBSS_CFG_REG59_OFFSET 0x20208
/* Field LFPS_MIN_GEN_U3EXIT - LFPS_MIN_GEN_U3EXIT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 12500 (~100us) For synthesis purposes it is recommended to set the value 12500 (~100us) */
#define IMX_USB3_USBSS_CFG_REG59_LFPS_MIN_GEN_U3EXIT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG59_LFPS_MIN_GEN_U3EXIT_MASK 0xFFFF
#define IMX_USB3_USBSS_CFG_REG59_LFPS_MIN_GEN_U3EXIT(v) (((v) << 0) & 0xFFFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG59_RESERVED_SHIFT 16
#define IMX_USB3_USBSS_CFG_REG59_RESERVED_MASK 0xFFFF0000
#define IMX_USB3_USBSS_CFG_REG59_RESERVED(v) (((v) << 0x10) & 0xFFFF0000)

/* IMX_USB3_USBSS_CFG_REG60 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG60_union_t {
    uint32_t R;
    struct {
        uint32_t PORT_CONFIG_TIMEOUT :7;         /* PORT_CONFIG_TIMEOUT value Resolution of this parameter is 1 us. For simulation purposes it is recommended to set the value 21 (~20us) For synthesis purposes it is recommended to set the value 21 (~20us) */
        uint32_t RESERVED    :25;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG60_t;

/* Register CFG_REG60 - USB3. */
#define IMX_USB3_USBSS_CFG_REG60_OFFSET 0x2020C
/* Field PORT_CONFIG_TIMEOUT - PORT_CONFIG_TIMEOUT value Resolution of this parameter is 1 us. For simulation purposes it is recommended to set the value 21 (~20us) For synthesis purposes it is recommended to set the value 21 (~20us) */
#define IMX_USB3_USBSS_CFG_REG60_PORT_CONFIG_TIMEOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG60_PORT_CONFIG_TIMEOUT_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG60_PORT_CONFIG_TIMEOUT(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG60_RESERVED_SHIFT 7
#define IMX_USB3_USBSS_CFG_REG60_RESERVED_MASK 0xFFFFFF80
#define IMX_USB3_USBSS_CFG_REG60_RESERVED(v) (((v) << 0x7) & 0xFFFFFF80)

/* IMX_USB3_USBSS_CFG_REG61 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG61_union_t {
    uint32_t R;
    struct {
        uint32_t LFPS_POL_LFPS_TO_RXEQ :11;      /* LFPS_POL_LFPS_TO_RXEQ value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 250 (~2us) For synthesis purposes it is recommended to set the value 250 (~2us) */
        uint32_t RESERVED    :21;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG61_t;

/* Register CFG_REG61 - USB3. */
#define IMX_USB3_USBSS_CFG_REG61_OFFSET 0x20210
/* Field LFPS_POL_LFPS_TO_RXEQ - LFPS_POL_LFPS_TO_RXEQ value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value 250 (~2us) For synthesis purposes it is recommended to set the value 250 (~2us) */
#define IMX_USB3_USBSS_CFG_REG61_LFPS_POL_LFPS_TO_RXEQ_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG61_LFPS_POL_LFPS_TO_RXEQ_MASK 0x7FF
#define IMX_USB3_USBSS_CFG_REG61_LFPS_POL_LFPS_TO_RXEQ(v) (((v) << 0) & 0x7FF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG61_RESERVED_SHIFT 11
#define IMX_USB3_USBSS_CFG_REG61_RESERVED_MASK 0xFFFFF800
#define IMX_USB3_USBSS_CFG_REG61_RESERVED(v) (((v) << 0xB) & 0xFFFFF800)

/* IMX_USB3_USBSS_CFG_REG62 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG62_union_t {
    uint32_t R;
    struct {
        uint32_t PHY_TX_LATENCY :6;              /* PHY_TX_LATENCY value This parameter defines latency from when data appear on PIPE interface to channel + 3 time units (defined by PHY_TX_LATENCY_PRESCALE). For simulation purposes it is recommended to set the value 11. For synthesis purposes it is recommended to set the value 11 */
        uint32_t RESERVED    :24;                /* Reserved field. Write ignored. 0 when read */
        uint32_t PHY_TX_LATENCY_PRESCALE :2;     /* PRESCALER for PHY_TX_LATENCY value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
    } B;
} IMX_USB3_USBSS_CFG_REG62_t;

/* Register CFG_REG62 - USB3. */
#define IMX_USB3_USBSS_CFG_REG62_OFFSET 0x20214
/* Field PHY_TX_LATENCY - PHY_TX_LATENCY value This parameter defines latency from when data appear on PIPE interface to channel + 3 time units (defined by PHY_TX_LATENCY_PRESCALE). For simulation purposes it is recommended to set the value 11. For synthesis purposes it is recommended to set the value 11 */
#define IMX_USB3_USBSS_CFG_REG62_PHY_TX_LATENCY_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG62_PHY_TX_LATENCY_MASK 0x3F
#define IMX_USB3_USBSS_CFG_REG62_PHY_TX_LATENCY(v) (((v) << 0) & 0x3F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG62_RESERVED_SHIFT 6
#define IMX_USB3_USBSS_CFG_REG62_RESERVED_MASK 0x3FFFFFC0
#define IMX_USB3_USBSS_CFG_REG62_RESERVED(v) (((v) << 0x6) & 0x3FFFFFC0)
/* Field PHY_TX_LATENCY_PRESCALE - PRESCALER for PHY_TX_LATENCY value: - 0x0 : 8ns (PHY pclk clock) - 0x1 : 1us - 0x2 : 100us - 0x3 : no clock - allows disabling certain timeout */
#define IMX_USB3_USBSS_CFG_REG62_PHY_TX_LATENCY_PRESCALE_SHIFT 30
#define IMX_USB3_USBSS_CFG_REG62_PHY_TX_LATENCY_PRESCALE_MASK 0xC0000000
#define IMX_USB3_USBSS_CFG_REG62_PHY_TX_LATENCY_PRESCALE(v) (((v) << 0x1E) & 0xC0000000)

/* IMX_USB3_USBSS_CFG_REG63 - USB3. */
typedef union IMX_USB3_USBSS_CFG_REG63_union_t {
    uint32_t R;
    struct {
        uint32_t U2_INACTIVITY_TMOUT :15;        /* U2_INACTIVITY_TMOUT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value: - 31999*8ns =~256us (SystemC device ENV) - 249*8ns =~2us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 31999*8ns =~256us */
        uint32_t RESERVED    :17;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG63_t;

/* Register CFG_REG63 - USB3. */
#define IMX_USB3_USBSS_CFG_REG63_OFFSET 0x20218
/* Field U2_INACTIVITY_TMOUT - U2_INACTIVITY_TMOUT value Resolution of this parameter is 8 ns. For simulation purposes it is recommended to set the value: - 31999*8ns =~256us (SystemC device ENV) - 249*8ns =~2us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 31999*8ns =~256us */
#define IMX_USB3_USBSS_CFG_REG63_U2_INACTIVITY_TMOUT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG63_U2_INACTIVITY_TMOUT_MASK 0x7FFF
#define IMX_USB3_USBSS_CFG_REG63_U2_INACTIVITY_TMOUT(v) (((v) << 0) & 0x7FFF)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG63_RESERVED_SHIFT 15
#define IMX_USB3_USBSS_CFG_REG63_RESERVED_MASK 0xFFFF8000
#define IMX_USB3_USBSS_CFG_REG63_RESERVED(v) (((v) << 0xF) & 0xFFFF8000)

/* IMX_USB3_USBSS_CFG_REG64 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG64_union_t {
    uint32_t R;
    struct {
        uint32_t TFILTSE0    :7;                 /* TFILTSE0 value Resolution of this parameter is 33.3ns. For simulation purposes it is recommended to set the value: - 74*33.3ns =~2.46us (SystemC device ENV) - 57*33.3ns =~1.9us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 74*33.3ns =~2.46us */
        uint32_t RESERVED    :25;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG64_t;

/* Register CFG_REG64 - USB2. */
#define IMX_USB3_USBSS_CFG_REG64_OFFSET 0x20220
/* Field TFILTSE0 - TFILTSE0 value Resolution of this parameter is 33.3ns. For simulation purposes it is recommended to set the value: - 74*33.3ns =~2.46us (SystemC device ENV) - 57*33.3ns =~1.9us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 74*33.3ns =~2.46us */
#define IMX_USB3_USBSS_CFG_REG64_TFILTSE0_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG64_TFILTSE0_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG64_TFILTSE0(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG64_RESERVED_SHIFT 7
#define IMX_USB3_USBSS_CFG_REG64_RESERVED_MASK 0xFFFFFF80
#define IMX_USB3_USBSS_CFG_REG64_RESERVED(v) (((v) << 0x7) & 0xFFFFFF80)

/* IMX_USB3_USBSS_CFG_REG65 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG65_union_t {
    uint32_t R;
    struct {
        uint32_t TFILT       :7;                 /* TFILT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value: - 75*33.3ns =~2.5us (SystemC device ENV) - 57*33.3ns =~1.9us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 75*33.3ns =~2.5us */
        uint32_t _unused7    :8;
        uint32_t RESERVED    :17;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG65_t;

/* Register CFG_REG65 - USB2. */
#define IMX_USB3_USBSS_CFG_REG65_OFFSET 0x20224
/* Field TFILT - TFILT value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value: - 75*33.3ns =~2.5us (SystemC device ENV) - 57*33.3ns =~1.9us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 75*33.3ns =~2.5us */
#define IMX_USB3_USBSS_CFG_REG65_TFILT_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG65_TFILT_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG65_TFILT(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG65_RESERVED_SHIFT 15
#define IMX_USB3_USBSS_CFG_REG65_RESERVED_MASK 0xFFFF8000
#define IMX_USB3_USBSS_CFG_REG65_RESERVED(v) (((v) << 0xF) & 0xFFFF8000)

/* IMX_USB3_USBSS_CFG_REG66 - USB2. */
typedef union IMX_USB3_USBSS_CFG_REG66_union_t {
    uint32_t R;
    struct {
        uint32_t TWTRSTFS_SE0 :7;                /* TWTRSTFS_SE0 value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value: - 73*33.3ns =~2.43us (SystemC device ENV) - 57*33.3ns =~1.9us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 73*33.3ns =~2.43us */
        uint32_t _unused7    :8;
        uint32_t RESERVED    :17;                /* Reserved field. Write ignored. 0 when read */
    } B;
} IMX_USB3_USBSS_CFG_REG66_t;

/* Register CFG_REG66 - USB2. */
#define IMX_USB3_USBSS_CFG_REG66_OFFSET 0x20228
/* Field TWTRSTFS_SE0 - TWTRSTFS_SE0 value Resolution of this parameter is 33.3 ns. For simulation purposes it is recommended to set the value: - 73*33.3ns =~2.43us (SystemC device ENV) - 57*33.3ns =~1.9us (VIP based ENV) For synthesis purposes it is recommended to set the value: - 73*33.3ns =~2.43us */
#define IMX_USB3_USBSS_CFG_REG66_TWTRSTFS_SE0_SHIFT 0
#define IMX_USB3_USBSS_CFG_REG66_TWTRSTFS_SE0_MASK 0x7F
#define IMX_USB3_USBSS_CFG_REG66_TWTRSTFS_SE0(v) (((v) << 0) & 0x7F)
/* Field RESERVED - Reserved field. Write ignored. 0 when read */
#define IMX_USB3_USBSS_CFG_REG66_RESERVED_SHIFT 15
#define IMX_USB3_USBSS_CFG_REG66_RESERVED_MASK 0xFFFF8000
#define IMX_USB3_USBSS_CFG_REG66_RESERVED(v) (((v) << 0xF) & 0xFFFF8000)

/* IMX_USB3_USBSS_DMA_AXI_CTRL - DMA AXI Master Control register. */
typedef union IMX_USB3_USBSS_DMA_AXI_CTRL_union_t {
    uint32_t R;
    struct {
        uint32_t MARPROT     :3;                 /* MARPROT */
        uint32_t RESERVED0   :1;                 /* RESERVED0 */
        uint32_t MARCACHE    :4;                 /* MARCACHE */
        uint32_t MARLOCK     :2;                 /* MARLOCK */
        uint32_t RESERVED1   :6;                 /* RESERVED1 */
        uint32_t MAWPROT     :3;                 /* MAWPROT */
        uint32_t RESERVED2   :1;                 /* RESERVED2 */
        uint32_t MAWCACHE    :4;                 /* MAWCACHE */
        uint32_t MAWLOCK     :2;                 /* MAWLOCK */
        uint32_t RESERVED3   :6;                 /* RESERVED3 */
    } B;
} IMX_USB3_USBSS_DMA_AXI_CTRL_t;

/* Register DMA_AXI_CTRL - DMA AXI Master Control register. */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_OFFSET 0x20300
/* Field MARPROT - MARPROT */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARPROT_SHIFT 0
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARPROT_MASK 0x7
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARPROT(v) (((v) << 0) & 0x7)
/* Field RESERVED0 - RESERVED0 */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED0_SHIFT 3
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED0_MASK 0x8
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED0(v) (((v) << 0x3) & 0x8)
/* Field MARCACHE - MARCACHE */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARCACHE_SHIFT 4
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARCACHE_MASK 0xF0
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARCACHE(v) (((v) << 0x4) & 0xF0)
/* Field MARLOCK - MARLOCK */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARLOCK_SHIFT 8
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARLOCK_MASK 0x300
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MARLOCK(v) (((v) << 0x8) & 0x300)
/* Field RESERVED1 - RESERVED1 */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED1_SHIFT 10
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED1_MASK 0xFC00
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED1(v) (((v) << 0xA) & 0xFC00)
/* Field MAWPROT - MAWPROT */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWPROT_SHIFT 16
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWPROT_MASK 0x70000
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWPROT(v) (((v) << 0x10) & 0x70000)
/* Field RESERVED2 - RESERVED2 */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED2_SHIFT 19
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED2_MASK 0x80000
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED2(v) (((v) << 0x13) & 0x80000)
/* Field MAWCACHE - MAWCACHE */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWCACHE_SHIFT 20
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWCACHE_MASK 0xF00000
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWCACHE(v) (((v) << 0x14) & 0xF00000)
/* Field MAWLOCK - MAWLOCK */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWLOCK_SHIFT 24
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWLOCK_MASK 0x3000000
#define IMX_USB3_USBSS_DMA_AXI_CTRL_MAWLOCK(v) (((v) << 0x18) & 0x3000000)
/* Field RESERVED3 - RESERVED3 */
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED3_SHIFT 26
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED3_MASK 0xFC000000
#define IMX_USB3_USBSS_DMA_AXI_CTRL_RESERVED3(v) (((v) << 0x1A) & 0xFC000000)

/* IMX_USB3_USBSS_DMA_AXI_ID - DMA AXI Master ID register. */
typedef union IMX_USB3_USBSS_DMA_AXI_ID_union_t {
    uint32_t R;
    struct {
        uint32_t MAW_ID      :5;                 /* MAW_ID */
        uint32_t RESERVED0   :11;                /* RESERVED0 */
        uint32_t MAR_ID      :5;                 /* MAR_ID */
        uint32_t RESERVED1   :11;                /* RESERVED1 */
    } B;
} IMX_USB3_USBSS_DMA_AXI_ID_t;

/* Register DMA_AXI_ID - DMA AXI Master ID register. */
#define IMX_USB3_USBSS_DMA_AXI_ID_OFFSET 0x20304
/* Field MAW_ID - MAW_ID */
#define IMX_USB3_USBSS_DMA_AXI_ID_MAW_ID_SHIFT 0
#define IMX_USB3_USBSS_DMA_AXI_ID_MAW_ID_MASK 0x1F
#define IMX_USB3_USBSS_DMA_AXI_ID_MAW_ID(v) (((v) << 0) & 0x1F)
/* Field RESERVED0 - RESERVED0 */
#define IMX_USB3_USBSS_DMA_AXI_ID_RESERVED0_SHIFT 5
#define IMX_USB3_USBSS_DMA_AXI_ID_RESERVED0_MASK 0xFFE0
#define IMX_USB3_USBSS_DMA_AXI_ID_RESERVED0(v) (((v) << 0x5) & 0xFFE0)
/* Field MAR_ID - MAR_ID */
#define IMX_USB3_USBSS_DMA_AXI_ID_MAR_ID_SHIFT 16
#define IMX_USB3_USBSS_DMA_AXI_ID_MAR_ID_MASK 0x1F0000
#define IMX_USB3_USBSS_DMA_AXI_ID_MAR_ID(v) (((v) << 0x10) & 0x1F0000)
/* Field RESERVED1 - RESERVED1 */
#define IMX_USB3_USBSS_DMA_AXI_ID_RESERVED1_SHIFT 21
#define IMX_USB3_USBSS_DMA_AXI_ID_RESERVED1_MASK 0xFFE00000
#define IMX_USB3_USBSS_DMA_AXI_ID_RESERVED1(v) (((v) << 0x15) & 0xFFE00000)

/* IMX_USB3_USBSS_DMA_AXI_CAP - DMA AXI Master Extended Capability register. */
typedef union IMX_USB3_USBSS_DMA_AXI_CAP_union_t {
    uint32_t R;
    struct {
        uint32_t RESERVED0   :20;                /* RESERVED0 */
        uint32_t AXI_DECERR_EN :1;               /* This bit enables interrupt on AXI DECODE ERROR detection. When 1 and AXI_DECERR is 1 then AXI DECODE ERROR interrupt is requested. When 0 - disabled interrupt from this source */
        uint32_t AXI_SLVERR_EN :1;               /* This bit enables interrupt on AXI SLAVE ERROR detection. When 1 and AXI_SLVERR is 1 then AXI SLAVE ERROR interrupt is requested. When 0 - disabled interrupt from this source */
        uint32_t RESERVED1   :6;                 /* RESERVED1 */
        uint32_t AXI_DECERR  :1;                 /* This bit provides an information about AXI DECODE ERROR response on B or R channel. This flag is cleared by writing '1' to it. Once set it is held until cleared. */
        uint32_t AXI_SLVERR  :1;                 /* This bit provides an information about AXI SLAVE ERROR response on B or R channel. This flag is cleared by writing '1' to it. Once set it is held until cleared. */
        uint32_t AXI_IDLE    :1;                 /* This bit provides information about the AXI Master state: '1': no pending action required by the AXI Master wrapper, '0': the AXI Master wrapper has outstanding transactions. */
        uint32_t RESERVED2   :1;                 /* RESERVED2 */
    } B;
} IMX_USB3_USBSS_DMA_AXI_CAP_t;

/* Register DMA_AXI_CAP - DMA AXI Master Extended Capability register. */
#define IMX_USB3_USBSS_DMA_AXI_CAP_OFFSET 0x20308
/* Field RESERVED0 - RESERVED0 */
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED0_SHIFT 0
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED0_MASK 0xFFFFF
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED0(v) (((v) << 0) & 0xFFFFF)
/* Field AXI_DECERR_EN - This bit enables interrupt on AXI DECODE ERROR detection. When 1 and AXI_DECERR is 1 then AXI DECODE ERROR interrupt is requested. When 0 - disabled interrupt from this source */
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_DECERR_EN_SHIFT 20
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_DECERR_EN_MASK 0x100000
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_DECERR_EN(v) (((v) << 0x14) & 0x100000)
/* Field AXI_SLVERR_EN - This bit enables interrupt on AXI SLAVE ERROR detection. When 1 and AXI_SLVERR is 1 then AXI SLAVE ERROR interrupt is requested. When 0 - disabled interrupt from this source */
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_SLVERR_EN_SHIFT 21
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_SLVERR_EN_MASK 0x200000
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_SLVERR_EN(v) (((v) << 0x15) & 0x200000)
/* Field RESERVED1 - RESERVED1 */
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED1_SHIFT 22
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED1_MASK 0xFC00000
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED1(v) (((v) << 0x16) & 0xFC00000)
/* Field AXI_DECERR - This bit provides an information about AXI DECODE ERROR response on B or R channel. This flag is cleared by writing '1' to it. Once set it is held until cleared. */
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_DECERR_SHIFT 28
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_DECERR_MASK 0x10000000
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_DECERR(v) (((v) << 0x1C) & 0x10000000)
/* Field AXI_SLVERR - This bit provides an information about AXI SLAVE ERROR response on B or R channel. This flag is cleared by writing '1' to it. Once set it is held until cleared. */
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_SLVERR_SHIFT 29
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_SLVERR_MASK 0x20000000
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_SLVERR(v) (((v) << 0x1D) & 0x20000000)
/* Field AXI_IDLE - This bit provides information about the AXI Master state: '1': no pending action required by the AXI Master wrapper, '0': the AXI Master wrapper has outstanding transactions. */
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_IDLE_SHIFT 30
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_IDLE_MASK 0x40000000
#define IMX_USB3_USBSS_DMA_AXI_CAP_AXI_IDLE(v) (((v) << 0x1E) & 0x40000000)
/* Field RESERVED2 - RESERVED2 */
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED2_SHIFT 31
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED2_MASK 0x80000000
#define IMX_USB3_USBSS_DMA_AXI_CAP_RESERVED2(v) (((v) << 0x1F) & 0x80000000)

/* IMX_USB3_USBSS_DMA_AXI_CTRL0 - DMA AXI Master Control0 register. */
typedef union IMX_USB3_USBSS_DMA_AXI_CTRL0_union_t {
    uint32_t R;
    struct {
        uint32_t B_MAX       :4;                 /* The register controls maximum burst length - it is used by the AXI Master wrapper to determine maximum value of AxLEN. It uses AXI AxLEN encoding. Default value is the maximum supported one and it is implementation specific. Width of this register is the same as AxLEN signals width. Note: This register should only be written to during the register initialisation process */
        uint32_t RESERVED    :28;                /* RESERVED */
    } B;
} IMX_USB3_USBSS_DMA_AXI_CTRL0_t;

/* Register DMA_AXI_CTRL0 - DMA AXI Master Control0 register. */
#define IMX_USB3_USBSS_DMA_AXI_CTRL0_OFFSET 0x2030C
/* Field B_MAX - The register controls maximum burst length - it is used by the AXI Master wrapper to determine maximum value of AxLEN. It uses AXI AxLEN encoding. Default value is the maximum supported one and it is implementation specific. Width of this register is the same as AxLEN signals width. Note: This register should only be written to during the register initialisation process */
#define IMX_USB3_USBSS_DMA_AXI_CTRL0_B_MAX_SHIFT 0
#define IMX_USB3_USBSS_DMA_AXI_CTRL0_B_MAX_MASK 0xF
#define IMX_USB3_USBSS_DMA_AXI_CTRL0_B_MAX(v) (((v) << 0) & 0xF)
/* Field RESERVED - RESERVED */
#define IMX_USB3_USBSS_DMA_AXI_CTRL0_RESERVED_SHIFT 4
#define IMX_USB3_USBSS_DMA_AXI_CTRL0_RESERVED_MASK 0xFFFFFFF0
#define IMX_USB3_USBSS_DMA_AXI_CTRL0_RESERVED(v) (((v) << 0x4) & 0xFFFFFFF0)

/* IMX_USB3_USBSS_DMA_AXI_CTRL1 - DMA AXI Master Control1 register. */
typedef union IMX_USB3_USBSS_DMA_AXI_CTRL1_union_t {
    uint32_t R;
    struct {
        uint32_t ROT         :5;                 /* Number of outstanding read transactions that can be initiated by the AXI Master wrapper. Default value of this field is CDNS_USBSSDEV_AXI_WCD-1 (define parameter). The value written to this field should be the requested number of outstanding read transactions minus 1, thus the actual number of possible outstanding read transactions is one more than the programmed value. Note: This register should only be written to during the register initialization process */
        uint32_t RESERVED0   :11;                /* RESERVED0 */
        uint32_t WOT         :5;                 /* Number of outstanding write transactions that can be initiated by the AXI Master wrapper. Default value of this field is CDNS_USBSSDEV_AXI_WCD-1 (define parameter). The value written to this field should be the requested number of outstanding write transactions minus 1, thus the actual number of possible outstanding write transactions is one more than the programmed value. Note: This register should only be written to during the register initialization process */
        uint32_t RESERVED1   :11;                /* RESERVED1 */
    } B;
} IMX_USB3_USBSS_DMA_AXI_CTRL1_t;

/* Register DMA_AXI_CTRL1 - DMA AXI Master Control1 register. */
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_OFFSET 0x20310
/* Field ROT - Number of outstanding read transactions that can be initiated by the AXI Master wrapper. Default value of this field is CDNS_USBSSDEV_AXI_WCD-1 (define parameter). The value written to this field should be the requested number of outstanding read transactions minus 1, thus the actual number of possible outstanding read transactions is one more than the programmed value. Note: This register should only be written to during the register initialization process */
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_ROT_SHIFT 0
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_ROT_MASK 0x1F
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_ROT(v) (((v) << 0) & 0x1F)
/* Field RESERVED0 - RESERVED0 */
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_RESERVED0_SHIFT 5
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_RESERVED0_MASK 0xFFE0
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_RESERVED0(v) (((v) << 0x5) & 0xFFE0)
/* Field WOT - Number of outstanding write transactions that can be initiated by the AXI Master wrapper. Default value of this field is CDNS_USBSSDEV_AXI_WCD-1 (define parameter). The value written to this field should be the requested number of outstanding write transactions minus 1, thus the actual number of possible outstanding write transactions is one more than the programmed value. Note: This register should only be written to during the register initialization process */
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_WOT_SHIFT 16
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_WOT_MASK 0x1F0000
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_WOT(v) (((v) << 0x10) & 0x1F0000)
/* Field RESERVED1 - RESERVED1 */
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_RESERVED1_SHIFT 21
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_RESERVED1_MASK 0xFFE00000
#define IMX_USB3_USBSS_DMA_AXI_CTRL1_RESERVED1(v) (((v) << 0x15) & 0xFFE00000)

/* USB3_USBSS peripheral register structure */
typedef struct IMX_USB3_USBSS_struct_t {
    volatile IMX_USB3_USBSS_OTGCMD_t OTGCMD;  /* OTG Command */
    volatile IMX_USB3_USBSS_OTGSTS_t OTGSTS;  /* OTG Status */
    volatile IMX_USB3_USBSS_OTGSTATE_t OTGSTATE;  /* OTG State */
    volatile IMX_USB3_USBSS_OTGREFCLK_t OTGREFCLK;  /* OTG Reference Clock */
    volatile IMX_USB3_USBSS_OTGIEN_t OTGIEN;  /* OTG Interrupt Enable */
    volatile IMX_USB3_USBSS_OTGIVECT_t OTGIVECT;  /* OTG Interrupt Vector */
  volatile uint8_t reserved0[8];
    volatile IMX_USB3_USBSS_CLK_FREQ_t CLK_FREQ;  /* Clock Frequency */
    volatile IMX_USB3_USBSS_OTGTMR_t OTGTMR;  /* OTG Timer */
  volatile uint8_t reserved1[8];
    volatile IMX_USB3_USBSS_OTGVERSION_t OTGVERSION;  /* OTG Version */
    volatile IMX_USB3_USBSS_OTGCAPABILITY_t OTGCAPABILITY;  /* OTG Capabilities register */
  volatile uint8_t reserved2[8];
    volatile IMX_USB3_USBSS_OTGSIMULATE_t OTGSIMULATE;  /* OTG Simulate */
  volatile uint8_t reserved3[12];
    volatile IMX_USB3_USBSS_OTGANASTS_t OTGANASTS;  /* OTG Attach Detection Protocol (ADP) BC Status */
    volatile IMX_USB3_USBSS_ADP_RAMP_TIME_t ADP_RAMP_TIME;  /* Attach Detection Protocol (ADP) Ramp Time */
    volatile IMX_USB3_USBSS_OTGCTRL1_t OTGCTRL1;  /* OTG Control Register 1 */
    volatile IMX_USB3_USBSS_OTGCTRL2_t OTGCTRL2;  /* OTG Control Register 2 */
  volatile uint8_t reserved4[65440];
    volatile IMX_USB3_USBSS_HCIVERSION_CAPLENGTH_t HCIVERSION_CAPLENGTH;  /* HCIVERSION_CAPLENGTH */
    volatile IMX_USB3_USBSS_HCSPARAMS1_t HCSPARAMS1;  /* Structural Parameters 1 (HCSPARAMS1). */
    volatile IMX_USB3_USBSS_HCSPARAMS2_t HCSPARAMS2;  /* Structural Parameters 2 (HCSPARAMS 2). */
    volatile IMX_USB3_USBSS_HCSPARAMS3_t HCSPARAMS3;  /* Structural Parameters 3 (HCSPARAMS3). */
    volatile IMX_USB3_USBSS_HCCPARAMS_t HCCPARAMS;  /* Capability Parameters (HCCPARAMS). */
    volatile IMX_USB3_USBSS_DBOFF_t DBOFF;  /* This register defines the offset of the Doorbell Array base address from the Base. */
    volatile IMX_USB3_USBSS_RTSOFF_t RTSOFF;  /* This register defines the offset of the xHCI Runtime Registers from the Base. */
  volatile uint8_t reserved5[100];
    volatile IMX_USB3_USBSS_USBCMD_t USBCMD;  /* USB Command Register (USBCMD). */
    volatile IMX_USB3_USBSS_USBSTS_t USBSTS;  /* USB Status Register (USBSTS). */
    volatile IMX_USB3_USBSS_PAGESIZE_t PAGESIZE;  /* Page Size Register (PAGESIZE). */
  volatile uint8_t reserved6[8];
    volatile IMX_USB3_USBSS_DNCTRL_t DNCTRL;  /* Device Notification Control Register (DNCTRL). */
    volatile IMX_USB3_USBSS_CRCR_LO_t CRCR_LO;  /* Command Ring Control Register Low (CRCR_L). */
    volatile IMX_USB3_USBSS_CRCR_HI_t CRCR_HI;  /* Command Ring Control Register High (CRCR_HI). */
  volatile uint8_t reserved7[16];
    volatile IMX_USB3_USBSS_DCBAAP_LO_t DCBAAP_LO;  /* Device Context Base Address Array Pointer Register (DCBAAP_LO). */
    volatile IMX_USB3_USBSS_DCBAAP_HI_t DCBAAP_HI;  /* Device Context Base Address Array Pointer Register (DCBAAP_HI). */
    volatile IMX_USB3_USBSS_CONFIG_t CONFIG;  /* Configure Register (CONFIG). */
  volatile uint8_t reserved8[964];
    volatile IMX_USB3_USBSS_PORTSC1USB2_t PORTSC1USB2;  /* Port Status and Control Register for USB2 protocol port. */
    volatile IMX_USB3_USBSS_PORTPMSC1USB2_t PORTPMSC1USB2;  /* The USB2 Port Power Management Status and Control register. */
  volatile uint8_t reserved9[4];
    volatile IMX_USB3_USBSS_PORT1HLPMC_t PORT1HLPMC;  /* The optional normative USB2 Port Hardware LPM Control register provides the USB2 LPM parameters necessary for the xHC to automatically generate a LPM Token to the downstream device. */
    volatile IMX_USB3_USBSS_PORTSC1USB3_t PORTSC1USB3;  /* Port Status and Control Register for USB3 protocol port. */
    volatile IMX_USB3_USBSS_PORTPMSC1USB3_t PORTPMSC1USB3;  /* USB3 Port Power Management Status and Control register. */
    volatile IMX_USB3_USBSS_PORTLI1_t PORTLI1;  /* The USB3 Port Link Info register reports the Link Error Count. */
  volatile uint8_t reserved10[7012];
    volatile IMX_USB3_USBSS_MFINDEX_t MFINDEX;  /* This register is used by the system software to determine the current periodic frame. */
  volatile uint8_t reserved11[28];
    volatile IMX_USB3_USBSS_IMAN0_t IMAN0;  /* Interrupter Management Register (IMAN). */
    volatile IMX_USB3_USBSS_IMOD0_t IMOD0;  /* Interrupter Moderation Register (IMOD). */
    volatile IMX_USB3_USBSS_ERSTSZ0_t ERSTSZ0;  /* Event Ring Segment Table Size Register (ERSTSZ). */
    volatile IMX_USB3_USBSS_RESERVED0_t RESERVED0;
    volatile IMX_USB3_USBSS_ERSTBA0_LO_t ERSTBA0_LO;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERSTBA0_HI_t ERSTBA0_HI;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERDP0_LO_t ERDP0_LO;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_ERDP0_HI_t ERDP0_HI;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_IMAN1_t IMAN1;  /* Interrupter Management Register (IMAN). */
    volatile IMX_USB3_USBSS_IMOD1_t IMOD1;  /* Interrupter Moderation Register (IMOD). */
    volatile IMX_USB3_USBSS_ERSTSZ1_t ERSTSZ1;  /* Event Ring Segment Table Size Register (ERSTSZ). */
    volatile IMX_USB3_USBSS_RESERVED1_t RESERVED1;
    volatile IMX_USB3_USBSS_ERSTBA1_LO_t ERSTBA1_LO;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERSTBA1_HI_t ERSTBA1_HI;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERDP1_LO_t ERDP1_LO;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_ERDP1_HI_t ERDP1_HI;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_IMAN2_t IMAN2;  /* Interrupter Management Register (IMAN). */
    volatile IMX_USB3_USBSS_IMOD2_t IMOD2;  /* Interrupter Moderation Register (IMOD). */
    volatile IMX_USB3_USBSS_ERSTSZ2_t ERSTSZ2;  /* Event Ring Segment Table Size Register (ERSTSZ). */
    volatile IMX_USB3_USBSS_RESERVED2_t RESERVED2;
    volatile IMX_USB3_USBSS_ERSTBA2_LO_t ERSTBA2_LO;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERSTBA2_HI_t ERSTBA2_HI;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERDP2_LO_t ERDP2_LO;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_ERDP2_HI_t ERDP2_HI;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_IMAN3_t IMAN3;  /* Interrupter Management Register (IMAN). */
    volatile IMX_USB3_USBSS_IMOD3_t IMOD3;  /* Interrupter Moderation Register (IMOD). */
    volatile IMX_USB3_USBSS_ERSTSZ3_t ERSTSZ3;  /* Event Ring Segment Table Size Register (ERSTSZ). */
    volatile IMX_USB3_USBSS_RESERVED3_t RESERVED3;
    volatile IMX_USB3_USBSS_ERSTBA3_LO_t ERSTBA3_LO;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERSTBA3_HI_t ERSTBA3_HI;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERDP3_LO_t ERDP3_LO;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_ERDP3_HI_t ERDP3_HI;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_IMAN4_t IMAN4;  /* Interrupter Management Register (IMAN). */
    volatile IMX_USB3_USBSS_IMOD4_t IMOD4;  /* Interrupter Moderation Register (IMOD). */
    volatile IMX_USB3_USBSS_ERSTSZ4_t ERSTSZ4;  /* Event Ring Segment Table Size Register (ERSTSZ). */
    volatile IMX_USB3_USBSS_RESERVED4_t RESERVED4;
    volatile IMX_USB3_USBSS_ERSTBA4_LO_t ERSTBA4_LO;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERSTBA4_HI_t ERSTBA4_HI;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERDP4_LO_t ERDP4_LO;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_ERDP4_HI_t ERDP4_HI;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_IMAN5_t IMAN5;  /* Interrupter Management Register (IMAN). */
    volatile IMX_USB3_USBSS_IMOD5_t IMOD5;  /* Interrupter Moderation Register (IMOD). */
    volatile IMX_USB3_USBSS_ERSTSZ5_t ERSTSZ5;  /* Event Ring Segment Table Size Register (ERSTSZ). */
    volatile IMX_USB3_USBSS_RESERVED5_t RESERVED5;
    volatile IMX_USB3_USBSS_ERSTBA5_LO_t ERSTBA5_LO;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERSTBA5_HI_t ERSTBA5_HI;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERDP5_LO_t ERDP5_LO;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_ERDP5_HI_t ERDP5_HI;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_IMAN6_t IMAN6;  /* Interrupter Management Register (IMAN). */
    volatile IMX_USB3_USBSS_IMOD6_t IMOD6;  /* Interrupter Moderation Register (IMOD). */
    volatile IMX_USB3_USBSS_ERSTSZ6_t ERSTSZ6;  /* Event Ring Segment Table Size Register (ERSTSZ). */
    volatile IMX_USB3_USBSS_RESERVED6_t RESERVED6;
    volatile IMX_USB3_USBSS_ERSTBA6_LO_t ERSTBA6_LO;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERSTBA6_HI_t ERSTBA6_HI;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERDP6_LO_t ERDP6_LO;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_ERDP6_HI_t ERDP6_HI;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_IMAN7_t IMAN7;  /* Interrupter Management Register (IMAN). */
    volatile IMX_USB3_USBSS_IMOD7_t IMOD7;  /* Interrupter Moderation Register (IMOD). */
    volatile IMX_USB3_USBSS_ERSTSZ7_t ERSTSZ7;  /* Event Ring Segment Table Size Register (ERSTSZ). */
    volatile IMX_USB3_USBSS_RESERVED7_t RESERVED7;
    volatile IMX_USB3_USBSS_ERSTBA7_LO_t ERSTBA7_LO;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERSTBA7_HI_t ERSTBA7_HI;  /* The Event Ring Segment Table Base Address Register identifies the start address of the Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_ERDP7_LO_t ERDP7_LO;  /* Event Ring Dequeue Pointer Register (ERDP). */
    volatile IMX_USB3_USBSS_ERDP7_HI_t ERDP7_HI;  /* Event Ring Dequeue Pointer Register (ERDP). */
  volatile uint8_t reserved12[3808];
    volatile IMX_USB3_USBSS_DB0_t DB0;    /* Host Controller Doorbell. */
    volatile IMX_USB3_USBSS_DB1_t DB1;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB2_t DB2;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB3_t DB3;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB4_t DB4;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB5_t DB5;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB6_t DB6;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB7_t DB7;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB8_t DB8;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB9_t DB9;    /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB10_t DB10;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB11_t DB11;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB12_t DB12;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB13_t DB13;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB14_t DB14;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB15_t DB15;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB16_t DB16;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB17_t DB17;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB18_t DB18;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB19_t DB19;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB20_t DB20;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB21_t DB21;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB22_t DB22;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB23_t DB23;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB24_t DB24;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB25_t DB25;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB26_t DB26;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB27_t DB27;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB28_t DB28;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB29_t DB29;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB30_t DB30;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB31_t DB31;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
    volatile IMX_USB3_USBSS_DB32_t DB32;  /* The Doorbell Array is organized as an array of up to 256 Doorbell Registers. */
  volatile uint8_t reserved13[20348];
    volatile IMX_USB3_USBSS_XECP_PORT_CAP_REG_t XECP_PORT_CAP_REG;  /* Extended capability for USB 3. */
    volatile IMX_USB3_USBSS_XECP_PORT_1_REG_t XECP_PORT_1_REG;  /* Extended capability for USB 3. */
    volatile IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CAP_t XECP_CDNS_DEBUG_BUS_CAP;  /* xHCI Debug Bus Capability. */
    volatile IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_CTRL_t XECP_CDNS_DEBUG_BUS_CTRL;  /* xHCI Debug Bus Control. */
    volatile IMX_USB3_USBSS_XECP_CDNS_DEBUG_BUS_STATUS_t XECP_CDNS_DEBUG_BUS_STATUS;  /* xHCI Debug Bus Status. */
    volatile IMX_USB3_USBSS_XECP_PM_CAP_t XECP_PM_CAP;  /* Extended Power Management capability register. */
    volatile IMX_USB3_USBSS_XECP_PM_PMCSR_t XECP_PM_PMCSR;  /* Extended Power Management Control/Status register. */
    volatile IMX_USB3_USBSS_XECP_MSI_CAP_t XECP_MSI_CAP;  /* Message Signaled Interrupts (MSI) configuration register. */
    volatile IMX_USB3_USBSS_XECP_MSI_ADDR_L_t XECP_MSI_ADDR_L;  /* Message Lower Address for MSI. */
    volatile IMX_USB3_USBSS_XECP_MSI_ADDR_H_t XECP_MSI_ADDR_H;  /* Message Upper Address for MSI. */
    volatile IMX_USB3_USBSS_XECP_MSI_DATA_t XECP_MSI_DATA;  /* Message data for MSI. */
    volatile IMX_USB3_USBSS_XECP_AXI_CAP_t XECP_AXI_CAP;  /* AXI Master Wrapper Extended Capability. */
    volatile IMX_USB3_USBSS_XECP_AXI_CFG0_t XECP_AXI_CFG0;  /* AXI Master Wrapper Extended Capability Configuration Register. */
    volatile IMX_USB3_USBSS_XECP_AXI_CTRL0_t XECP_AXI_CTRL0;  /* AXI Master Wrapper Extended Capability Control Register 0. */
    volatile IMX_USB3_USBSS_XECP_AXI_CTRL1_t XECP_AXI_CTRL1;  /* AXI Master Wrapper Extended Capability Control Register 1. */
    volatile IMX_USB3_USBSS_XECP_AXI_CTRL2_t XECP_AXI_CTRL2;  /* AXI Master Wrapper Extended Capability Control Register 2. */
    volatile IMX_USB3_USBSS_XECP_SUPP_USB2_CAP0_t XECP_SUPP_USB2_CAP0;  /* xHCI Supported Protocol Capability. */
    volatile IMX_USB3_USBSS_XECP_SUPP_USB2_CAP1_t XECP_SUPP_USB2_CAP1;  /* xHCI Supported Protocol Capability. */
    volatile IMX_USB3_USBSS_XECP_SUPP_USB2_CAP2_t XECP_SUPP_USB2_CAP2;  /* xHCI Supported Protocol Capability; USB 2. */
    volatile IMX_USB3_USBSS_XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE_t XECP_SUPP_USB2_PROTOCOL_SLOT_TYPE;  /* Protocol Slot Type. */
    volatile IMX_USB3_USBSS_XECP_PSI_FULL_SPEED_t XECP_PSI_FULL_SPEED;  /* Protocol Speed ID, xHCI Supported Protocol Capability */
    volatile IMX_USB3_USBSS_XECP_PSI_LOW_SPEED_t XECP_PSI_LOW_SPEED;  /* Protocol Speed ID, xHCI Supported Protocol Capability */
    volatile IMX_USB3_USBSS_XECP_PSI_HIGH_SPEED_t XECP_PSI_HIGH_SPEED;  /* Protocol Speed ID, xHCI Supported Protocol Capability */
  volatile uint8_t reserved14[4];
    volatile IMX_USB3_USBSS_XECP_SUPP_USB3_CAP0_t XECP_SUPP_USB3_CAP0;  /* xHCI Supported Protocol Capability. */
    volatile IMX_USB3_USBSS_XECP_SUPP_USB3_CAP1_t XECP_SUPP_USB3_CAP1;  /* xHCI Supported Protocol Capability. */
    volatile IMX_USB3_USBSS_XECP_SUPP_USB3_CAP2_t XECP_SUPP_USB3_CAP2;  /* xHCI Supported Protocol Capability; USB 3. */
    volatile IMX_USB3_USBSS_XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE_t XECP_SUPP_USB3_PROTOCOL_SLOT_TYPE;  /* Protocol Slot Type. */
    volatile IMX_USB3_USBSS_PSI_SUPER_SPEED_t PSI_SUPER_SPEED;  /* Protocol Speed ID, xHCI Supported Protocol Capability */
  volatile uint8_t reserved15[12];
    volatile IMX_USB3_USBSS_XECP_CMDM_STS0_t XECP_CMDM_STS0;  /* Command Ring related status register. */
    volatile IMX_USB3_USBSS_XECP_CMDM_RESERVED_1_t XECP_CMDM_RESERVED_1;  /* Event ring manager module reserved space. */
    volatile IMX_USB3_USBSS_XECP_CMDM_RESERVED_2_t XECP_CMDM_RESERVED_2;  /* Event ring manager module reserved space. */
    volatile IMX_USB3_USBSS_XECP_CMDM_RESERVED_3_t XECP_CMDM_RESERVED_3;  /* Event ring manager module reserved space. */
    volatile IMX_USB3_USBSS_XECP_CMDM_RESERVED_4_t XECP_CMDM_RESERVED_4;  /* Event ring manager module reserved space. */
    volatile IMX_USB3_USBSS_XECP_CMDM_RESERVED_5_t XECP_CMDM_RESERVED_5;  /* Event ring manager module reserved space. */
    volatile IMX_USB3_USBSS_XECP_CMDM_CTRL_REG1_t XECP_CMDM_CTRL_REG1;  /* Command Manager Control register 1. */
    volatile IMX_USB3_USBSS_XECP_CMDM_CTRL_REG2_t XECP_CMDM_CTRL_REG2;  /* Command Manager Control register 2. */
    volatile IMX_USB3_USBSS_XECP_CMDM_CTRL_REG3_t XECP_CMDM_CTRL_REG3;  /* Command Manager Control register 3. */
  volatile uint8_t reserved16[12];
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_CAP_t XECP_HOST_CTRL_CAP;  /* This is a register that describes the host controller's extended capability location. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_RSVD_t XECP_HOST_CTRL_RSVD;  /* Reserved space. */
    volatile IMX_USB3_USBSS_XECP_HOST_CLR_MASK_REG_t XECP_HOST_CLR_MASK_REG;  /* Override Endpoint Flow Control. */
    volatile IMX_USB3_USBSS_XECP_HOST_CLR_IN_EP_VALID_REG_t XECP_HOST_CLR_IN_EP_VALID_REG;  /* Clear Active IN EP ID Control. */
    volatile IMX_USB3_USBSS_XECP_HOST_CLR_PMASK_REG_t XECP_HOST_CLR_PMASK_REG;  /* Clear Poll Mask Control. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_OCRD_REG_t XECP_HOST_CTRL_OCRD_REG;  /* Port Credit Control. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_LO_t XECP_HOST_CTRL_TEST_BUS_LO;  /* Test Bus Low Bits: Host controller test bus low 32 bits. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_TEST_BUS_HI_t XECP_HOST_CTRL_TEST_BUS_HI;  /* Test Bus High Bits: Host controller test bus high 32 bits. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG1_t XECP_HOST_CTRL_TRM_REG1;  /* Host Control Transfer Manager (TRM) register. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG1_t XECP_HOST_CTRL_SCH_REG1;  /* Host Control Scheduler register. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_ODMA_REG_t XECP_HOST_CTRL_ODMA_REG;  /* Host Control ODMA. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_IDMA_REG_t XECP_HOST_CTRL_IDMA_REG;  /* Host Control IDMA. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_CTRL_t XECP_HOST_CTRL_PORT_CTRL;  /* Global Port Control. */
  volatile uint8_t reserved17[28];
    volatile IMX_USB3_USBSS_XECP_AUX_CTRL_REG_t XECP_AUX_CTRL_REG;  /* AUX Reset Control. */
    volatile IMX_USB3_USBSS_XECP_HOST_BW_OV_SS_REG_t XECP_HOST_BW_OV_SS_REG;  /* Super Speed Bandwidth Overload. */
    volatile IMX_USB3_USBSS_XECP_HOST_BW_OV_HS_REG_t XECP_HOST_BW_OV_HS_REG;  /* High Speed TT Bandwidth Overload. */
    volatile IMX_USB3_USBSS_XECP_HOST_BW_OV_FS_LS_REG_t XECP_HOST_BW_OV_FS_LS_REG;  /* Bandwidth Overload Full and Low Speed. */
    volatile IMX_USB3_USBSS_XECP_HOST_BW_OV_SYS_REG_t XECP_HOST_BW_OV_SYS_REG;  /* System Bandwidth Overload. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG_t XECP_HOST_CTRL_SCH_ASYNC_DELAY_REG;  /* Scheduler Async Delay. */
    volatile IMX_USB3_USBSS_XECP_UPORTS_PON_RST_REG_t XECP_UPORTS_PON_RST_REG;  /* AUX Power PHY Reset. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG3_t XECP_HOST_CTRL_TRM_REG3;  /* Host Control Transfer Manager (TRM) register. */
    volatile IMX_USB3_USBSS_XECP_AUX_CTRL_REG1_t XECP_AUX_CTRL_REG1;  /* AUX Power Management Control 1. */
  volatile uint8_t reserved18[4];
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_WATERMARK_REG_t XECP_HOST_CTRL_WATERMARK_REG;  /* Port Watermark. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG_t XECP_HOST_CTRL_PORT_LINK_REG;  /* SuperSpeed Port Link Control. */
    volatile IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG1_t XECP_USB2_LINK_MGR_CTRL_REG1;  /* USB2 Port Link Control 1,2,3,4. */
    volatile IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG2_t XECP_USB2_LINK_MGR_CTRL_REG2;  /* USB2 Port Link Control 1, 2, 3, 4. */
    volatile IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG3_t XECP_USB2_LINK_MGR_CTRL_REG3;  /* USB2 Port Link Control 1, 2, 3, 4. */
    volatile IMX_USB3_USBSS_XECP_USB2_LINK_MGR_CTRL_REG4_t XECP_USB2_LINK_MGR_CTRL_REG4;  /* USB2 Port Link Control 1, 2, 3, 4. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX_REG_t XECP_HOST_CTRL_BW_MAX_REG;  /* USB2 Max Bandwidth Control. */
    volatile IMX_USB3_USBSS_XECP_FPGA_REVISION_REG_t XECP_FPGA_REVISION_REG;  /* FPGA_REVISION_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_INTF_CTRL_REG_t XECP_HOST_INTF_CTRL_REG;  /* Host interface control register. */
    volatile IMX_USB3_USBSS_XECP_BW_OV_SS_BURST_REG_t XECP_BW_OV_SS_BURST_REG;  /* BW_OV_SS_BURST_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_TRM_REG2_t XECP_HOST_CTRL_TRM_REG2;  /* Host Control Transfer Manager (TRM) register. */
  volatile uint8_t reserved19[20];
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX1_REG_t XECP_HOST_CTRL_BW_MAX1_REG;  /* HOST_CTRL_BW_MAX1_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_BW_MAX2_REG_t XECP_HOST_CTRL_BW_MAX2_REG;  /* HOST_CTRL_BW_MAX2_REG. */
    volatile IMX_USB3_USBSS_XECP_USB2_LINESTATE_REG_t XECP_USB2_LINESTATE_REG;  /* USB2_LINESTATE_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER1_REG_t XECP_HOST_PROTO_GAP_TIMER1_REG;  /* HOST_PROTO_GAP_TIMER1_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_PROTO_GAP_TIMER2_REG_t XECP_HOST_PROTO_GAP_TIMER2_REG;  /* HOST_PROTO_GAP_TIMER2_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_PROTO_BTO_TIMER_REG_t XECP_HOST_PROTO_BTO_TIMER_REG;  /* HOST_PROTO_BTO_TIMER_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH_REG_t XECP_HOST_CTRL_PSCH_REG;  /* HOST_CTRL_PSCH_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_PSCH1_REG_t XECP_HOST_CTRL_PSCH1_REG;  /* HOST_CTRL_PSCH1_REG. */
  volatile uint8_t reserved20[8];
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG_t XECP_HOST_CTRL_LTM_REG;  /* HOST_CTRL_LTM_REG. */
    volatile IMX_USB3_USBSS_XECP_AUX_CTRL_REG2_t XECP_AUX_CTRL_REG2;  /* AUX Power Management Control 1. */
    volatile IMX_USB3_USBSS_XECP_AUX_CTRL_REG3_t XECP_AUX_CTRL_REG3;  /* Configuration bits for USB2 PHY. */
    volatile IMX_USB3_USBSS_XECP_DEBUG_CTRL_REG_t XECP_DEBUG_CTRL_REG;  /* DEBUG_CTRL_REG. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_SCH_REG2_t XECP_HOST_CTRL_SCH_REG2;  /* Host Control Scheduler. */
    volatile IMX_USB3_USBSS_XECP_AUX_DEBUG_READ_ONLY_t XECP_AUX_DEBUG_READ_ONLY;  /* AUX_DEBUG_READ_ONLY. */
    volatile IMX_USB3_USBSS_XECP_AUX_CTRL_PORTNUM_REG_t XECP_AUX_CTRL_PORTNUM_REG;  /* AUX_CTRL_PORTNUM_REG. */
    volatile IMX_USB3_USBSS_XECP_AUX_CTRL_DEV_REMOVE_REG_t XECP_AUX_CTRL_DEV_REMOVE_REG;  /* Feature #3002 (Device Removable in PORTSC). */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_DESC_t XECP_HOST_CTRL_DEBUG_PORT_DESC;  /* dbgp_desc_ctrl_reg. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_TRM_t XECP_HOST_CTRL_DEBUG_PORT_TRM;  /* dbgp_trm_ctrl_reg. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_IDMA_t XECP_HOST_CTRL_DEBUG_PORT_IDMA;  /* dbgp_idma_ctrl_reg. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_ODMA_t XECP_HOST_CTRL_DEBUG_PORT_ODMA;  /* dbgp_odma_ctrl_reg. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_DEBUG_PORT_MISC_t XECP_HOST_CTRL_DEBUG_PORT_MISC;  /* dbgp_misc_ctrl_reg. */
  volatile uint8_t reserved21[28];
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_TTE_REG1_t XECP_HOST_CTRL_TTE_REG1;  /* Specific control register for SCH. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG1_t XECP_HOST_CTRL_LTM_REG1;  /* HOST_CTRL_LTM_REG1. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_LTM_REG2_t XECP_HOST_CTRL_LTM_REG2;  /* HOST_CTRL_LTM_REG2. */
  volatile uint8_t reserved22[20];
    volatile IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_0_t XECP_AUX_SCRATCHPAD_0;  /* For internal use. */
    volatile IMX_USB3_USBSS_XECP_AUX_SCRATCHPAD_1_t XECP_AUX_SCRATCHPAD_1;  /* For internal use. */
  volatile uint8_t reserved23[8];
    volatile IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG_t XECP_BATTERY_CHARGE_REG;  /* Battery charge mode and enable register. */
    volatile IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG1_t XECP_BATTERY_CHARGE_REG1;  /* Battery charge control register 1. */
    volatile IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG2_t XECP_BATTERY_CHARGE_REG2;  /* Battery charge control register 2. */
    volatile IMX_USB3_USBSS_XECP_BATTERY_CHARGE_REG3_t XECP_BATTERY_CHARGE_REG3;  /* Battery charge debug register. */
    volatile IMX_USB3_USBSS_XECP_HOST_CTRL_PORT_LINK_REG1_t XECP_HOST_CTRL_PORT_LINK_REG1;  /* Feature #581. */
  volatile uint8_t reserved24[332];
    volatile IMX_USB3_USBSS_XECP_USBLEGSUP_t XECP_USBLEGSUP;  /* USB Legacy Support Capability. */
    volatile IMX_USB3_USBSS_XECP_USBLEGCTLSTS_t XECP_USBLEGCTLSTS;  /* USB Legacy Support Control Status. */
  volatile uint8_t reserved25[8];
    volatile IMX_USB3_USBSS_XECP_DCID_t XECP_DCID;  /* The Debug Capability ID Register links the USB Debug Capability into the xHCI list of Extended Capabilities and defines its basic capabilities. */
    volatile IMX_USB3_USBSS_XECP_DCDB_t XECP_DCDB;  /* Debug Capability Doorbell Register */
    volatile IMX_USB3_USBSS_XECP_DCERSTSZ_t XECP_DCERSTSZ;  /* The Debug Capability Event Ring Segment Table Size Register defines the number of segments supported by the Debug Capability Event Ring Segment Table. */
    volatile IMX_USB3_USBSS_XECP_RSVD_0C_t XECP_RSVD_0C;  /* XECP_RSVD_0C, RsvdZ. */
    volatile IMX_USB3_USBSS_XECP_DCERSTBA_LOW_t XECP_DCERSTBA_LOW;  /* Debug Capability Event Ring Segment Table Base Address Register (DCERSTBA). */
    volatile IMX_USB3_USBSS_XECP_DCERSTBA_HIGH_t XECP_DCERSTBA_HIGH;  /* Debug Capability Event Ring Segment Table Base Address Register (DCERSTBA). */
    volatile IMX_USB3_USBSS_XECP_DCERDP_LOW_t XECP_DCERDP_LOW;  /* Debug Capability Event Ring Dequeue Pointer Register (DCERDP). */
    volatile IMX_USB3_USBSS_XECP_DCERDP_HIGH_t XECP_DCERDP_HIGH;  /* Debug Capability Event Ring Dequeue Pointer Register (DCERDP). */
    volatile IMX_USB3_USBSS_XECP_DCCTRL_t XECP_DCCTRL;  /* The Debug Capability Control Register is used to manage the Debug Capability. */
    volatile IMX_USB3_USBSS_XECP_DCST_t XECP_DCST;  /* The Debug Capability Status Register reports capability related status information to software. */
    volatile IMX_USB3_USBSS_XECP_DCPORTSC_t XECP_DCPORTSC;  /* Debug Capability Port Status and Control Register (DCPORTSC). */
    volatile IMX_USB3_USBSS_XECP_RSVD_2C_t XECP_RSVD_2C;  /* XECP_RSVD_2C, RsvdZ. */
    volatile IMX_USB3_USBSS_XECP_DCCP_LOW_t XECP_DCCP_LOW;  /* Debug Capability Context Pointer Register (DCCP). */
    volatile IMX_USB3_USBSS_XECP_DCCP_HIGH_t XECP_DCCP_HIGH;  /* Debug Capability Context Pointer Register (DCCP). */
    volatile IMX_USB3_USBSS_XECP_DCDDI1_t XECP_DCDDI1;  /* Debug Capability Device Descriptor Info Register 1 (DCDDI1). */
    volatile IMX_USB3_USBSS_XECP_DCDDI2_t XECP_DCDDI2;  /* The Debug Capability Device Descriptor Register 2 identifies the Device Revision and Product ID values that shall be reported by DbC in its Device Descriptor when it is enumerated by a Debug Host. */
  volatile uint8_t reserved26[1088];
    volatile IMX_USB3_USBSS_XECP_USB3_TEST_PORT0_REG_t XECP_USB3_TEST_PORT0_REG;  /* USB3_TEST_PORT_REG. */
  volatile uint8_t reserved27[30716];
    volatile IMX_USB3_USBSS_USB_CONF_t USB_CONF;  /* Global Configuration Register */
    volatile IMX_USB3_USBSS_USB_STS_t USB_STS;  /* Global Status Register */
    volatile IMX_USB3_USBSS_USB_CMD_t USB_CMD;  /* Global Command Register */
    volatile IMX_USB3_USBSS_USB_IPTN_t USB_IPTN;
    volatile IMX_USB3_USBSS_USB_LPM_t USB_LPM;  /* USB LPM Register */
    volatile IMX_USB3_USBSS_USB_IEN_t USB_IEN;  /* Interrupt Enable Register */
    volatile IMX_USB3_USBSS_USB_ISTS_t USB_ISTS;  /* USB Interrupt Status Register Each bit (interrupt flag) from this register can be cleared by writing '1'. */
    volatile IMX_USB3_USBSS_EP_SEL_t EP_SEL;  /* Endpoint Select Register This register is used in conjunction with Endpoint Configuration, Command, Status, and Transfer ring address registers. */
    volatile IMX_USB3_USBSS_EP_TRADDR_t EP_TRADDR;  /* Endpoint Transfer Ring Address Register All bytes of the register must be written, to store the TRADDR value. */
    volatile IMX_USB3_USBSS_EP_CFG_t EP_CFG;  /* Endpoint Configuration Register The endpoint configuration can be changed only once after reset (or configuration reset: USB_CONF. */
    volatile IMX_USB3_USBSS_EP_CMD_t EP_CMD;  /* Endpoint Command Register */
    volatile IMX_USB3_USBSS_EP_STS_t EP_STS;  /* Endpoint Status Register. */
    volatile IMX_USB3_USBSS_EP_STS_SID_t EP_STS_SID;  /* Endpoint Status Register */
    volatile IMX_USB3_USBSS_EP_STS_EN_t EP_STS_EN;  /* Endpoint Status Register Enable */
    volatile IMX_USB3_USBSS_DRBL_t DRBL;  /* Doorbell Register - used for initiating transfers with one access to USBSS-DEV, without use of the EP_SEL register(+EP_CMD. */
    volatile IMX_USB3_USBSS_EP_IEN_t EP_IEN;  /* Endpoints Interrupt Enable Register (1 - enables interrupt, 0 - disables interrupt) */
    volatile IMX_USB3_USBSS_EP_ISTS_t EP_ISTS;  /* Endpoints Interrupt Status Register. */
    volatile IMX_USB3_USBSS_USB_PWR_t USB_PWR;  /* Global power configuration register */
    volatile IMX_USB3_USBSS_USB_CONF2_t USB_CONF2;  /* USB configuration register 2 */
    volatile IMX_USB3_USBSS_USB_CAP1_t USB_CAP1;  /* USB Capability Register 1 */
    volatile IMX_USB3_USBSS_USB_CAP2_t USB_CAP2;  /* USB Capability Register */
    volatile IMX_USB3_USBSS_USB_CAP3_t USB_CAP3;  /* USB Capability Register 3. */
    volatile IMX_USB3_USBSS_USB_CAP4_t USB_CAP4;  /* ISO HW support for Endpoints implemented EPINI. */
    volatile IMX_USB3_USBSS_USB_CAP5_t USB_CAP5;  /* Bulk Stream HW support for Endpoints implemented. */
    volatile IMX_USB3_USBSS_USB_CAP6_t USB_CAP6;  /* Device controller version. */
    volatile IMX_USB3_USBSS_USB_CPKT1_t USB_CPKT1;  /* Custom Packet value. */
    volatile IMX_USB3_USBSS_USB_CPKT2_t USB_CPKT2;  /* Custom Packet value. */
    volatile IMX_USB3_USBSS_USB_CPKT3_t USB_CPKT3;  /* Custom Packet value. */
  volatile uint8_t reserved28[144];
    volatile IMX_USB3_USBSS_CFG_REG1_t CFG_REG1;  /* VBUS debouncer Configuration Register 1 */
    volatile IMX_USB3_USBSS_DBG_LINK1_t DBG_LINK1;  /* USB3. */
    volatile IMX_USB3_USBSS_DBG_LINK2_t DBG_LINK2;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG4_t CFG_REG4;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG5_t CFG_REG5;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG6_t CFG_REG6;  /* Configuration Register 6 */
    volatile IMX_USB3_USBSS_CFG_REG7_t CFG_REG7;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG8_t CFG_REG8;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG9_t CFG_REG9;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG10_t CFG_REG10;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG11_t CFG_REG11;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG12_t CFG_REG12;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG13_t CFG_REG13;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG14_t CFG_REG14;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG15_t CFG_REG15;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG16_t CFG_REG16;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG17_t CFG_REG17;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG18_t CFG_REG18;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG19_t CFG_REG19;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG20_t CFG_REG20;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG21_t CFG_REG21;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG22_t CFG_REG22;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG23_t CFG_REG23;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG24_t CFG_REG24;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG25_t CFG_REG25;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG26_t CFG_REG26;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG27_t CFG_REG27;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG28_t CFG_REG28;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG29_t CFG_REG29;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG30_t CFG_REG30;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG31_t CFG_REG31;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG32_t CFG_REG32;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG33_t CFG_REG33;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG34_t CFG_REG34;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG35_t CFG_REG35;  /* USB3. */
  volatile uint8_t reserved29[32];
    volatile IMX_USB3_USBSS_CFG_REG36_t CFG_REG36;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG37_t CFG_REG37;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG38_t CFG_REG38;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG39_t CFG_REG39;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG40_t CFG_REG40;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG41_t CFG_REG41;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG42_t CFG_REG42;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG43_t CFG_REG43;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG44_t CFG_REG44;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG45_t CFG_REG45;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG46_t CFG_REG46;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG47_t CFG_REG47;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG48_t CFG_REG48;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG49_t CFG_REG49;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG50_t CFG_REG50;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG51_t CFG_REG51;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG52_t CFG_REG52;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG53_t CFG_REG53;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG54_t CFG_REG54;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG55_t CFG_REG55;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG56_t CFG_REG56;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG57_t CFG_REG57;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG58_t CFG_REG58;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG59_t CFG_REG59;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG60_t CFG_REG60;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG61_t CFG_REG61;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG62_t CFG_REG62;  /* USB3. */
    volatile IMX_USB3_USBSS_CFG_REG63_t CFG_REG63;  /* USB3. */
  volatile uint8_t reserved30[4];
    volatile IMX_USB3_USBSS_CFG_REG64_t CFG_REG64;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG65_t CFG_REG65;  /* USB2. */
    volatile IMX_USB3_USBSS_CFG_REG66_t CFG_REG66;  /* USB2. */
  volatile uint8_t reserved31[212];
    volatile IMX_USB3_USBSS_DMA_AXI_CTRL_t DMA_AXI_CTRL;  /* DMA AXI Master Control register. */
    volatile IMX_USB3_USBSS_DMA_AXI_ID_t DMA_AXI_ID;  /* DMA AXI Master ID register. */
    volatile IMX_USB3_USBSS_DMA_AXI_CAP_t DMA_AXI_CAP;  /* DMA AXI Master Extended Capability register. */
    volatile IMX_USB3_USBSS_DMA_AXI_CTRL0_t DMA_AXI_CTRL0;  /* DMA AXI Master Control0 register. */
    volatile IMX_USB3_USBSS_DMA_AXI_CTRL1_t DMA_AXI_CTRL1;  /* DMA AXI Master Control1 register. */
} IMX_USB3_USBSS_t;



#endif /* IMX_USB3_USBSS_H */

#if defined(__QNXNTO__) && defined(__USESRCVERSION)
#include <sys/srcversion.h>
__SRCVERSION("$URL: http://svn.ott.qnx.com/product/mainline/hardware/startup/lib/public/aarch64/imx8xp/imx_usb3.h $ $Rev: 850159 $")
#endif
