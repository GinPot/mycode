<html><head>
<title>Elvis-2.2_0 Ex Mode</title>
</head><body>

<h1>4. EX COMMAND MODE</h1>

Ex is an editing mode in which Elvis acts like a line editor.
This means that you type in a command line, and when the line is complete
Elvis executes it on the current text buffer.
I.e., in ex each <em>line</em> (or group of lines) is a command,
as opposed to vi where each <em>character</em> (or group of characters) is a
command.
The commands are listed below either <a href="#GROUP">grouped by function</a>
or <a href="#INDEX">listed in alphabetical order</a>.

<p>Typically, ex commands are used to do perform complex actions such as
global search &amp; replace, or actions which require an argument such as
writing the edit buffer out to a different file.

<p>Ex is also used as the configuration language for Elvis;
configuration scripts such as <a href="elvisses.html#elvis.ini">elvis.ini</a>,
.exrc (or elvis.rc), and <a href="elvisses.html#elvis.arf">elvis.arf</a>
contain a series of ex commands.

<p>You can switch freely between vi and ex.
If you're in vi mode, you can enter a single ex command line via the
visual <a href="elvisvi.html#colon">:</a> command, or more permanently switch via
the visual <a href="elvisvi.html#Q">Q</a> command.
If you're in ex mode, you can switch to vi mode via ex's
<a href="#visual">:vi</a> command.

<p>Normally Elvis will start in vi mode, but you can force it to start in
ex mode by supplying a <strong>-e</strong> command line flag.
On UNIX systems, you can link Elvis to a name which ends with "x" to
achieve the same effect.

<p>The remainder of this section discusses how to enter lines, the general
syntax of an ex command line, and the specific commands which Elvis supports.

<h2>4.1 Entering lines</h2>
In Elvis, when you're typing in an ex command line
you're really inputting text into a buffer named "Elvis ex history".
All of the usual <a href="elvisinp.html">input mode</a> commands are available,
including <kbd>Backspace</kbd> to erase the previous character,
<kbd>Control-W</kbd> to erase the previous word, and so on.

<p>Any previously entered lines will still be in the "Elvis ex history"
buffer, and you can use the arrow keys to move back and edit earlier commands.
You can even use the <kbd>Control-O</kbd> input-mode command with
the <a href="elvisvi.html#slash">?<var>regexp</var></a> visual command,
to search for an earlier command line.

<p>When you hit the <kbd>Enter</kbd> key on a line in the "Elvis ex history"
buffer, Elvis sends that line to the ex command parser,
which is described in the next section.

<h3>4.1.1 An example</h3>

Suppose you enter the command...
<pre>
	:e ~/proj1/src/header.h
</pre>
...and then realize that you really wanted "header2.h" instead of "header.h".
You simplest way to get "header2.h" is to...
<ol>
<li>Hit the <kbd>:</kbd> key to start a new ex command line.
<li>Hit the <kbd>Up</kbd> arrow key, or <kbd>^O k</kbd> to move back to the
    preceding command line (which was "<code>:e ~/proj1/src/header.h</code>").
    <kbd>^O k</kbd> works because <kbd>^O</kbd> reads and executes one vi
    command, and the <kbd>k</kbd> vi command moves the cursor back one line.
    The <kbd>Up</kbd> arrow key works because it is mapped to "visual k",
    which does exactly the same thing as <kbd>^O k</kbd>.
<li>Hit the <kbd>Left</kbd> arrow key twice, or <kbd>^O 2 h</kbd>, to move
    the cursor back to the '.' character in "header.h".
<li>Hit <kbd>2</kbd> to insert a '2' before the '.' character.  At this point,
    the line should look like "<code>:e ~/proj1/src/header2.h</code>".
<li>Hit <kbd>Enter</kbd> to submit the revised command line.
</ol>

<p>Or suppose you really wanted "footer2.h" instead of "header2.h".
This is a little trickier because you want to delete characters in the
middle of the command line, before inserting the correct text.
The simplest way to do this is move the cursor to a point just <em>after</em>
the last character that you want to delete, and then backspace over them.
The steps are:
<ol>
<li>Hit the <kbd>:</kbd> key to start a new ex command line.
<li>Hit the <kbd>Up</kbd> arrow key or <kbd>^O k</kbd> repeatedly to move
    back to the "<code>:e ~/proj1/src/header2.h</code>"command line.
<li>Hit the <kbd>Left</kbd> arrow key five times, or <kbd>^O 5 h</kbd>, to move
    the cursor back to the last 'e' character in "header2.h".
<li>Hit the <kbd>Backspace</kbd> key four times to delete the word "head".
    It will still show on the screen, but Elvis will know that it has been
    deleted.  This is the same sort of behavior that Elvis (and vi) exhibits
    when you backspace over newly entered text in input mode.
<li>Type <kbd>f o o t</kbd> to insert "foot" where "head" used to be.  At this
    point, the line should look like "<code>:e ~/proj1/src/footer2.h</code>".
<li>Hit <kbd>Enter</kbd> to submit the revised command line.
</ol>

<h3>4.1.2 The TAB key</h3>
<p>The <a name="Tab"><kbd>Tab</kbd></a> key has a special function when you're inputting
text into the "Elvis ex history" buffer.
It is used for name completion.
(Exception: Under MS-DOS, this feature is disabled in order to reduce the
size of the program, so it will fit in the lower 640K.)


<p>Name completion works like this:
The preceding word is assumed to be a partial name for an ex command,
an option, a tag, or a file.
The type of name is determined by the context in which it appears --
commands appear at the start of an ex command line, and the others
can only occur after certain, specific command names.
Elvis searches for all matches of the appropriate type.

<p>If there are multiple matches, then Elvis fills in as many
characters of the name as possible, and then stops;
or, if no additional characters are implied by the matching names,
then Elvis lists all matching names and redisplays the command line.
If there is a single match, then Elvis completes the name and appends a space
 character or some other appropriate character.
If there are no matches, then Elvis simply inserts a tab character.

<p>Also, if while entering a <a href="#set">:set</a> command you hit the
<kbd>Tab</kbd> key immediately after "<var>option</var>=" then Elvis
will insert the current value of the <var>option</var>.
You can then edit that value before submitting the command line.

<p>I tried to make Elvis smart enough that the <kbd>Tab</kbd> key will
only attempt file/command/option completion in contexts where it makes sense to
do so, but that code might not be 100% correct.
You can bypass the completion by typing a <kbd>Control-V</kbd>
before the <kbd>Tab</kbd> key.
You can also disable name completion altogether by setting the
"Elvis ex history" buffer's <a href="elvisopt.html#inputtab">inputtab</a>
option to "tab", via the following command:
<pre>
	:(Elvis ex history)set inputtab=tab
</pre>
or the abbreviated form:
<pre>
	:("Eeh)se it=t</pre>

<p>By default, Elvis ignores binary files when performing filename
completion.
The <a href="elvisopt.html#completebinary">completebinary</a> option can
be used to make Elvis include binary files.
That's a global option (unlike <a href="elvisopt.html#inputtab">inputtab</a>
which is associated with a specific buffer), so you don't need to specify
the buffer name; a simple <code>:set completebinary</code> will set it.

<h2>4.2 Syntax and Addressing</h2>
In general, ex command lines can begin with an optional window id.
This may be followed by an optional buffer id,
and then 0, 1, or 2 line addresses,
followed by a command name, and perhaps some arguments after that
(depending on the command name).

<p>A window ID is typed in as a decimal number followed by a colon character.
If you don't supply a window ID (and you almost never will) then it defaults
to the window where you typed in the command line.
The <a href="#buffer">:buffer</a> command lists the buffers, and shows which
one is being edited in which window.
Also, the <a href="elvisopt.html#windowid">windowid</a> option indicates the
ID of the current window.

<p>A <a name="BUFFERID">buffer ID</a> is given by typing an opening parenthesis, the name of the
buffer, and a closing parenthesis.
For user buffers, the name of the buffer is usually identical to the name of
the file that it corresponds to.
For example, a file named .Xdefaults would be loaded into a buffer which
could be addressed as <code>(.Xdefaults)</code>.
Elvis also assigns numbers to user buffers, which may be more convenient
to type since numbers are generally shorter than names.
If .Xdefaults is the first file you've edited since starting Elvis, then
its buffer could be addressed as <code>(#1)</code>.
The <a href="#buffer">:buffer</a> command shows the number for each user
buffer.

<p>Elvis also has several internal buffers, all of which have names that start
with "Elvis ", such as <code>(Elvis cut buffer x)</code> and
<code>(Elvis error list)</code>.
The <a href="#buffer">:buffer!</a> command (with a ! suffix) will list them all.
For the sake of brevity, Elvis allows you to refer to cut buffers as
<code>("x)</code>.
Similarly, the other internal buffers can be referred to via a " character
and the initial letter in each word of the full name, such as
<code>("Eel)</code> for <code>(Elvis error list)</code>.

<p>The parentheses can also contain an '=' followed by an
<a href="elvisexp.html">expression</a>,
in which case Elvis will evaluate the expression and use
the result as the buffer name.
For example, if the <a href="elvisopt.html#x">x</a> option is set to "run2000",
then "<code>:(=x)%p</code>" is equivalent to "<code>:(run2000)%p</code>".
(They both print the contents of the buffer named "run2000".)
This is often handy in <a href="elvistip.html#ALIAS">aliases</a>.

<p>Commands which don't access the text, such as "<a href="#quit">:quit</a>",
don't allow any line addresses.
Other commands, such as "<a href="#mark">:mark</a>",
only allow a single line address.
Most commands, though, allow two line addresses;
the command is applied to all lines between the two specified lines,
inclusively.
The tables below indicate how many line addresses each command allows.

<p>Line addresses are always optional.
The first line address of most commands usually defaults to the current line.
The second line address usually defaults to be the same as the first line address.
Exceptions are <a href="#write">:write,</a> <a href="#lpr">:lpr,</a>
<a href="#global">:global,</a> and <a href="#vglobal">:vglobal,</a>
which act on all lines of the file by  default,  and
<a href="#BANG">:!,</a> which acts on no lines by default.

<p>If you use the visual <a href="elvisvi.html#V">V</a> command to mark
a range of lines, and then use the visual <a href="elvisvi.html#colon">:</a>
command to execute a single ex command,
then the default range affected by the ex command will
be the visibly marked text.

<p><a name="address">Line addresses</a> consist of an absolute part and
a relative part.
The <em>absolute part</em> of a line specifier may be either an
explicit line number, a mark, a dot to denote the current line,
a dollar sign to denote the last line of the file, or a
forward or backward search.

An <em>explicit line number</em> is  simply a decimal number,
expressed as a string of digits.

A <em>mark</em> is typed in as an apostrophe followed by a letter.
Marks must be set before they can be used.
You can set a mark in visual command mode by typing "m" and a letter,
or you can set it in ex command mode via the "mark" command.

A <em>forward search</em> is typed in as a regular expression surrounded by
slash characters; searching begins at the default line.
A <em>backward search</em> is typed in as a  regular  expression
surrounded by question marks;
searching begins at the line before the default line.

<p>If you omit the <em>absolute part,</em> then the default line is used.

<p>The <em>relative part</em> of a line specifier is typed as a <code>+</code>
or <code>-</code> character followed by a decimal number.
The number is added to or subtracted from the absolute part of the line
specifier to produce the final line number.

<p>To use a range of addresses, give the expressions for the first and last
line separated by either a comma or semicolon.
When separated by a comma, both lines are addressed relative to the default
line (where the cursor is, generally).
When separated by a semicolon, the second address will be relative to the
first address.
You can also give more than two addresses, in which case the last two will
define the range.

<p>As a special case, the <code>%</code> character may be used to specify
all lines of the file.
It is roughly equivalent to saying <code>1,$</code>.
This can be a handy shortcut.

<p>Here are some addressing examples, using the <a href="#print">:p</a> command:
<pre graphic>
   COMMAND      | ACTION
   -------------|-------------------------------------------
   :p           | print the current line
   :37p         | print line 37
   :'gp         | print the line which contains mark g
   :/foo/p      | print the next line that contains "foo"
   :$p          | print the last line of the buffer
   :20,30p      | print lines 20 through 30
   :1,$p        | print all lines of the buffer
   :%p          | print all lines of the buffer
   :(zot)%p     | print all lines of the "zot" buffer
   :/foo/-2,+4p | print 5 lines around the next "foo"</pre>

<p>The optional addresses are followed by the command name.
Command names may be abbreviated.
In the sections that follow, the command's full name is given with the
optional part enclosed in square brackets.

<p>Some commands allow a '!' character to appear immediately after the
command name.
The significance of the '!' varies from one command to another,
but typically it forces the command to do something dangerous that it would
ordinarily refuse to do.
For example, <a href="#write">:w <var>file</var></a> refuses to overwrite an
existing file, but <a href="#write">:w! <var>file</var></a> will do it.

<p>Many commands allow (or even require) additional arguments.
The descriptions below list which arguments each command accepts
with optional commands denoted by square brackets.
The most common argument types are:

<dl>

<dt>/regexp/
<dd>This is a <a href="elvisre.html">regular expression.</a>
You can use any punctuation character to delimit it, but the '/' character
is the most commonly used.

<dt>/regexp/newtext/
<dd>This is a <a href="elvisre.html">regular expression</a>
followed by replacement text.

<dt>count
<dd>This is a number - a string of digits.
Generally, it is used as the repeat count for certain commands.

<dt>cutbuf
<dd>This is the name of a cut buffer - a single letter.
Elvis also allows (but does not require) a quote character before the letter.

<dt>excmds
<dd>This is another ex command, or list of ex commands.
Traditionally, the whole list of commands had to appear on the same line,
delimited by '|' characters.
Elvis has the added versatility of allowing a '{' character on the first line,
each command on a separate following  line, and then '}' on a line by itself to mark
the end of the ex command list.

<dt>lhs
<dd>This is string of characters.
If whitespace characters are to be included in it, then they must be
quoted by embedding a <kbd>^V</kbd> character before them.

<dt>face
<dd>This is the name of a text face -- that is, a type of text.
The <a href="#color">:color</a> command is used to configure the appearance
of the face, and <a href="#check">:check</a> defines the spell-checking rules.

<dt>line
<dd>This is a line address, as described earlier.

<dt>+line
<dd>Some commands which cause a file to be loaded also allow you to specify
some other command to be executed after the loading is complete.
To use this feature, you mist give a "+" followed by the command, in between
the command name and the file name.
Here's an example that loads foo and then moves the cursor to line 40.
<pre>
	:e +40 foo</pre>

<p>Usually the command is just a line number, so this is denoted as "+line"
in this documentation.
Other commands are allowed though, such as "+/text" to search for text,
or "+normal" to force it to use the <a href="elvisdm.html#normal">normal</a>
display mode.

<p>Traditionally, commands supplied in this manner weren't allowed to contain
whitespace, because that makes parsing the command line harder.
This is too limiting, though, so Elvis allows you to embed spaces in the
command by wrapping the entire deferred command in double-quotes, like this:
<pre>
	:e +"set bufdisplay=man" filedb.8</pre>

<dt>mark
<dd>This is the name of a mark - a single lowercase letter.
Elvis allows (but does not require) an apostrophe before the letter.

<dt>rhs
<dd>This is a string of characters.
If it begins with a whitespace character, then that character must be quoted
by embedding a <kbd>^V</kbd> character in the command line before it.
Other whitespace characters in the string do not need to be quoted.

<dt>expr
<dd>This is an <a href="elvisexp.html">arithmetic expression</a>
using the normal syntax.

<dt>shellcmd
<dd>This is a command line which is passed to the system's command interpreter.
Within the command line, the following character substitutions take place,
unless preceded by a backslash:
<pre graphic>
	.-----------.----------------------------.
	| CHARACTER | REPLACED BY                |
	|-----------|----------------------------|
	|     %     | Name of current file       |
	|     #     | Name of alternate file     |
	|     #<var>n</var>    | Name of file whose <a href="elvisopt.html#bufid">bufid</a>=<var>n</var> |
	|     !     | Previous command line      |
	|     \@    | Word at cursor location    |
	^-----------^----------------------------^
</pre>
Note that the <code>\@</code> substitution <em>requires</em> a backslash.
This quirk exists for the sake of backward compatibility -
the real vi doesn't perform any substitutions for just plain @,
and neither does Elvis.

<dt><a name="FILES">file or files</a>
<dd>This is one or more file names, or a "wildcard" pattern which matches
the names of zero or more files.  File names are subjected to three levels
of processing.  First, leading ~ characters and certain other characters
are replaced with text, as follows:
<pre graphic>
    .-----------.------------------------------------------------.
    | SYMBOL    | REPLACED BY                                    |
    |-----------|------------------------------------------------|
    | ~<var>user</var>     | (Unix only) Replaced by home directory of <var>user</var> |
    | ~+        | Replaced by current working directory          |
    | ~-        | Replaced by previous directory (<a href="elvisopt.html#previousdir">previousdir</a>)   |
    | ~         | Replaced by home directory (<a href="elvisopt.html#home">home</a>)              |
    | %         | Replaced by the name of the current file       |
    | #         | Replaced by the name of the alternate file     |
    | #<var>n</var>        | Replaced by the filename of buffer with <a href="elvisopt.html#bufid">bufid</a>=<var>n</var>|
    | (space)   | Delimits one file name from another            |
    | `program` | Run program, interpret its output as filenames |
    ^-----------^------------------------------------------------^
</pre>
The second stage of processing evaluates each name using the
<a href="elvisexp.html#SIMPLER">simpler expression syntax</a>.
This basically means that expressions of the form
<strong>$</strong><var>NAME</var> will be replaced with the value of 
the environment variable named <var>NAME</var>.
Also, you can use parentheses around option names or more complex expressions.
For example, if the user option <a href="elvisopt.html#f">f</a> contains
the name of a file, then you could say "<code>:e (f)</code>" to edit that file.

<p>In either of the first two stages,
backslashes may be used to prevent the special symbols from
having their usual meaning; they'll be treated as normal text instead.
In particular, a backslash-space sequence can be used to give a filename
which includes spaces; e.g., to edit "C:\Program&nbsp;Files\foo" you would type
"<code>:e C:\Program\&nbsp;Files\foo</code>".
Note that backslashes which are followed by a normal character are simply
retained as normal characters, so you rarely need to type a double-backslash
when your file name needs only a single backslash.

<p>The third stage of processing checks for "wildcard" characters in the name,
and if there are any then the whole name is replaced by the name of each
matching file.  The exact list of supported wildcards will vary from one
operating system to another, but the following are typical:
<pre graphic>
	.--------.----------------------------------------------.
	| SYMBOL | MATCHES                                      |
	|--------|----------------------------------------------|
	| *      | Any string of characters, of any length      |
	| ?      | Any single character                         |
	| [A-Z]  | (Unix only) Any single character from A to Z |
	^--------^----------------------------------------------^
</pre>
In most operating systems, wildcards are only recognized when they occur
in the last file name part of a longer pathname.  In other words, you can
use wildcards for file names,
but not in directory names leading up to file names.

<p>Traditionally, vi has used the Unix shell to expand wildcards.
However, this interferes with the use of spaces in file names, isn't easily
portable to non-Unix operating systems, and is a potential security hole.
So Elvis performs all wildcard expansion itself.  The only disadvantage
of this is that you loose other shell notations such as
<code>{alt1,alt2}</code>.
</dl>

<p>Most commands can be followed by a '|' character and another ex command.
Others can't.  In particular, any command which takes a <strong>excmd</strong>
or <strong>shellcmd</strong> argument doesn't treat '|' as a command delimiter.

<p>If a command does treat '|' as a delimiter, and you want '|' to be treated
as part of a command argument, then you'll need to quote the '|' character
by preceding it with a backslash or ^V, depending on the command.
(Sadly, different commands require different quote characters.)

<h2><a name="GROUP">4.3 Ex Commands, Grouped by Function</a></h2>
<menu>
<li><a href="#HELP">	4.4 The help command itself</a>
<li><a href="#EDIT">	4.5 Editing commands</a>
<li><a href="#GLOBAL">	4.6 Global edit commands</a>
<li><a href="#PRINT">	4.7 Displaying text</a>
<li><a href="#TAGS">	4.8 Tags</a>
<li><a href="#IO">	4.9 File I/O commands</a>
<li><a href="#ARGS">	4.10 The args list, and selecting a file to edit</a>
<li><a href="#QUIT">	4.11 Quitting</a>
<li><a href="#MACRO">	4.12 Scripts and macros</a>
<li><a href="#ERRLIST">	4.13 Working with a compiler</a>
<li><a href="#CALC">	4.14 Built-in calculator</a>
<li><a href="#BUFFER">	4.15 Buffer commands</a>
<li><a href="#WINDOW">	4.16 Window commands</a>
<li><a href="#SETUP">	4.17 Configuration</a>
<li><a href="#AUTOCMD">	4.18 Auto commands</a>
<li><a href="#FOLD">	4.19 Folding</a>
<li><a href="#REGION">	4.20 Regions</a>
<li><a href="#SPELL">	4.21 Spell checking</a>
<li><a href="#MISC">	4.22 Miscellaneous</a>
</menu>

<h2><a name="HELP">4.4 The help command itself</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#help">h[elp]</a>            | topic                             |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><a name="help">h[elp]</a> <var>topic</var>
<dd>The <code>:help</code> command loads and displays a
help file for a given topic.
There are several help files, covering a wide variety of topics.

<p>Elvis looks at the topic you supply, and tries to determine whether
it is an ex command name, vi keystroke, option name, or something else.
Based on this, it generates a hypertext link to the topic in the appropriate
help file, and shows the topic in a separate window.
Elvis uses the following rules to convert your requested topic into
a hypertext reference:
<pre graphic>
  .-------------------.-------------------------------------------.
  | COMMAND           | ELVIS' INTERPRETATION                     |
  |-------------------|-------------------------------------------|
  | :help             | With no topic, Elvis loads the table of   |
  |                   |   contents. This has hypertext links that |
  |                   |   can lead you to any other topic.        |
  | :help ex          | Elvis loads the chapter describing ex     |
  |                   |   commands.                               |
  | :help vi          | Elvis loads the chapter describing vi     |
  |                   |   commands.                               |
  | :help set XXX     | If XXX is an option name, Elvis will show |
  |                   |   the description of that option; else it |
  |                   |   will list groups of all options.        |
  | :help display XXX | If XXX is the name of a display mode, then|
  |                   |   Elvis will show the description of that |
  |                   |   mode.  Otherwise it shows the top of the|
  |                   |   display mode chapter                    |
  | :help autocmd XXX | If XXX is the name of an autocmd event,   |
  |                   |   then Elvis will show the description of |
  |                   |   that event; else it will take you to the|
  |                   |   top of the event list                   |
  | :help :XXX        | If XXX is an ex command name, Elvis will  |
  |                   |   show its description; else Elvis will   |
  |                   |   list groups of all ex commands.         |
  | :help XXX()       | Elvis loads the chapter describing the    |
  |                   |   built-in calculator, and moves to the   |
  |                   |   section describing function XXX.        |
  | :help &lt;XXX&gt;       | Describe Elvis' implementation of the HTML|
  |                   |   tag &lt;XXX&gt;                               |
  | :help XXX         | If XXX appears to be a keystroke then     |
  |                   |   Elvis will assume it is meant to be a   |
  |                   |   vi command and will show the command's  |
  |                   |   description.  Else if it is an option   |
  |                   |   name Elvis will show that. Else if it   |
  |                   |   is an ex command, Elvis will show that. |
  |                   |   Else Elvis will show this description   |
  |                   |   of the :help command itself.            |
  ^-------------------^-------------------------------------------^</pre>
<p>Although this chart only mentions chapters on
ex commands, vi commands, options, functions, autocmd events, and html tags,
there are many other chapters which are only
accessible via the table of contents shown by ":help" with no arguments.

<p>All of these help files are HTML documents.
Elvis' standard HTML editing facilities are available while you're
viewing the help text.
Some of the highlights of this are:
<ul>
<li>To close this help window, type <kbd>ZQ</kbd>.  Actually, this works
	for all windows.  (You must hold the <kbd>Shift</kbd> key
	as you type <kbd>ZQ</kbd>, because lowercase <kbd>zq</kbd> does
	something else entirely: nothing!)
<li>Any underlined text is a hypertext reference.  This means that you
	can move the cursor onto it, and hit <a href="elvisvi.html#^]">^]</a>
	(Control-]) and the cursor will move to a topic describing the
	underlined text.
	Usually when viewing HTML documents, the <kbd>Enter</kbd> key will be
	mapped to <kbd>^]</kbd> so you can use it too.
<li>To return to your original position after following a hypertext reference,
hit <a href="elvisvi.html#^T">^T</a> (Control-T).
<li>The <a href="elvisvi.html#^I">Tab</a> key moves the cursor forward to the next
	hypertext reference.
</ul>
<p>You can use Elvis to print the document via the <a href="#lpr">:lpr</a>
command.  This assumes you have set the <a href="elvisopt.html#LPR">printing
options</a> correctly.

</dl>

<p><strong>NOTE:</strong> In addition to the <a href="#help">:help</a> command,
most versions of Elvis also support two <a href="elvistip.html#EXAMPLES">aliases</a> which you may find handy.
The "<a href="elvistip.html#howto">:howto</a> <var>words...</var>" alias
searches for given words in the title lines of a short "howto.html" document.
The "<a href="elvistip.html#kwic">:kwic</a> <var>word</var>" alias finds every
instance of a given word in any section of Elvis' documentation, and builds a
table showing each instance along with some of the surrounding text;
you can then follow hypertext links to the actual location in the manual.

<h2><a name="EDIT">4.5 Editing commands</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
| line  | <a href="#append">a[ppend]</a>[!]       | [text]                            |
| line  | <a href="#insert">i[nsert]</a>[!]       | [text]                            |
| range | <a href="#change">c[hange]</a>[!]       | [count]                           |
| range | <a href="#delete">d[elete]</a>          | [cutbuf] [count]                  |
| range | <a href="#yank">y[ank]</a>            | [cutbuf] [count]                  |
| line  | <a href="#put">pu[t]</a>             | [cutbuf]                          |
| range | <a href="#copy">co[py]</a>            | line                              |
| range | <a href="#move">m[ove]</a>            | line                              |
| range | <a href="#to">t[o]</a>              | line                              |
| range | <a href="#BANG">!</a>                 | shellcmd                          |
| range | <a href="#GT">&gt;</a>                 |                                   |
| range | <a href="#LT">&lt;</a>                 |                                   |
| range | <a href="#join">j[oin]</a>[!]         |                                   |
|       | <a href="#undo">u[ndo]</a>            | [count]                           |
|       | <a href="#redo">red[o]</a>            | [count]                           |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><var>line</var> <a name="append">a[ppend]</a><code>[</code>!<code>]</code> <code>[</code><var>text</var><code>]</code>
<dd>The <code>:append</code> command inserts text after the
current line.
If no new text is supplied on the command line, then Elvis will wait for
you to type in text;
you can then mark the end of the new text by typing a "." (period) on a
line by itself.
In the real vi, adding a '!' suffix temporarily toggles the
<a href="elvisopt.html#autoindent">autoindent</a> option, but Elvis just
ignores the '!'.

<dt><var>line</var> <a name="insert">i[nsert]</a><code>[</code>!<code>]</code> <code>[</code><var>text</var><code>]</code>
<dd>The <code>:insert</code> command inserts text before the
current line.
Other than that, it is identical to the <a href="#append">:append</a>
command.
In the real vi, adding a '!' suffix temporarily toggles the
<a href="elvisopt.html#autoindent">autoindent</a> option, but Elvis just
ignores the '!'.

<dt><var>range</var> <a name="change">c[hange]</a><code>[</code>!<code>]</code> <code>[</code><var>count</var><code>]</code> <code>[</code><var>text</var><code>]</code>
<dd>The <code>:change</code> command deletes old text lines
(copying them into the anonymous cut buffer) and then waits for you to enter
new text to replace it.
You can then mark the end of the new text by typing a "." (period) on a
line by itself.
In the real vi, adding a '!' suffix temporarily toggles the
<a href="elvisopt.html#autoindent">autoindent</a> option, but Elvis just
ignores the '!'.

<dt><var>range</var> <a name="delete">d[elete]</a> <code>[</code><var>cutbuf</var><code>]</code> <code>[</code><var>count</var><code>]</code>
<br><var>range</var> <a name="yank">y[ank]</a> <code>[</code><var>cutbuf</var><code>]</code> <code>[</code><var>count</var><code>]</code>
<dd>The <code>:delete</code> command copies
text into a cut buffer, and then deletes it from the edit buffer.
The <code>:yank</code> command copies text into a cut buffer but leaves the
edit buffer unchanged.

<dt><var>line</var> <a name="put">pu[t]</a> <code>[</code><var>cutbuf</var><code>]</code>
<dd>The <code>:put</code> command "pastes" text from a cut buffer
back into the edit buffer.
The cut buffer's contents are inserted after the addressed line.
If you want to insert before the first line, you can use address 0 like
this:
<pre>
:0put</pre>

<dt><var>range</var> <a name="copy">co[py]</a> <var>line</var>
<br><var>range</var> <a name="to">t[o]</a> <var>line</var>
<dd>
The <code>:copy</code> and <code>:to</code> commands are identical.
They both make a copy of a portion of an edit buffer, and insert that copy
at a specific point.
The destination line can be specified with an optional buffer name and the
full address syntax as described in <a href="#address">section 4.2.</a>
Consequently, you can use this command to copy part of one edit buffer
into another edit buffer.
The following example copies an 11-line window from the current buffer
onto the end of a buffer named "otherbuf"
<pre>
:-5,+5t(otherbuf)$</pre>

<dt><var>range</var> <a name="move">m[ove]</a> <var>line</var>
<dd>
The <code>:move</code> command resembles <a href="#copy">:copy</a> except that
<code>:move</code> deletes the original text.

<dt><var>range</var> <a name="BANG">!</a> <var>shellcmd</var>
<dd>
The <code>:!</code> command allows you to send parts of your edit buffer though
some external "filter" program.
The output of the program then replaces the original text.
For example, this following will sort lines 1 through 10 using the "sort"
program.
<pre>
:1,10!sort</pre>

<p>If you use the <code>:!</code> command without any line addresses, then
Elvis will simply execute the program and display its output.
This is only guaranteed to work correctly for non-interactive programs;
to execute an interactive program you should use the <a href="#shell">:shell</a>
command.

<dt><var>range</var> <a name="LT">&lt;</a>
<br><var>range</var> <a name="GT">&gt;</a>
<dd>The <code>:&lt;</code> and <code>:&gt;</code> commands adjust the indentation on the
addressed lines.
The <code>:&lt;</code> command decreases the leading whitespace by the number of
spaces indicated in the <a href="elvisopt.html#shiftwidth">shiftwidth</a>
option, and <code>:&gt;</code> does the reverse.
You can use multiple &lt; or &gt; characters in a single command to increase
the shift amount; for example, <code>:&gt;&gt;&gt;</code> shifts text by triple
the <a href="elvisopt.html#shiftwidth">shiftwidth</a> amount.
Normally Elvis' versions of these commands will leave blank lines unchanged,
but if you append a '!' (as in <code>:&gt;!</code>) then the command will affect
blank lines in addition to other lines.

<dt><var>range</var> <a name="join">j[oin]</a><code>[</code>!<code>]</code>
<dd>
The <code>:join</code> command joins multiple lines together so they form one
long line.
Normally it will intelligently decide how much whitespace it should place
between lines, depending on the <a href="elvisopt.html#sentenceend">sentenceend,</a>
<a href="elvisopt.html#sentencegap">sentencegap,</a> and
<a href="elvisopt.html#sentencequote">sentencequote</a> options.
When invoked with a '!' suffix (as in <code>:join!</code>), it joins the lines
without doing fancy things to whitespace.

<dt><a name="undo">u[ndo]</a> <code>[</code><var>count</var><code>]</code>
<br><a name="redo">red[o]</a> <code>[</code><var>count</var><code>]</code>
<dd>The <code>:undo</code> command undoes recent changes.
The number of undoable changes is controllable on a buffer-by-buffer basis,
via the <a href="elvisopt.html#undolevels">undolevels</a> option.
The <code>:redo</code> command undoes an undo.

</dl>

<h2><a name="GLOBAL">4.6 Global edit commands</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
| range | <a href="#global">g[lobal]</a>[!]       | /regexp/ excmds                   |
| range | <a href="#vglobal">v[global]</a>[!]      | /regexp/ excmds                   |
| range | <a href="#substitute">s[ubstitute]</a>      | /regexp/new/[g|.<var>n</var>][x][c][e][p|l|#]|
| range | <a href="#AMP">&amp;</a>                 | [g|.<var>n</var>][p|l|#][x][c]               |
| range | <a href="#TILDE">~</a>                 | [g|.<var>n</var>][p|l|#][x][c]               |
|       | <a href="#nohlsearch">noh[lsearch]</a>      |                                   |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><var>range</var> <a name="global">g[lobal]</a><code>[</code>!<code>]</code> /<var>regexp</var>/ <var>excmds</var>
<br><var>range</var> <a name="vglobal">v[global]</a><code>[</code>!<code>]</code> /<var>regexp</var>/ <var>excmds</var>
<dd>
The <code>:global</code> command searches for lines which contain the
<a href="elvisre.html">/regexp/</a> and executes the given <var>excmds</var>
for each matching line.
The <code>:vglobal</code> command executes the <var>excmds</var> for each line
which <em>does not</em> match the <var>/regexp/.</var>

<p>In script files, you can supply multiple command lines to a single
<code>:global</code> or <code>:vglobal</code> by placing a '{' character on the
<code>:global/:vglobal</code> line,
following that with any number of command lines, and then finally a '}'
character on a line by itself to mark the end.
This notation doesn't allow nesting; you can't use {...} inside a larger
{...} command list.
(Hopefully this limitation will be lifted soon.)

<dt><var>range</var> <a name="substitute">s[ubstitute]</a> /<var>regexp</var>/<var>new</var>/<code>[</code>g<code>|</code>.<var>instance</var><code>][</code>c<code>][</code>x<code>][</code>e<code>][</code>p<code>|</code>l<code>|</code>#<code>][</code><var>count</var><code>]</code>
<dd>
The <code>:substitute</code> command searches for the <var>/regexp/</var> in each
line, and replaces the matching text with <var>newtext.</var>
The interpretation of <var>new</var> text is described in
<a href="elvisre.html#SUBST">section 5.2</a>

<p>Briefly, flags supported by <code>:s</code> are...
<pre graphic>
.------.-------------------------------------------------------.
| FLAG | WHAT IT MEANS                                         |
|------|-------------------------------------------------------|
|  g   | replace every instance in each line                   | 
|  .<var>n</var>  | (n is a number) replace the <var>n</var>'th instance in each line|
|  c   | ask for confirmation before making the change         |
|  x   | execute the <var>newtext</var> as an ex command; don't subsitute |
|  e   | don't treat "no match" as an error                    |
|  p   | print the changed line like <a href="#print">:p</a>                        |
|  l   | print the changed line like <a href="#list">:l</a>                        |
|  #   | print the changed line like <a href="#number">:nu</a>                       |
^------^-------------------------------------------------------^</pre>


<p>The <var>newtext</var> can be followed by a <kbd>g</kbd> flag to
replace all instances in each line.
Without the <kbd>g</kbd> flag, only the first match within each line is changed
(unless the <a href="elvisopt.html#gdefault">gdefault</a> option is set).
To replace some other instance in each line, give a decimal point followed by
the instance number, such as <kbd>.3</kbd> to replace the third instance of
matching text in each line.

<p>You can also supply a <kbd>p</kbd> flag.
This causes each affected line to be printed (like <a href="#print">:p</a>),
after all substitutions have been made to that line.
Similarly, <kbd>l</kbd> lists it (like <a href="#list">:l</a>), and
<kbd>#</kbd> prints it with a line number (like <a href="#number">:nu or :#</a>).

<p>You can also make Elvis ask for confirmation before each substitution by
appending a <kbd>c</kbd> flag.
The <code>:s</code> command will locate the first match and then exit immediately,
but it will leave the window in an unusual input state in which
<kbd>y</kbd> performs a substitution and then moves on to the next match,
<kbd>n</kbd> does not perform the substitution but still moves to the next match, and
<kbd>Esc</kbd> cancels the operation.
Most other keys act like <kbd>y</kbd> in this mode.

<p><strong>NOTE:</strong>
Elvis doesn't allow the <kbd>c</kbd> flag to be combined with the
<a href="#global">:g</a> command.
Instead of using "<code>:g/regexp/s//newtext/gc</code>", I suggest you get
in the habit of using "<code>:%s/regexp/newtext/gc</code>".
There is no way to do the more complex
"<code>:g/regexp1/s/regexp2/newtext/gc</code>" in Elvis at this time.

<p>Elvis supports a special <kbd>x</kbd> flag.
Instead of performing each substitution,
Elvis will execute the final replacement text as an ex command line.
This is used in the implementation of modelines, like this:
<pre>
	try 1,5 s/ex:\(.*\):/\1/x
	try $-4,$ s/ex:\(.*\):/\1/x</pre>

<p>The <a href="elvisex.html#try">:try</a> command is there so that if no
modelines are found, Elvis won't consider that to be an error.
This is important because an error would cause the script to be aborted.
Another way to avoid errors when there is no match is to use the <kbd>e</kbd>
flag.

<dt><var>range</var> <a name="AMP">&amp;</a><code> [</code>g<code>|</code>.<var>instance</var><code>][</code>c<code>][</code>p<code>|</code>n<code>|</code>#<code>][</code>x<code>][</code><var>count</var><code>]</code>
<br><var>range</var> <a name="TILDE">~</a><code> [</code>g<code>|</code>.<var>instance</var><code>][</code>c<code>][</code>p<code>|</code>n<code>|</code>#<code>][</code>x<code>][</code><var>count</var><code>]</code>
<dd>The <code>:&amp;</code> and <code>:~</code> commands both repeat the previous
<code>:substitute</code> command, discarding any previous flags.
The difference between them is that <code>:&amp;</code> uses the regular
expression from the previous <code>:s</code> command, but <code>:~</code>
uses the most recent regular expression from any context.

<dt><a name="nohlsearch">noh[lsearch]</a>
<dd>
The <code>:nohlsearch</code> temporarily disables the
<a href="elvisopt.html#hlsearch">hlsearch</a> option's highlighting.
It doesn't change that option's value;
it merely makes Elvis forget that it was supposed to highlight anything.
The next time you perform a search, the <code>hlsearch</code> option will
again highlight the matching text.

</dl>

<h2><a name="PRINT">4.7 Displaying text</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
| range | <a href="#print">p[rint]</a>           | [count]                           |
| range | <a href="#list">l[ist]</a>            | [count]                           |
| range | <a href="#number">nu[mber]</a>          | [count]                           |
| range | <a href="#HASH">#</a>                 | [count]                           |
| line  | <a href="#z">z</a>                 | [spec]                            |
| range | <a href="#EQ">=</a>                 |                                   |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><var>range</var> <a name="print">p[rint]</a> <code>[</code><var>count</var><code>]</code>
<dd>
The <code>:print</code> command displays lines from the edit buffer.
It displays them the normal way -- with tabs expanded and so on.

<dt><var>range</var> <a name="list">l[ist]</a> <code>[</code><var>count</var><code>]</code>
<dd>
The <code>:list</code> command also displays lines, but it tries to make
all non-printing characters visible, and it marks the end of each line with
a '$' character.

<dt><var>range</var> <a name="number">nu[mber]</a> <code>[</code><var>count</var><code>]</code>
<br><var>range</var> <a name="HASH">#</a> <code>[</code><var>count</var><code>]</code>
<dd>The <code>:number</code> and <code>:#</code> commands are identical to each other.
They both display lines the normal way except that each line is preceded by
its line number.

<dt><var>line</var> <a name="z">z</a> <code>[</code><var>spec</var><code>]</code>
<dd>
The <code>:z</code> command shows a "window" of lines surrounding the current line.
The default size of the "window" is taken from the
<a href="elvisopt.html#window">window</a> option.
If a line address is supplied, then it becomes the current line before this
command is executed.
The <var>spec</var> can be one of the following characters;
the default is <kbd>z+.</kbd>
<pre graphic>
   .------.-----------------------------------------------------.
   | SPEC | OUTPUT STYLE                                        |
   |------|-----------------------------------------------------|
   |  -   | Place the current line at the bottom of the window. |
   |------|-----------------------------------------------------|
   |  +   | Place the current line at the top of the window.    |
   |      | Upon completion of this command, the last line      |
   |      | output will become the current line.                |
   |------|-----------------------------------------------------|
   |  ^   | Jump back 2 windows' worth of lines, and then do    |
   |      | the equivalent of z+.  Note that z+ is like paging  |
   |      | forward and z^ is like paging backward.             |
   |------|-----------------------------------------------------|
   |  .   | Place the current line in the middle of the window. |
   |      | Upon completion of this command, the last line      |
   |      | output will become the current line.                |
   |------|-----------------------------------------------------|
   |  =   | Place the current line in the middle of the window, |
   |      | and surround it with lines containing hyphens.      |
   ^------^-----------------------------------------------------^ </pre>

<dt><var>range</var> <a name="EQ">=</a>
<dd>
The <code>:=</code> command displays the line number of the current line,
or the addressed line if given one address.
If given a range of addresses, it tells you the line numbers of the two
endpoints and the total number of lines in the range.

</dl>

<h2><a name="TAGS">4.8 Tags</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#tag">ta[g]</a>[!]          | [tag]                             |
|       | <a href="#stack">stac[k]</a>           |                                   |
|       | <a href="#pop">po[p]</a>[!]          |                                   |
|       | <a href="#push">pus[h]</a>[!]         | [+line] [file]                    |
|       | <a href="#browse">br[owse]</a>[!]       | restrictions                      |
^-------^-------------------^-----------------------------------^
</pre>

Tags provide a way to associate names with certain places within certain files.
Typically, you will run the <strong>ctags</strong> program to create a file
named "tags" which describes the location of each function and macro
used in the source code for your project.
The tag names are the same as the function names, in this case.

<p>In HTML mode, Elvis uses the tags commands to follow hypertext links,
but we'll generally ignore that in the following discussions.

<dl>

<dt><a name="tag">ta[g]</a><code>[</code>!<code>]</code> <code>[</code><var>tag</var><code>]</code>
<dd>
The <code>:tag</code> command performs tag lookup.
It reads the "tags" file to locate the named tag.
It then loads the source file where that tag is defined, and moves the
cursor to the specific point within that buffer where the tag is defined.
Elvis' implementation of <code>:tag</code> also allows you to give extra
<a href="elvistag.html#HINTS">restrictions and hints.</a>
There is also a <a href="#stag">:stag</a> command which creates a new window
and moves its cursor to the tag's definition point.

<dt><a name="push">pus[h]</a><code>[</code>!<code>]</code> <code>[</code>+<var>line</var><code>]</code> <code>[</code><var>file</var><code>]</code>
<dd>
The <code>:push</code> command is similar to <a href="#open">:edit</a>,
except that <code>:push</code> saves the cursor position first.
Specifically, invoking "<code>:push</code>" with no arguments pushes
the cursor position onto the tag stack -- nothing else.
Invoking "<code>:push </code><var>file</var>" will push the cursor position
and then switch to a new file.

<dt><a name="browse">br[owse]</a><code>[</code>!<code>]</code> <var>restrictions</var>
<dd>
The <code>:browse</code> command extracts selected tags from the tags file,
constructs an HTML document listing those tags (with hypertext links to their
definition points inside your source code) and displays it in the current
window.
There is also a <a href="#sbrowse">:sbrowse</a> command which displays the
same list in a new window.
If invoked with no args, they browse all tags in the current file.
If invoked with a '!' suffix, they browse <code>all</code> tags.
See chapter <a href="elvistag.html">14. Tags</a> for a full description of
<a href="elvistag.html#HINTS">restrictions and hints,</a> and
<a href="elvistag.html#BROWSE">browsing.</a>



<dt><a name="stack">stac[k]</a>
<dd>
Before moving the cursor, Elvis will save the old cursor position on a stack.
You can use the <code>:stack</code> command to display the contents of that stack.
Each window has an independent stack.

<dt><a name="pop">po[p]</a><code>[</code>!<code>]</code>
<dd>
The <code>:pop</code> command pops a cursor position off the stack, restoring
the cursor to its previous position.
When you're browsing though source code, you will typically use <code>:tag</code>
to go deeper into the call tree, and <code>:pop</code> to come back out again.

<p>In HTML mode, these all work the same except that <code>:tag</code> expects to
be given an URL instead of a tag name.
URLs don't depend on having a "tags" file, so the "tags" file is ignored
when in HTML mode.
For more information, see the discussion of the
<a href="elvisdm.html#URL">&lt;a ...&gt; tag in the Display Modes chapter</a>.
The following example would move the cursor to the start of this section:
<pre>
    :tag elvisopt.html#TAGS</pre>

</dl>

<h2><a name="IO">4.9 File I/O commands</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
| line  | <a href="#read">r[ead]</a>            | file | !shellcmd                  |
| range | <a href="#write">w[rite]</a>[!]        | [file | &gt;&gt;file | !shellcmd]       |
| range | <a href="#lpr">lp[r]</a>[!]          | [file | &gt;&gt;file | !shellcmd]       |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><var>line</var> <a name="read">r[ead]</a> <var>file</var> <code>|</code> !<var>shellcmd</var>
<dd>
The <code>:read</code> command reads a file or external program,
and inserts the new text into the edit buffer after the addressed line.
If you don't explicitly give a line address, then the text will be
inserted after the current line.
To insert the file's contents into the top of the buffer (before line 1),
you should specify line 0.
For example, to insert the contents of "foo.txt" before line 1, you would
give the command...
<pre>
    :0 read foo.txt</pre>

<dt><var>range</var> <a name="write">w[rite]</a><code>[</code>!<code>]</code> <code>[</code><var>file</var> <code>|</code> &gt;&gt;<var>file</var> <code>|</code> !<var>shellcmd</var><code>]</code>
<dd>
The <code>:write</code> command writes either the entire edit buffer (if no
address range is given) or a part of it (if a range is given) out to either
a file or an external filter program.
If you don't specify the output file or external command,
then Elvis will assume it should write to the file that the buffer was
originally loaded from.

<p>Elvis will normally prevent you from overwriting existing files.
(The exact details of this protection depend on the
<a href="elvisopt.html#edited">edited,</a>
<a href="elvisopt.html#filename">filename,</a>
<a href="elvisopt.html#newfile">newfile,</a>
<a href="elvisopt.html#readonly">readonly,</a> and
<a href="elvisopt.html#writeany">writeany</a> options.)
If you want to force Elvis to overwrite an existing file,
you can append a "!" to the end of the command name, but before the file name.
In order to avoid ambiguity, <em>there must not be any whitespace between
the "write" command name and the "!" character</em> when you want to
overwrite an existing file.
Conversely, when writing to an external program there <em>should</em> be
whitespace before the "!" that marks the start of the program's command line.
The "&gt;&gt;file" notation tells Elvis to append to "file" instead of overwriting it.

<dt><var>range</var> <a name="lpr">lp[r]</a><code>[</code>!<code>]</code> <code>[</code><var>file</var> <code>|</code> &gt;&gt;<var>file</var> <code>|</code> !<var>shellcmd</var><code>]</code>
<dd>
The <code>:lpr</code> command sends text to the printer.
It is similar to <code>:write</code> except that <code>:lpr</code>
formats the buffer contents as defined by the
<a href="elvisopt.html#bufdisplay">bufdisplay</a> option and the
<a href="elvisopt.html#LPR">printing options.</a>
If no output file or external program is specified,
then the printer output is sent to the file or external program
specified by the <a href="elvisopt.html#lpout">lpout</a> option.

</dl>

<h2><a name="ARGS">4.10 The args list, and selecting a file to edit</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#args">ar[gs]</a>            | [file...]                         |
|       | <a href="#next">n[ext]</a>[!]         | [file...]                         |
|       | <a href="#previous">N[ext]</a>[!]         |                                   |
|       | <a href="#previous">pre[vious]</a>[!]     |                                   |
|       | <a href="#rewind">rew[ind]</a>[!]       |                                   |
|       | <a href="#last">la[st]</a>            |                                   |
|       | <a href="#wnext">wn[ext]</a>[!]        |                                   |
|       | <a href="#file">f[ile]</a>            | [file]                            |
|       | <a href="#edit">e[dit]</a>[!]         | [+line] [file]                    |
|       | <a href="#ex">ex</a>[!]             | [+line] [file]                    |
|       | <a href="#visual">vi[sual]</a>[!]       | [+line] [file]                    |
|       | <a href="#open">o[pen]</a>[!]         | [+line] [file]                    |
^-------^-------------------^-----------------------------------^
</pre>

The "args list" is a list of file names.
It provides an easy way to edit a whole series of files, one at a time.
Initially, it contains any file names that you named on the command line
when you invoked Elvis.

<dl>

<dt><a name="args">ar[gs]</a> <code>[</code><var>file</var><code>...]</code>
<dd>
The <code>:args</code> command displays the args list, with the
current file name enclosed in brackets.
You can also use <code>:args</code> to replace the args list with a new
set of files;
this has no effect on whatever file you're editing at that time, but
it will affect any <a href="#next">:next</a> commands that you give later.

<dt><a name="next">n[ext]</a><code>[</code>!<code>]</code> <code>[</code><var>file</var><code>...]</code>
<dd>
The <code>:next</code> command switches to the next file in the args list.
This means it loads the next file from the args list into an edit buffer,
and makes that edit buffer be the current buffer for this window.
You can also give a new args list on the <code>:next</code> command line;
this acts like a <code>:args</code> command to set the args list, followed by
an argumentless <code>:next</code> command to load the next (first) file in
that list.

<dt><a name="Next">N[ext]</a><code>[</code>!<code>]</code>
<br><a name="previous">pre[vious]</a><code>[</code>!<code>]</code>
<dd>The <code>:Next</code> (with a capital "N") and <code>:previous</code> commands
are identical to each other.
They both move backwards through the args list.

<dt><a name="rewind">rew[ind]</a><code>[</code>!<code>]</code>
<br><a name="last">la[st]</a>
<dd>The <code>:rewind</code> and <code>:last</code> commands switch to the first and
last files in the args list, respectively.

<dt><a name="wnext">wn[ext]</a><code>[</code>!<code>]</code>
<dd>
The <code>:wnext</code> command is like a <a href="#write">:write</a> command
followed by a <a href="#next">:next</a> command.
It saves any changes made to the current file before switching to the next
file.
(The <a href="elvisopt.html#autowrite">autowrite</a> option offers a better
alternative.)

<dt><a name="file">f[ile]</a> <code>[</code><var>file</var><code>]</code>
<dd>
The <code>:file</code> command displays information about the current buffer.
It can also be used to change the filename associated with this buffer.

<dt><a name="edit">e[dit]</a><code>[</code>!<code>]</code> <code>[</code>+<var>line</var><code>]</code> <code>[</code><var>file</var><code>]</code>
<br><a name="ex">ex</a><code>[</code>!<code>]</code> <code>[</code>+<var>line</var><code>]</code> <code>[</code><var>file</var><code>]</code>
<dd>The <code>:edit</code> and <code>:ex</code> commands are identical to each other.
They both switch to a new file, or if no file is named then they reread
the current file.
This has no effect on the args list.

<dt><a name="visual">vi[sual]</a><code>[</code>!<code>]</code> <code>[</code>+<var>line</var><code>]</code> <code>[</code><var>file</var><code>]</code>
<br><a name="open">o[pen]</a><code>[</code>!<code>]</code> <code>[</code>+<var>line</var><code>]</code> <code>[</code><var>file</var><code>]</code>
<dd>The <code>:visual</code> and <code>:open</code> commands switch to a new file if
one is named; otherwise they continue to use the current buffer <em>without</em>
reloading it from the original file.
These commands have the side-effect of switching the window mode from ex mode
to either the normal visual mode or the uglier "open" mode, respectively.
"Open" mode allows you to use all of the visual commands, but it only displays
a single line (the line that the cursor is on) at the bottom of the screen.
The sole advantage that "open" mode has over "visual" mode is that "open"
mode doesn't need to know what kind of terminal you're using.

</dl>

<h2><a name="QUIT">4.11 Quitting</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#close">cl[ose]</a>[!]        |                                   |
|       | <a href="#quit">q[uit]</a>[!]         |                                   |
|       | <a href="#wquit">wq[uit]</a>[!]        | [file]                            |
|       | <a href="#xit">x[it]</a>[!]          | [file]                            |
|       | <a href="#qall">qa[ll]</a>[!]         |                                   |
|       | <a href="#preserve">pres[erve]</a>        |                                   |
^-------^-------------------^-----------------------------------^
</pre>

Except for <code>:qall,</code> all of these commands attempt to close the current
window without losing any changes.
When the last window is closed, Elvis exits.
The differences between these commands concern how modified buffers are handled.
In the discussions below, it is assumed that
<a href="elvisopt.html#tempsession">tempsession</a> is True and the buffer's
<a href="elvisopt.html#retain">retain</a> option is False, which is usually
the case.

<dl>

<dt><a name="close">cl[ose]</a><code>[</code>!<code>]</code>
<dd>
The <code>:close</code> command is the simplest.
If the current window is the only window and one or more buffers have been
modified but not yet saved, then <code>:close</code> will fail;
otherwise the current window will be closed.
The visual <a href="elvisvi.html#^Wq">^Wq</a> command uses this command internally.
If the window's buffer was modified, then Elvis will just have a modified
buffer lying around, which may or may not be visible in some other window.
That's okay.
The other quitting commands won't allow you to lose that buffer accidentally.
You can make some other window view that buffer by giving that buffer's
name in parentheses on an ex command line in that other window.

<dt><a name="quit">q[uit]</a><code>[</code>!<code>]</code>
<dd>
The <code>:quit</code> command fails if the current buffer has been modified.
If you wish to abandon the changes made to the current buffer, you can add
a "!" to the end of the command name; this has the effect of turning off
the buffer's <a href="elvisopt.html#modified">modified</a> flag.

<dt><a name="xit">x[it]</a><code>[</code>!<code>]</code> <code>[</code><var>file</var><code>]</code>
<dd>
The <code>:xit</code> command saves the file if it has been modified, and then
closes the window.
The visual <a href="elvisvi.html#Z">ZZ</a> command uses this command internally.

<dt><a name="wquit">wq[uit]</a><code>[</code>!<code>]</code> <code>[</code><var>file</var><code>]</code>
<dd>
The <code>:wquit</code> command saves the file regardless of whether it has been
modified, and then closes the window.

<dt><a name="qall">qa[ll]</a><code>[</code>!<code>]</code>
<dd>
The <code>:qall</code> command tries to close all of the windows at once.
It is equivalent to giving the <code>:quit</code> command in each window.

<dt><a name="preserve">pre[serve]</a>
<dd>
The <code>:preserve</code> command closes all windows and exits, but it doesn't
delete the session file.
You can restart the same edit session later by giving the command...
<pre>
	elvis -s<var>sessionfile</var>
</pre>
...where <var>sessionfile</var> is the name of the session file, 
usually "/var/tmp/elvis1.ses".
You may want to check the value of the
<a href="elvisopt.html#session">session</a> option first, just to make sure.

</dl>

<h2><a name="MACRO">4.12 Scripts and macros</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#AT">@</a>                 | cutbuf                            |
|       | <a href="#source">so[urce]</a>[!]       | file                              |
|       | <a href="#safely">safel[y]</a>          | excmds                            |
|       | <a href="#alias">al[ias]</a>[!]        | [name [excmds]]                   |
|       | <a href="#unalias">unal[ias]</a>[!]      | name                              |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><a name="AT">@</a> <var>cutbuf</var>
<dd>
The <code>:@</code> command executes the contents of a cut buffer as a series
of ex command lines.

<dt><a name="source">so[urce]</a><code>[</code>!<code>]</code> <var>file</var>
<dd>
The <code>:source</code> command reads a file, and executes its contents as a
series of ex commands.
Normally, Elvis would issue an error message if the requested file didn't
exist but when a "!" is appended to the command name, Elvis will silently
ignore the command if it doesn't exist.

<dt><a name="safely">safel[y]</a><code>[</code>!<code>]</code> <var>excmds</var>
<dd>
The <code>:safely</code> executes its arguments as an ex command line.
While the argument commands are running,
the <a href="elvisopt.html#security">security</a> option is temporarily set
to "safer" so most dangerous commands (security holes) are blocked.
In particular, "<code>:safely source</code> <var>filename</var>"
is a good way to run untrusted scripts.

<dt><a name="alias">al[ias]</a><code>[</code>!<code>]</code> <code>[</code><var>name</var> <code>[</code><var>excmds</var><code>]]</code>
<dd>The <code>:alias</code> command manipulates the alias list.
(See the <a href="elvistip.html#ALIAS">Tips</a> section of the manual for
a discussion of aliases.)
With no arguments, <code>:alias</code> lists all user-defined aliases,
and <code>:alias!</code> lists all system-defined aliases.

<p>When given a name but no commands, <code>:alias</code> displays the
complete definition of the named alias.

<p>When given a name and commands, <code>:alias</code> defines (or redefines)
an alias.
Adding a "!" suffix (<code>:alias!</code>) will cause the alias to be marked
as a system alias, which is only significant because the
<a href="#mkexrc">:mkexrc</a> command doesn't save system aliases.

<dt><a name="unalias">unal[ias]</a> <var>name</var>
<dd>
The <code>:unalias</code> command deletes the alias with a given name.

</dl>

<h2><a name="ERRLIST">4.13 Working with a compiler</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#cc">cc</a>[!]             | [args]                            |
|       | <a href="#make">mak[e]</a>[!]         | [args]                            |
|       | <a href="#errlist">er[rlist]</a>[!]      | [file]                            |
^-------^-------------------^-----------------------------------^
</pre>

If you use Elvis to edit source code for programs, then you can have
Elvis read the output of your compiler and parse that output for error
messages.
When Elvis finds an error message, it can move the cursor to the file and
line number where the error was reported.

<p>To parse the compiler output, Elvis first breaks the output into lines.
Each line is then broken into words.
If a word looks like a number, then it is assumed to be a line number.
If a word looks like the name of an existing file, then it is assumed to
be a file name.
Any line which contains both a line number and a file name is treated as
an error report (with the remainder of the line serving as a description
of the error); lines which don't have both of these are simply ignored.

<dl>

<dt><a name="cc">cc</a><code>[</code>!<code>]</code> <code>[</code><var>args</var><code>]</code>
<br><a name="make">mak[e]</a><code>[</code>!<code>]</code> <code>[</code><var>args</var><code>]</code>
<dd>The <code>:cc</code> and <code>:make</code> commands use the
<a href="elvisopt.html#ccprg">ccprg</a> and
<a href="elvisopt.html#makeprg">makeprg</a> options, respectively,
to run your compiler or "make" utility, and collect the output.
Elvis will then move the cursor to where the first error was detected.
(If there were no errors, Elvis will say so and leave the cursor unchanged.)

<dt><a name="errlist">er[rlist]</a><code>[</code>!<code>]</code> <code>[</code><var>file</var><code>]</code>
<dd>
After that, the <code>:errlist</code> command can be used repeatedly to move
to each successive error.
You can also use the <code>:errlist</code> command with a file name argument
to load a new batch of error messages from a file; the cursor is then moved
to the first error in that batch.

</dl>

<h2><a name="CALC">4.14 Built-in calculator</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#calculate">ca[lculate]</a>       | expr                              |
|       | <a href="#eval">ev[al]</a>            | expr                              |
^-------^-------------------^-----------------------------------^
</pre>

Elvis has a built-in calculator which uses a C-like syntax.
It is described in section <a href="elvisexp.html">12: Arithmetic Expressions.</a>
The <a href="#if">:if</a>, <a href="#while">:while</a>,
<a href="#switch">:switch</a>, and <a href="#let">:let</a>
commands also use the calculator.

<dl>

<dt><a name="calculate">ca[lculate]</a> <var>expr</var>
<dd>
The <code>:calculate</code> command evaluates an expression and displays the
result.

<dt><a name="eval">ev[al]</a> <var>expr</var>
<dd>
The <code>:eval</code> command evaluates an expression using the simpler syntax
(which basically means that text outside of parentheses is left alone),
and then executes the result as an ex command line.
This provides a way to use expressions with commands which would not
ordinarily use expressions.
For example, the following command line inserts the value the
<a href="elvisopt.html#elvispath">elvispath</a> option into the current
edit buffer.
<pre>
	:eval insert elvispath=(elvispath)</pre>

<p><strong>Note:</strong>
There is a hardcoded limit of (normally) 1023 characters for the result of
any expression.  This limit will sometimes impact the use of :eval.
For example, if your <code>$EXINIT</code> environment variable is longer
than 1023 characters then Elvis will be unable to interpret it during
initialization.

</dl>

<h2><a name="BUFFER">4.15 Buffer commands</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#all">al[l]</a>[!]          | excmds                            |
|       | <a href="#buffer">b[uffer]</a>[!]       | [buffer]                          |
|       | <a href="#OPEN">(</a>                 | buffer                            |
|       | <a href="#bbrowse">bb[rowse]</a>[!]      |                                   |
|       | <a href="#sbbrowse">sbb[rowse]</a>[!]     |                                   |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><a name="all">al[l]</a><code>[</code>!<code>]</code> <var>excmds</var>
<dd>
The <code>:all</code> command applies a given ex command line to each edit buffer
in turn.
Normally the command is applied just to the user edit buffers, but if you
append a "!" to the command name, then the ex command line is applied to
internal buffers as well.
For example, the following sets the "bufdisplay" option of all user
edit buffers:
<pre>
	:all set bufdisplay=normal</pre>

<p>In script files, you can supply multiple command lines to a single
<code>:all</code> commands
by placing a '{' character on the <code>:all</code>
line, following that with any number of command lines, and then finally a '}'
character on a line by itself to mark the end.
This notation doesn't allow nesting; you can't use {...} inside a larger
{...} command list.
(Hopefully this limitation will be lifted soon.)

<dt><a name="buffer">b[uffer]</a><code>[</code>!<code>]</code> <code>[</code><var>buffer</var><code>]</code>
<dd>
The <code>:buffer</code> command lists either all user edit buffers, or
(when "!" is appended to the command name) <em>all</em> buffers including
internal ones.
If the buffer is being edited in one or more windows, then the window ID
is also displayed.
Buffers which have been modified will be marked with an asterisk.

<p>You can also use the <code>:buffer</code> command to make the current window
display a different buffer.

<dt><a name="OPEN">(</a> <var>buffer</var>
<dd>
The <code>:(</code><var>buffer</var> notation causes the current window to display the
named buffer, instead of the current buffer.
This isn't really a command;
it is part of an address.
Whenever you give an address without specifying a command, Elvis
moves the cursor to the addressed line.
In this particular case, we're addressing the most recently changed line
of a given buffer, so that's where the cursor is moved to.
For more information, see the discussion of <a href="#BUFFERID">Buffer IDs</a>
earlier in this chapter (in the discussion of addresses).

<dt><a name="bbrowse">bb[rowse]</a>
<br><a name="sbbrowse">sbb[rowse]</a>
<dd>
The <code>:bbrowse</code> and <code>:sbbrowse</code> commands create an HTML document
which lists the names of all user buffers (or, when a '!' is appended to the
command name, <em>all</em> buffers including internal buffers).
You can then go to one of the buffers just by following the hypertext link.
The difference between these two commands is that <code>:bbrowse</code> displays
the list in the current window, but <code>:sbbrowse</code> creates a new
window to display it.

</dl>

<h2><a name="WINDOW">4.16 Window commands</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#split">sp[lit]</a>           | [+line] [file | !shellcmd]        |
|       | <a href="#new">new</a>               |                                   |
|       | <a href="#only">on[ly]</a>            |                                   |
|       | <a href="#snew">sne[w]</a>            |                                   |
|       | <a href="#snext">sn[ext]</a>           | [file...]                         |
|       | <a href="#sNext">sN[ext]</a>           |                                   |
|       | <a href="#srewind">sre[wind]</a>         |                                   |
|       | <a href="#slast">sl[ast]</a>           |                                   |
|       | <a href="#stag">sta[g]</a>            | [tag]                             |
|       | <a href="#sbrowse">sb[rowse]</a>         | restrictions                      |
|       | <a href="#sall">sa[ll]</a>            |                                   |
|       | <a href="#window">wi[ndow]</a>          | [ +[+] | -[-] | number | buffer]  |
|       | <a href="#display">di[splay]</a>         | [modename [language]]             |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><a name="split">sp[lit]</a> <code>[</code>+<var>line</var><code>]</code> <code>[</code><var>file</var> <code>|</code> !<var>shellcmd</var><code>]</code>
<dd>
The <code>:split</code> command creates a new window.
If you supply a file name, then it will load that file into an edit buffer
and the new window will show that buffer.
If you supply a shell command line preceded by a '!' character, then it
will create an untitled buffer, and read the output of that command line
into the buffer.
Otherwise, the new window will show the same buffer as the current window.

<dt><a name="new">new</a>
<br><a name="snew">sne[w]</a>
<dd>
The <code>:new</code> and <code>:snew</code> commands are identical to each other.
They both create a new empty buffer, and then create a new window to
show that buffer.

<dt><a name="only">on[ly]</a>
<dd>
Close all windows except the current one.
(To close only the current window, use the <a href="#close">:close</a> command.)

<dt><a name="snext">sn[ext]</a> <code>[</code><var>file</var><code>...]</code>
<br><a name="sNext">sN[ext]</a>
<br><a name="srewind">sre[wind]</a><code>[</code>!<code>]</code>
<br><a name="slast">sl[ast]</a>
<br><a name="stag">sta[g]</a> <code>[</code><var>tag</var><code>]</code>
<br><a name="sbrowse">sb[rowse]</a> <var>restrictions</var>
<dd>
The <code>:snext, :sNext, :srewind, :slast, :stag, </code> and <code>:sbrowse</code>
commands resemble the
<a href="#next">:next,</a>
<a href="#Next">:Next,</a>
<a href="#rewind">:rewind,</a>
<a href="#last">:last,</a>
<a href="#tag">:tag,</a> and
<a href="#browse">:browse</a>
commands, respectively,
except that these "s" versions create a new window for the newly loaded file,
and leave the current window unchanged.

<dt><a name="sall">sa[ll]</a>
<dd>
The <code>:sall</code> command creates a new window for any files named in the
args list, which don't already have a window.
(See section <a href="#ARGS">4.10: The args list...</a> for a discussion
of the args list.)

<dt><a name="window">wi[ndow]</a> <code>[</code>+ <code>|</code> ++ <code>|</code> - <code>|</code> -- <code>|</code> <var>number</var> <code>|</code> <var>buffer</var> <code>]</code>
<dd>
The <code>:window</code> command either lists all windows
(when invoked with no arguments) or switches to a given window.
You can specify which to switch to by giving one of the following
arguments.
<pre graphic>
    .----------.-----------------------------------------------.
    | ARGUMENT | MEANING                                       |
    |----------|-----------------------------------------------|
    |    +     | Switch to the next window, like <a href="elvisvi.html#^Wk">^Wk</a>           |
    |    ++    | Switch to the next window, wrapping like <a href="elvisvi.html#^W^W">^W^W</a> |
    |    -     | Switch to the previous window, like <a href="elvisvi.html#^Wj">^Wj</a>       |
    |    --    | Switch to the previous window, wrapping       |
    |  number  | Switch to the window whose windowid=number    |
    |  buffer  | Switch to the window editing the named buffer |
    ^----------^-----------------------------------------------^</pre>
<dt><a name="display">di[splay]</a> <code>[</code><var>modename</var> <code>[</code><var>language</var><code>]</code><code>]</code>
<dd>
The <code>:display</code> command switches the window to a new <a href="elvisdm.html">display mode</a>,
overriding the value of the <a href="elvisopt.html#bufdisplay">bufdisplay</a>
option.
The <a href="elvisopt.html#display">display</a> option indicates the current
display mode.
If you omit the new modename, then the <code>:display</code> command will list
all supported display modes, with an asterisk next to the current mode.
The "syntax" mode allows you to specify which language's syntax it is supposed
to use; if you don't specify a language, Elvis will guess the language from
the file name's extension.

</dl>

<h2><a name="SETUP">4.17 Configuration</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#abbreviate">ab[breviate]</a>[!]   | [lhs rhs]                         |
|       | <a href="#unabbreviate">una[bbreviate]</a>[!] | lhs                               |
|       | <a href="#map">map</a>[!]            | [flags] [lhs [flags] rhs]         |
|       | <a href="#unmap">unm[ap]</a>[!]        | [flags] lhs                       |
|       | <a href="#break">bre[ak]</a>[!]        | [flags] lhs                       |
|       | <a href="#unbreak">unb[reak]</a>[!]      | [flags] lhs                       |
|       | <a href="#digraph">dig[raph]</a>[!]      | [lhs [rhs]]                       |
|       | <a href="#color">col[or]</a>[!]        | [face [attributes]]               |
|       | <a href="#gui">gu[i]</a>             | text                              |
|       | <a href="#set">se[t]</a>[!]          | [option=value | option? | all]    |
|       | <a href="#local">lo[cal]</a>           | [option=value | option ]          |
|       | <a href="#let">le[t]</a>[!]          | option=expr                       |
|       | <a href="#if">if</a>                | expr                              |
|       | <a href="#then">th[en]</a>            | excmds                            |
|       | <a href="#else">el[se]</a>            | excmds                            |
|       | <a href="#try">try</a>               | excmds                            |
|       | <a href="#while">wh[ile]</a>           | expr                              |
|       | <a href="#doloop">do[loop]</a>          | excmds                            |
|       | <a href="#foreach">for[each]</a>         | option ["in"] expression          |
|       | <a href="#switch">sw[itch]</a>          | expr                              |
|       | <a href="#case">cas[e]</a>            | value [excmds]                    |
|       | <a href="#default">def[ault]</a>         | excmds                            |
|       | <a href="#mkexrc">mk[exrc]</a>[!]       | [file]                            |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><a name="abbreviate">ab[breviate]</a><code>[</code>!<code>]</code> <code>[</code><var>lhs rhs</var><code>]</code>
<br><a name="unabbreviate">una[bbreviate]</a><code>[</code>!<code>]</code> <var>lhs</var>
<dd>
The <code>:abbreviate</code> and <code>:unabbreviate</code> commands add and remove
entries to the abbreviation table, respectively.
Also, the <code>:abbreviate</code> command can be used with no arguments to list
the current contents of the abbreviation table.
For a discussion of abbreviations, see section
<a href="elvisinp.html#ABBR">3.3: Abbreviations.</a>
Normal abbreviations are only active while you're typing in a normal text
buffer; adding a '!' suffix to the command name causes the macro to be active
while you're entering ex command lines.

<dt><a name="map">map</a><code>[</code>!<code>]</code> <code>[</code><var>flags</var><code>] [</code>all <code>|</code> <var>lhs </var><code>[</code><var>flags</var><code>]</code> <var>rhs</var><code>]</code>
<br><a name="unmap">unm[ap]</a><code>[</code>!<code>]</code> <code>[</code><var>flags</var><code>]</code> <var>lhs</var>
<dd>
The <code>:map</code> and <code>:unmap</code> commands add and remove entries to the
map table, respectively.

<p>
When the <code>:map</code> command is given without any text to map, it lists
the contents of a map table, excluding cursor keys.
When invoked with the word "all" instead of text to map, it lists all
entries from the map table including cursor keys.

<p>The primary purpose of the map table is to assign actions to the cursor keypad
and the function keys.
Each of these keys sends an arbitrary but distinctive sequence of characters
when pressed.
The map tables are used to convert these arbitrary character sequences into
command keystrokes that Elvis can do something useful with.
For example, arrow keys are normally mapped to the
<a href="elvisvi.html#h">h,</a>
<a href="elvisvi.html#j">j,</a>
<a href="elvisvi.html#k">k,</a> and
<a href="elvisvi.html#l">l</a> commands.

<p>The first text argument to <code>:map</code> is the raw character sequence
sent by a key.
This can be either a literal sequence of characters, or a gui-dependent
symbol representing a particular keystroke.
See the <a href="elvisgui.html">User Interfaces</a> chapter for lists of
keystrokes.
Also, function keys can usually be denoted by #1 for the &lt;F1&gt; key,
#2 for the &lt;F2&gt; key, and so on.

<p>The second text argument is character sequence that Elvis should pretend you
typed whenever the raw characters are received.

<p>Elvis allows you to use symbolic names for some keys and characters.
The following symbols represent individual characters, and are case-insensitive:
<strong>&lt;Nul&gt;, &lt;BS&gt;, &lt;Tab&gt;, &lt;FF&gt;, &lt;NL&gt;,
&lt;LF&gt;, &lt;EOL&gt;, &lt;CR&gt;, &lt;Return&gt;, &lt;Enter&gt;,
&lt;Esc&gt;, &lt;CSI&gt;, &lt;Del&gt;, &lt;Nul&gt;, &lt;Space&gt;, &lt;lt&gt;,
&lt;gt&gt;, &lt;Bar&gt;,</strong> and <strong>&lt;Bslash&gt;</strong>

<p>In addition, each user interface may add its own symbols for cursor keys
and function keys.  The exact list of symbols will vary.
Typically, these names will be case-sensitive.
See the <a href="elvisgui.html#x11.keys">X11 Keys</a>,
<a href="elvisgui.html#windows.keys">Windows Keys</a>, and
<a href="elvisgui.html#termcap.keys">Termcap Keys</a> manual sections.

<p>Flags may precede either argument.
Some flags select the context in which the map applies, and some affect
the way the second argument's text is used.

<pre graphic>
.----------.------------------------------------------------------.
|  FLAG    | WHAT IT MEANS                                        |
|----------|------------------------------------------------------|
| command  | works in the normal "Command" mode                   |
| motion   | works when used as the target of an <a href="elvisvi.html#OPER">operator</a>         |
| select   | works while text is selected via <a href="elvisvi.html#V">V</a>, <a href="elvisvi.html#v">v</a>, or <a href="elvisvi.html#^V">^V</a>         |
| input    | works in "Input" or "Replace" mode on main buffer    |
| history  | works when typing an ex command or search expression |
| mode=<var>name</var>| works only if the <a href="elvisopt.html#mapmode">mapmode</a> option is set to <var>name</var>      |
| visual   | always interpret second argument text as vi commands |
| noremap  | never check second text for maps, regardless of <a href="elvisopt.html#remap">remap</a>|
| nosave   | prevent <a href="#mkexrc">mkexrc</a> from saving this map                  |
^----------^------------------------------------------------------^</pre>

<p>Using <code>:map!</code> (with a "!") causes Elvis to act as though you
used the "input" and "history" context flags.
If you don't use any context flags or "!", then Elvis will assume you
want "command", "motion", and "select" contexts.
Using "visual" implies "input" and "history", unless you explicitly supply at least one of those context flags.

<p>You can use contexts with a <code>:map</code> command that has no text
arguments to selectively list only those maps which work in that context.
You can also use contexts with <code>:unmap</code> to selectively delete
maps in a given context.

<dt><a name="break">bre[ak]</a><code>[</code>!<code>]</code> <code>[</code><var>flags</var><code>]</code> <var>lhs</var>
<br><a name="unbreak">unb[reak]</a><code>[</code>!<code>]</code> <code>[</code><var>flags</var><code>]</code> <var>lhs</var>
<dd>
The <code>:break</code> and <code>:unbreak</code> commands set and reset the breakpoint
flag for a given macro, respectively.
Using a '!' suffix causes the breakpoint to be set for an input-mode map.
This is used for debugging macros, as described in section
<a href="elvistip.html#DEBUG">16.3: How to debug macros.</a>
If a macro has its breakpoint flag set, and the
<a href="elvisopt.html#maptrace">maptrace</a> option is set to <strong>run,</strong>
then when that map is encountered Elvis will automatically switch maptrace
to <strong>step</strong> mode.

<p><strong>NOTE:</strong>
The flags are the sames as those used by <a href="#map">:map</a>, above,
but <code>:break</code> and <code>:unbreak</code> only partially support them.
This is because each entry in the map table may apply to multiple contexts,
but only has a single "break" flag.
So when you set or clear a break point in one context, it may also affect
other contexts.
Usually this isn't a problem.

<dt><a name="digraph">dig[raph]</a><code>[</code>!<code>]</code> <code>[</code><var>lhs</var> <code>[</code><var>rhs</var><code>]</code><code>]</code>
<dd>
The <code>:digraph</code> command manipulates the digraph table.
(See section <a href="elvisinp.html#DIG">3.2: Digraphs</a> for a discussion
on digraphs.)
With no arguments, it lists the digraph table.
With one argument, it removes the given digraph from the table.
With two arguments, it adds the given digraph to the table, or
if the same two ASCII characters are already in the table then it alters
the existing entry.

<p>Normally, the <code>:digraph</code> command sets the most significant bit
in the last argument's character.
That way you don't need to be able to type a non-ASCII character on your
keyboard in order to enter it into the table; you can type the ASCII
equivalent and allow Elvis to convert it to non-ASCII before storing the
digraph.
If you don't want Elvis to set the most significant bit, then append a
"!" to the end of the command name.

<dt><a name="color">col[or]</a><code>[</code>!<code>]</code> <code>[</code><var>face</var> <code>[</code><var>attributes</var><code>]</code><code>]</code>
<dd>
The <code>:color</code> command is used for configuring the colors and other
attributes of text.
If invoked without arguments, then it lists any colors/attributes you've set
(or for all faces if invoked with a ! suffix).
If invoked with the name of a face
(see <a href="#colortype">below</a>)
then it lists the colors/attributes for that single face.
If invoked with both a face name and new colors/attributes
then it changes the colors/attributes for that face.

<p>The list of possible face names is not entirely preset.
Different display modes can be configured to use totally new faces
for any purpose.
A few of the faces are built into Elvis, and several more are used in
the syntax and markup descriptions included in the standard Elvis distribution.
These are:
<pre graphic>
.------------.--------------.--------------------------------------.
| <strong>FACE NAME</strong>  | <strong>INHERIT FROM</strong> | <strong>USED FOR</strong>                             |
|------------^--------------^--------------------------------------|
|In all display modes and all user interfaces...                   |
| normal     | --           | default when window has input focus  |
| idle       | normal       | default when window loses input focus|
| bottom     | --           | ex commands at the bottom of a window|
| lnum       | (normal/idle)| line numbers for <a href="elvisopt.html#number">:set number</a>         |
| showmode   | (normal/idle)| input mode name for <a href="elvisopt.html#showmode">:set showmode</a>    |
| ruler      | (normal/idle)| line/column numbers for <a href="elvisopt.html#number">:set ruler</a>   |
| selection  | --           | selected text for <a href="elvisvi.html#v">v, V, and ^V</a> cmds  |
| hlsearch   | --           | matching text for the <a href="elvisopt.html#hlsearch">hlsearch</a> option|
| hlobject<var>n</var>  | --           | highlighting via <a href="elvisopt.html#hlobject">hlobject</a> &amp; <a href="elvisopt.html#hllayers">hllayers</a> |
| spell      | --           | highlighting via <a href="elvistip.html">spell-checking</a>      |
| fold       | --           | regions folded via the <a href="#fold">:fold</a> command |
| header     | --           | page headers if <a href="elvisopt.html#lpheader">lpheader</a> is set      |
|------------^--------------^--------------------------------------|
|In the "syntax" display modes...                                  |
| comment    | (normal/idle)| comments                             |
| string     | (normal/idle)| string literals                      |
| char       | string       | character literals                   |
| regexp     | string       | regular expression literals          |
| regsub     | regsub       | substitution text after regexp       |
| number     | (normal/idle)| number literals                      |
| keyword    | (normal/idle)| keywords                             |
| other      | keyword      | names matching "other" keyword descr.|
| function   | (normal/idle)| names which appear to be functions   |
| variable   | (normal/idle)| any other name                       |
| prep       | (normal/idle)| preprocessor directives              |
| prepquote  | (normal/idle)| filenames in preprocessor directives |
| doc        | (normal/idle)| embedded documentation               |
| docmarkup  | doc          | markup lines in embedded docs        |
| docindent  | doc          | embedded doc lines that are indented |
| kind<var>k</var>      | (normal/idle)| tags with "kind=<var>k</var>" if <a href="elvisopt.html#tagkind">tagkind</a> is set |
| lib<var>k</var>       | (normal/idle)| library tags w/"kind=<var>k</var>" if <a href="elvisopt.html#taglibrary">taglibrary</a>|
|------------^--------------^--------------------------------------|
| In "normal" and "syntax" display modes...                        |
| specialkey | (normal/idle)| control characters if <a href="elvisopt.html#list">list</a> is on     |
| nontext    | specialkey   | end-of-line marker if <a href="elvisopt.html#list">list</a> is on     |
| extends    | specialkey   | side-scrolling arrows if <a href="elvisopt.html#wrap">wrap</a> is off |
|------------^--------------^--------------------------------------|
|In the "hex" display mode...                                      |
| hexheading | (normal/idle)| headings in the <a href="elvisdm.html#hex">hex</a> display mode     |
| hexoffset  | (normal/idle)| offsets, at the start of each line   |
| hexcursor  | (normal/idle)| hex code for character at cursor     |
|------------^--------------^--------------------------------------|
|In the "html", "man", and "tex" display modes...                  |
| formatted  | (normal/idle)| normal text in markup display modes  |
| bold       | formatted    | boldface text                        |
| italic     | formatted    | italic text                          |
| underlined | formatted    | underlined text                      |
| fixed      | formatted    | fixed-pitch text                     |
| link       | formatted    | HTML hypertext reference             |
| definition | bold         | definition of a term within text     |
| graphic    | fixed        | line-drawing chars for &lt;<a href="elvisdm.html#<pre">pre graphic</a>&gt; |
| bullet     | (normal/idle)| bullets in unordered list, like &lt;<a href="elvisdm.html#<ul">ul</a>&gt; |
| markup     | (normal/idle)| markups revealed by <a href="elvisopt.html#list">list</a>/<a href="elvisopt.html#showmarkups">showmarkups</a> |
| form       | (normal/idle)| common attributes of form inputs     |
| form_button| form         | buttons such as "Submit"             |
| form_radio | form         | values of radio buttons              |
| form_check | form         | checkbox                             |
| form_text  | form         | text input fields, including textarea|
| form_other | form         | other form inputs                    |
|------------^--------------^--------------------------------------|
|In the "x11" user interface...                                    |
| cursor     | --           | cursor color                         |
| tool       | --           | toolbar buttons                      |
| toolbar    | --           | toolbar &amp; labels of disabled buttons |
| scroll     | tool         | scrollbar buttons (background only)  |
| scrollbar  | toolbar      | scrollbar background                 |
| status     | tool         | text boxes at statusbar's right edge |
| statusbar  | toolbar      | status bar &amp; text on its left edge   |
^------------^--------------^--------------------------------------^</pre>

<p>The "normal" and "idle" distinction is made so that you can configure
Elvis to display the current window differently than other windows.
For example, "<code>:color idle on gray80</code>" in the x11 user interface
will cause idle windows to be displayed with a dull background color, while
the current window is displayed with the normal background color.

<p>Normally, the new attributes you specify will completely replace the
face's existing attributes.
However, you can add or subtract the new attributes from the face's
existing attributes by placing "<code>+=</code>" or "<code>-=</code>"
at the front of the attribute string.
Also, when using the "<code>-=</code>" notation you can simply say
"<code>color</code>" instead of the face's real color;
this will remove any existing color.
For example...
<pre>
	:color hlsearch += red
</pre>... will cause <a href="elvisopt.html#hlsearch">hlsearch</a> text to be
red (in addition to any other attributes -- usually bold), and...
<pre>
	:color hlsearch -= color
</pre>
... will remove that coloration, but keep the bold attribute.

<p>The <code>:color</code> command allows you to specify other attributes
besides color.
You can specify which font it should inherit any unspecified colors
or attributes from, via a "like" clause.
You can also give attributes such as "underlined".
The complete list of attributes includes:

<table border=1 cellpadding=1>

<tr>
<th valign=top><var>color</var></th>
<td>
The foreground color.
If you don't specify a foreground color, then the inherited foreground color
is used.
The exact list of acceptable colors will vary, depending on your hardware
and the user interface.
For X-windows, you can use any of the standard color names such as black,
royal blue, or #800028.
For the termcap interface and most others, the list includes
<strong>black, red, green, brown, blue, magenta, cyan, white, gray, light red,
light green, yellow, light blue, light magenta, light cyan,</strong> and
<strong>bright white</strong>... with the caveat that the "bold" attribute
may interact strangely with the "light" or "bright" colors.
There is also <strong>default</strong> color, but not all ANSI-ish terminals
implement it correctly, so use it with caution.
</td>
</tr>

<tr>
<th valign=top>or <var>color</var></th>
<td>
An alternate foreground color.
Elvis will choose the foreground color which gives the highest contrast
against the normal background color.
(If no background color has been set, then the
<a href="elvisopt.html#background">background</a> option may affect the choice.)
Elvis also remembers the color which had the highest contrast with white,
for use when printing whenever the <a href="elvisopt.html#lpcolor">lpcolor</a>
option is set.
</td>
</tr>

<tr>
<th valign=top>on <var>color</var></th>
<td>
The background color.
If you don't specify a background color, then the inherited background color
is used.
The list of color names also varies, just as it does for foreground colors.
For most user interfaces, the list of background colors is identical to the list
of foreground colors, but the termcap interface limits you to the first 8 colors
(<strong>black</strong> through <strong>white</strong> in the above list).
<p>
The <a href="elvisgui.html#x11">x11</a> interface has experimental support for
images for some backgrounds.
For example, "color normal on blue sand.xpm" will load the "sand.xpm" image,
tint it blue, and use that as the background for normal text.
See the <a href="elvisgui.html#x11.bgimage">X11 Background Images</a> discussion
for more information.
<p>
The termcap interface also has <em>experimental</em> support for a
<strong>transparent</strong> background color, which resets the background
to its default (whatever that happens to be).
You can also use <strong>default</strong>, which tries to achieve the same
effect in a slightly different way.
If you use this feature, then you should probably set the
<a href="elvisopt.html#background">background</a> option.
</td>
</tr>

<tr>
<th valign=top>like <var>otherface</var></th>
<td>
All faces ultimately inherit from either "normal" or "idle",
depending whether the window has input focus or not.
This attribute allows you to add another font in the inheritance chain between
this font and "normal" or "idle".
For example, "<code>:color char like string</code>" causes character literals
to be displayed using the same colors and attributes as string literals.
</td>
</tr>

<tr>
<th valign=top>bold
<br>underlined
<br>italic
<br>boxed</th>
<td>
These are all attributes that can be attached to a face.
Any inherited attributes are retained; these keywords only allow you to
add new attributes to the inherited ones.
For example, ":color x underlined|color y like x bold", will cause the
"y" font to be both bold and underlined.

<p>Some user interfaces may not be able to display all of these attributes.
And even if the user interface can display them all individually, it may not
be able to display all possible combinations.

<p>The <strong>boxed</strong> attribute attempts to draw a box around the text;
for some user interfaces, or when printing to some types of printers, the
box may be implemented by changing the background.
In the termcap user interface, it uses the standout attribute.
</td>
</tr>

<tr>
<th valign=top>graphic</th>
<td>
This is a special attribute.
It causes some characters to be converted to line-drawing characters.
This is used for implementing the &lt;pre graphic&gt; tag in HTML.
</td>
</tr>

<tr>
<th valign=top>fixed
<br><a name="PROPORTIONAL">proportional</a></th>
<td>
On your screen these attributes have no effect, but when printing via the
<a href="#lpr">:lpr</a> command they may select between fixed-pitch and
variable-pitch fonts.
Some <a href="elvisopt.html#lptype">lptype</a> settings don't support this,
and among those that do, some support it better than others.

<p>Printing with proportional fonts is a little quirky because Elvis'
text formatting was designed to support only fixed-pitch fonts.
The "epson", "pana", "ibm", and "hp" <a href="elvisopt.html#lptype">lptype</a>s
support proportional printing, but are unable to make columns line up
correctly when you use it.
Because proportional text tends to be narrower than fixed-pitch text,
you may want to increase <a href="elvisopt.html#lpcolumns">lpcolumns</a>
from 80 to about 110, if your document consists mostly of proportional text.

<p>The "ps", "ps2", and "windows" <a href="elvisopt.html#lptype">lptype</a>s
handle proportional text in a different way.
In order to prevent overlaps or large gaps when mixing fonts on
a line, these drivers adjust the width of
each chunk of proportional text to match the width it would have had
if it was fixed-pitch.
For large chunks you'll probably never notice, but if you have a single
word in a proportional font, and most of the letters in that word happen
to be narrow, then the stretching may be significant.
</td>
</tr>

</table>

<dt><a name="gui">gu[i]</a> <var>text</var>
<dd>
The <code>:gui</code> command provides a way to pass unusual commands to the
user interface.
Currently, the only user interface which uses this is the "x11" interface,
which uses it mostly to
<a href="elvisgui.html#x11.toolbar">configure the toolbar.</a>

<dt><a name="set">se[t]</a><code>[</code>!<code>]</code> <code>[</code><var>option</var>=<var>value</var><code>... |</code> <var>option</var>?<code>... |</code> all <code>|</code> everything<code>]</code>
<dd>
The <code>:set</code> command allows you to examine or change the values of
<a href="elvisopt.html">options.</a>

<p>With no arguments, <code>:set</code> lists the names and values of any
options that have been altered or are of frequent interest.
If given the argument "all" it will list the names and values of
most (but not really all) options.
If given the argument "everything", it really will list all options.
If given the name of an option followed by a "?"  character,
<code>:set</code> will output the option's name and value.
If given the name of a group of options, followed by a "?" character,
<code>:set</code> will output the names and values of all options in that group.

<p>To turn a Boolean option on, just give the name of the option.
You can turn it off by adding the prefix "no" to the option name, and you
can negate it by adding the "neg" prefix to its name.

<p>To change the value of a non-Boolean option, give the name followed
<em>immediately</em> by an "=" and the new value.
If the new value contains whitespace, you should either enclose the
entire value in quotes, or precede each whitespace character with a backslash.

<p>If you give the name of a non-Boolean option, without either
"=<var>value</var>" or "?", then Elvis will display its value.

<pre graphic>
.-----------.----------------------------------------------------.
| EXAMPLE   | WHAT IT DOES                                       |
|-----------|----------------------------------------------------|
| :set      | display names &amp; values of changed/important options|
| :set all  | display names &amp; values of most POSIX-compliant opts|
| :set ts?  | display name &amp; value of the tabstop option         |
| :set lp?  | display names &amp; values of all printing options     |
| :set ts=4 | set value of the tabstop option to 4               |
| :set ai   | turn on the autoindent option                      |
| :set noai | turn off the autoindent option                     |
| :set negai| toggle the autoindent option                       |
^-----------^----------------------------------------------------^</pre>

<p>Adding a "!" to the end of the command name (<code>:set!</code>)
affects the behavior in two ways.
First, it causes any displayed options to be shown with the short name, and
the name of their group.
For example, "<code>:set! tabstop</code>" shows "buf.ts=8".

<p>The other difference is that <code>:set!</code> changes the option's default
value in addition to its current value, and then marks the option as having
<em>not</em> been changed.
This is used mostly in Elvis' initialization scripts.

<dt><a name="local">lo[cal]</a> <var>option</var>=<var>value</var><code>... |</code> <var>option</var><code>...</code>
<dd>The <code>:local</code> command is similar to <a href="#set">:set</a>, and is
intended to be used in <a href="elvistip.html#ALIAS">aliases</a> and scripts.
In addition to setting options' values, it also pushes the old values onto a
stack; the old values are automatically restored at the end of the alias or
script.
Another difference is that where <code>:set</code> would output an option,
<code>:local</code> merely pushes its old value, without outputting or changing
the option's value.
This means that you can save a non-Boolean option simply by mentioning its name
on a <code>:local</code> command line; Boolean options can also be saved without
altering them, but you must put a question mark after the option's name.

<p> Here's a simple alias which uses <code>:local</code>.
It adds up the numbers in all lines from the current line forward to the next
line which contains the "total:", and stores the sum in the "total:" line.
<pre>
    :alias total {
        local nowrapscan ignorecase t=0
        .,/total:/-1 s/\d\+/let t=t+&amp;/x
        eval /total:/ s/total:.*/total: (t)/
    }</pre>

<dt><a name="let">le[t]</a><code>[</code>!<code>]</code> <var>option</var> <code>[</code><var>oper</var><code>]</code>= <var>expr</var>
<br>le[t]<code>[</code>!<code>]</code> <var>option</var> =~ <var>excmds</var>
<dd>
Both forms of the <code>:let</code> command compute a new value for an option.
The "= <var>expr</var>" (or "<var>oper</var>= <var>expr</var>") form
evaluates an <a href="elvisexp.html">expression</a> to produce the new value.
The <var>oper</var>, if used, can be any of the
<a href="elvisexp.html#operators">expression operators</a>, and must be
followed immediately by the "=", without any intervening whitespace.
As in C, using an operator in this way causes the assigned option to be
treated as the left-hand operand for the operator, and the rest of the
expression as the right-hand operand.
<pre>
    :let a = 2+2
    :calc a
    4
    :let a &lt;&lt;= 3
    :calc a
    32</pre>

<p>Note that even Boolean options use the "=" notation here.
You <em>can not</em> say ":let nowrap" to turn off the
<a href="elvisopt.html#wrap">wrap</a> option, for example.

<p>The "=~ <var>excmds</var>" form is only available if Elvis is compiled
with FEATURE_EQUALTILDE defined (i.e., if <code>:calc&nbsp;feature("equaltilde")</code> returns <code>True</code>).
This form stores the option's old value into a buffer,
applies the <var>excmds</var> to that buffer, and then
copies the resulting buffer back into the option.
This is most useful when used with the <a href="#substitute">:s</a> command.
For example, the following capitalizes the first letter of each word in "a".
<pre>
    :let a =~ s/\&lt;\w/\u&amp;/g</pre>

<p>If Elvis is compiled with array support
(that is, if <code>:calc&nbsp;feature("array")</code> says <code>True</code>)
then you can also use a subscript after the option name, to change just
part of its value.
For more information about subscripts, see the discussion in the
<a href="elvisexp.html#subscripts">Arithmetic Expressions</a> chapter.

<p>When invoked as <code>:let!</code> (with a '!' suffix),
Elvis will set both the current and default values of the option,
and mark the option has having <em>not</em> been changed.
This is used in some of Elvis' initialization scripts.

<dt><a name="if">if</a> <var>expr</var>
<br><a name="then">th[en]</a> <var>excmds</var>
<br><a name="else">el[se]</a> <var>excmds</var>
<dd>The <code>:if</code> command evaluates an <a href="elvisexp.html">expression</a>,
and sets an internal variable according to whether the result was true or false.
Later, the <code>:then</code> and <code>:else</code> commands can be used to test
that variable, and conditionally execute other ex commands.

<p>Note that after an <code>:if</code> command, any other ex commands which
don't start with <code>:then</code> or <code>:else</code> will be executed
unconditionally.

<p>In aliases or script files, you can supply multiple command lines to a single
<code>:then</code> or <code>:else</code> by placing a '{' character on the
<code>:then/:else</code> line,
following that with any number of command lines, and then finally a '}'
character on a line by itself to mark the end.
The following example demonstrates this syntax, and also shows that you
can safely use <code>:if</code> inside a <code>:then</code> or
<code>:else</code> command:
<pre>
	:if i &lt;= 0
	:then {
		if i == 0
		then echo zero
		else echo negative
	}
	:else echo positive</pre>

<dt><a name="try">try</a> <var>excmds</var>
<dd>
The <code>:try</code> command executes its argument text as an ex command line.
Regardless of whether that command line succeeds or fails, the <code>:try</code>
command itself always succeeds.
That's significant because when a command fails, all pending aliases, macros,
and scripts are canceled; <code>:try</code> prevents that.
Error messages and warning messages are disabled while the command line runs.
Afterward, the then/else is set to indicate whether the command line succeeded.
This command is useful for implementing specialized error handing in an
alias or script.
The following example will search for "foo";
if there is no "foo" then it will search for "bar":
<pre>
    :try /foo
    :else /bar</pre>

<dt><a name="while">wh[ile]</a> <var>expr</var>
<br><a name="doloop">do[loop]</a> <var>excmds</var>
<dd>The <code>:while</code> command stores an expression.  It should be followed by
a <code>:do</code> command; the <code>:do</code> command repeatedly evaluates
the expression, and as long as the result is true it executes the commands
which follow the <code>:do</code>.  The following example counts from
1 to 10:
<pre>
    :let i=1
    :while i &lt;= 10
    :do {
        calc i
        let i=i+1
    }</pre>

<dt><a name="foreach">for[each]</a> <var>option</var> <code>[</code>in<code>]</code> <var>files...</var>
<br>for[each] <var>option</var> <var>expression</var>
<dd>The <code>:foreach</code> or <code>:for</code> command is similar to
<code>:while</code> in that it sets up information that
<code>:do</code> uses for looping.
The difference is that it sets up different information: A variable name,
and a list of values that the variable should take on.
<p>
If the list expression begins with the word "in", then "in" will be
stripped off and the remainder will be interpreted as a space-delimited list
of file names.
You can use <kbd>backslash-space</kbd> to embed actual spaces in the names.
If the file names contain wildcard characters, then they'll be expanded to
the actual file names.
The body of the loop is executed separately for each matching file name.
<pre>
    for i in *.h
    do calc i</pre>
<p>
Without the word "in", the remaining arguments are evaluated using the
normal expression syntax, and the result is then divided into
whitespace-delimited words.
The body of the loop is executed separately for each word.
<pre>
    foreach i (1..10)
    do calc i</pre>

<dt><a name="switch">sw[itch]</a> <var>expr</var>
<br><a name="case">cas[e]</a> <var>label</var> <code>[</code><var>excmds</var><code>]</code>
<br><a name="default">def[ault]</a> <var>excmds</var>
<dd>The <code>:switch</code> command evaluates an expression and stores the result.
The <code>:case</code> command compares that result to a given value, and executes
an ex command line if it matches.
If you omit the command line then it will carry forward to the next <code>:case</code> which does have an
ex command line; this allows multiple cases to share a single
ex command line.
The <code>:default</code> command executes its ex command line if no previous case
was matched.
Here's an example:
<pre>
    :switch os
    :case unix
    :case win32 echo Elvis has graphical and text-mode interfaces.
    :case os2 {
      echo Elvis has been ported natively as a text-mode program.
      echo You can also compile it to use the X11 interface from
      echo Unix, but you need the EMX libraries to run it.
    }
    :case msdos echo Elvis is slow and ugly under DOS.
    :default echo How are you even running this?
</pre>

Notice that there is no punctuation after the case value, and that there is
no "break" or "endswitch" command.
This example says "Elvis has graphical and text mode interfaces" for both
the "unix" and "win32" cases; the "unix" case has no command, so it falls
through to the "win32" case.

<p>The <code>:if/:then/:else</code>, <code>:while/:do</code>, and
<code>:switch/:case/:default</code> command structures all permit nesting.
I.e., the commands in a <code>:then</code> command
can't affect the "if" variable to cause the <code>:else</code> command to
also be executed.

<dt><a name="mkexrc">mk[exrc]</a><code>[</code>!<code>]</code> <code>[</code><var>file</var><code>]</code>
<dd>
The <code>:mkexrc</code> command creates a file containing ex commands which
recreate most of configuration features of Elvis, including:
<ul>
<li> the <a href="#map">map</a> table
<li> the <a href="#abbreviate">abbreviation</a> table
<li> the <a href="#digraph">digraph</a> table
<li> the <a href="#autocmd">autocmd</a> tables
<li> custom spell-checker <a href="#words">words</a>
<li> any options which have been <a href="#set">set</a>
</ul>

<p>If invoked with a filename, then
the <a href="elvisopt.html#mkexrcfile">mkexrcfile</a> option will be set to
that name;
this setting will be stored in the script, along with your other settings.
If the named file already exists, then you must use <code>:mkexrc!</code>
(with a "!" suffix) to overwrite it.

<p>If you don't specify a filename, then it will write to the file whose name
is already stored in the <a href="elvisopt.html#mkexrcfile">mkexrcfile</a>
option.
If that file already exists, then <code>:mkexrc</code> will overwrite the
file <em>without requiring a "!" suffix</em>.

<p>If <a href="elvisopt.html#mkexrcfile">mkexrcfile</a> hasn't been set,
and you don't specify a name on the command line, then <code>:mkexrc</code>
will act as though you invoked it with a default name -- either ".elvisrc"
or "elvis.rc" in the <a href="elvisopt.html#home">home</a> directory,
depending on the operating system.
Elvis' default initialization will <a href="#source">:source</a> that file,
so you don't need to explicitly <code>:source</code> it yourself each time
you start Elvis.
That's convenient.

<p>In summary:
The first time you run <code>:mkexrc</code> without arguments, it will store
the configuration in a standard place.
After that, when you invoke <code>:mkexrc</code> without arguments, it will
overwrite the previous configuration file.
You can also explicitly make it write the configuration out to some other
file if you want to.

</dl>

<h2><a name="AUTOCMD">4.18 Auto commands</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#auevent">aue[vent]</a>[!]      | [event] ...                       |
|       | <a href="#augroup">aug[roup]</a>[!]      | [group]                           |
|       | <a href="#autocmd">au[tocmd]</a>[!]      | [group] [events [file [excmd]]]   |
|       | <a href="#doautocmd">doa[utocmd]</a>       | [group] event [file]              |
^-------^-------------------^-----------------------------------^
</pre>

These commands only exist if the <code>FEATURE_AUTOCMD</code> feature was
enabled when Elvis was compiled.
(The command `<a href="#calculate">:calc</a>
<a href="elvisexp.html#feature">feature("autocmd")</a>' should return <code>True</code>.)
<p>
This is vim's way to run commands automatically in certain situations. 
See the discussion in the <a href="elvistip.html#AUTOCMD">Tips</a> chapter.
It is sort of like Elvis' <a href="elvisses.html#elvis.arf">elvis.arf</a>
file and related files, but much more versatile.
I'm trying to add it to Elvis to gain that versatility.
It is extremely complex, though, so you should expect to be baffled as you
read the following...

<dl>

<dt><a name="auevent">aue[vent]</a><code>[</code>!<code>]</code> <code>[</code><var>event</var><code>] ...</code>
<dd>This lets you create new event types (as additions to the built-in list).
The events won't be triggered automatically, but you can explicitly trigger
them via the <a href="#doautocmd">:doautocmd</a> command.
For example, the following commands create a new event named "BufAdd",
and arrange for it to behave mostly as a synonym for the built-in
<a href="elvistip.html#BufCreate">BufCreate</a> event.
<pre>
	:auevent BufAdd
	:au BufCreate * doau BufAdd</pre>

<p>For a more complex example,
the following commands create a new event named "FileChangedRO",
arrange for it to be triggered on the first modification that you make to
a readonly file, and then use it to give a warning when you start modifying
a readonly file:
<pre>
	:auevent FileChangedRO
	:au OptSet modified {
	  if readonly
	  then doau FileChangedRO
	}
	:au FileChangedRO * message ^GChanging a readonly file!</pre>
<p><strong>Note:</strong>
Vim doesn't have a <code>:auevent</code> command.
I added it to Elvis because vim is rapidly acquiring new events, and
it seemed easier to add a general solution like this than to try to
reimplement all of vim's new events in Elvis.

<dt><a name="augroup">aug[roup]</a><code>[</code>!<code>]</code> <code>[</code><var>group</var><code>]</code>
<dd>Auto commands are divided into groups, for the sake of convenience.
The <code>:augroup</code> command creates groups, lists them, or selects one
for editing.
It has no effect on which events get run, though -- it is used purely for
editing.

<p>When invoked without arguments, it lists the current groups.

<p>When invoked with a group name as an argument, it selects that group as
being the one that later <a href="#autocmd">:autocmd</a> commands will edit.
The default group is named "END", so most sequences of autocmd configuration
commands begin with "<code>:aug</code>&nbsp;<var>group</var>", contain any
number of <a href="#autocmd">:au</a> commands, and then end with
"<code>:aug&nbsp;END</code>".

<p>You can create your own groups.
If the group name that you specify didn't exist before this command,
then <code>:aug</code> will create it.

<p>The "!" suffix is used to indicate whether the named group should be
saved by the <a href="#mkexrc">:mkexrc</a> command.
Generally, you won't use "!" in your own <code>:aug</code> commands.
Elvis' standard scripts use "<code>:aug!</code>"
to set up a standard set of auto commands.
You wouldn't want them in your .exrc file, since they're already in the
standard scripts.

<dt><a name="autocmd">au[tocmd]</a><code>[</code>!<code>]</code> <code>[</code><var>group</var><code>]</code> <code>[</code><var>events</var> <code>[</code><var>file</var> <code>[</code><var>excmd</var><code>]</code><code>]</code><code>]</code>
<dd>The <code>:au</code> command lists, adds, or deletes auto command entries
from the current group.
The events are described in the <a href="elvistip.html#EVENTS">Tips</a>
chapter.

<p>The <var>group</var>, <var>events</var>, and <var>file</var> arguments are
used to select the event.
The <var>group</var> can be any group name that was created by an earlier
<a href="#augroup">:augroup</a> command; if omitted, it defaults to the name
used in the most recent "<a href="#augroup">:augroup</a>&nbsp;<var>group</var>"
command.
The <var>events</var> parameter is a comma-delimited list of events
as described in the <a href="elvistip.html#EVENTS">Tips</a> chapter,
or "*" for all events; if you omit it (and all parameters after it),
it defaults to "*", which is handy when listing files.
The <var>file</var> argument is a wildcard pattern such as "*.c"; if you
omit it (and all parameters after it), it defaults to "*" so the pattern will
work for any files.
The <var>excmd</var> is any ex command line, or {...} delimited group of lines;
it may access the
<a href="elvisopt.html#auevent">auevent</a>,
<a href="elvisopt.html#aufilename">aufilename</a>, and
<a href="elvisopt.html#auforce">auforce</a> options to determine what triggered
the event.

<p>Vim allows the special keyword "nested" to appear at the start of the
<var>excmd</var> to indicate that it can be run recursively.
Elvis allows the "nested" flag, but ignores it.
Elvis never allows auto commands to be recursive.

<p><strong>Listing:</strong>
If you don't give either a <code>!</code> after the command name
(not "<code>:au!</code>"), or a new <var>excmd</var> to run, then
<code>:au</code> will list the matching auto commands.
Some examples:
<pre>
	:au		list all commands in the current group
	:au END		list all commands in the default group
	:au BufRead	list all commands for BufRead events
	:au * *.html	list all commands for HTML files</pre>

<p><strong>Deleting:</strong>
With a <code>!</code> after the command name ("<code>:au!</code>"),
then it deletes the matching auto commands, instead of listing them.
<pre>
	:au!		delete all commands in the current group
	:au! END	delete all commands in the default group
	:au! BufRead	delete all commands for BufRead events
	:au! * *.html	delete all commands for HTML files</pre>

<p><strong>Adding:</strong>
To add an entry, use the same arguments with an ex command at then end.
The new command will be added to the end of the group.
(When multiple commands match a particular event, they're executed from
top to bottom in the list, so any existing commands will be executed
before the newly added command.
The following example adds a rule that makes all HTML files be read-only.
<pre>
	:au BufRead *.html set readonly</pre>

<p><strong>Replacing:</strong>
You can delete old auto commands and then add a new one in a single step,
by invoking <code>:au</code> with both the <code>!</code> suffix and an
new <var>excmd</var> to execute.
The following example replaces the previous one.
<pre>
	:au! BufRead *.html set noreadonly</pre>

<dt><a name="doautocmd">doa[utocmd]</a> <code>[</code><var>group</var><code>]</code> <var>event</var> <code>[</code><var>file</var><code>]</code>
<dd>This simulates an event, causing the associated auto commands to be run.
This is handy for testing your configuration, or for rerunning the commands
after you've changed your configuration.

<p>By default, it runs commands in all groups, but if you specify a
<var>group</var> then it will only run auto commands in that group.
If there is no such group, it gives an error message.

<p>The <var>event</var> argument selects the particular event you want to
simulate.

<p>The <var>file</var>, if given, is the matched against the wildcard patterns.
If you omit it, then the current file name will be used (as indicated by the
<a href="elvisopt.html#filename">filename</a> option); this is usually what
you want to do.

<p><strong>Note:</strong> Vim allows this command to be abbreviated to
"<code>:do</code>", but most users abbreviate it as "<code>:doau</code>".
That's a good thing, because Elvis already has a <a href="#doloop">:do</a>
command, used for looping.

<p><strong>Note:</strong> Vim also has a "<code>:doautoall</code>" command.
I don't expect to implement that one, since you can achieve the same effect
in Elvis by running "<code>:all doau</code>".

</dl>

<h2><a name="FOLD">4.19 Folding</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
| range | <a href="#fold">fo[ld]</a>[!]         | [name]                            |
| range | <a href="#unfold">unf[old]</a>[!]       | [name]                            |
^-------^-------------------^-----------------------------------^
</pre>

These commands are only available if your version of Elvis was compiled with
the folding feature is enabled.
(The command `<code>:calc feature("fold")</code>' should return True.)
"Folding" allows you to temporarily hide portions of your text, without
actually deleting it.

<p>Elvis allows you to create named regions called "FOLDs".
Each FOLD is either folded or unfolded, and
you can toggle a FOLD between those two states at will.
Folded regions, no matter how large, are displayed as a single line
which shows the FOLD's name.
Unfolded regions are displayed exactly like text that isn't in a FOLD.
The only reason that Elvis bothers to remember unfolded FOLDs is to
allow you to refold it easily.

<p>There are some limitations:
You can nest one FOLD inside another,
but you can't have overlapping FOLDs, or
different folds with exactly the same endpoints.
Folding only affects the appearance of the
<a href="elvisdm.html#normal">normal</a> and
<a href="elvisdm.html#syntax">syntax</a> display modes.

<p>You can use the "<a href="#color">:color</a> <code>fold</code>
<var>attributes</var>" command to control the appearance of folded FOLDs.

<dl>

<dt><var>range</var> <a name="fold">fo[ld]</a><code>[</code>!<code>]</code> <code>[</code><var>name</var><code>]</code>
<br><var>range</var> <a name="unfold">unf[old]</a><code>[</code>!<code>]</code> <code>[</code><var>name</var><code>]</code>
<dd>The <code>:fold</code> and <code>:unfold</code> commands both have a very similar
syntax.
When invoked with a range of lines and a name, they create a FOLD which
is initially either folded or unfolded, respectively.
When invoked with either just a range of lines or just a name, they
alter the state of any existing FOLDs.
The following table shows this in greater detail:
<pre graphic>
.--------------------.---------------------------------------------.
| COMMAND            | WHAT IT DOES                                |
|--------------------|---------------------------------------------|
| :<var>range</var> fold <var>name</var>   | Create a folded FOLD with the given <var>name</var>.   |
| :<var>range</var> fold        | Refold any existing FOLDs which contain     |
|                    |   lines in the given <var>range</var>.                 |
| :fold <var>name</var>         | Refold any existing FOLDs which have the    |
|                    |   given <var>name</var>.                               |
| :fold              | Refold the FOLD containing the current line.|
|--------------------|---------------------------------------------|
| :<var>range</var> unfold <var>name</var> | Create an unfolded FOLD with the given <var>name</var>.|
| :<var>range</var> unfold      | Unfold any existing FOLDs which contain     |
|                    |   lines in the given <var>range</var>.                 |
| :unfold <var>name</var>       | Unfold any existing FOLDs which have the    |
|                    |   given <var>name</var>.                               |
| :unfold            | Unfold the FOLD containing the current line.|
^--------------------^---------------------------------------------^</pre>

<p>
Both commands can accept a "!" modifier.
When FOLDs are nested inside each other, the <code>:fold</code> and
<code>:unfold</code> commands normally refold or unfold a single layer;
the "!" causes them to refold or unfold all layers.
In particular, you can unfold all FOLDs via the following command:
<pre>
	:%unfold!</pre>

<p>
For both commands, the <var>name</var> argument is evaluated using the
<a href="elvisexp.html#SIMPLER">simpler expression syntax</a>, with
<code>$1</code> being replaced by the number of lines in the <var>range</var>.
The following shows how this could be used to fold the bodies of C functions
and give the folds the same name as their function.
(This depends on the <a href="elvisopt.html#show">show</a> option
containing "tag" in it somewhere.)
<pre>
	:g/^{/,/^}/fold {(current("tag"))(":" $1 "lines")}</pre>
<p>
There are also <a href="elvisexp.html#folded">folded()</a> and
<a href="elvisexp.html#unfolded">unfolded()</a> functions.
If the cursor is in a folded FOLD, then the <code>folded()</code> function
returns its name.
Otherwise it returns "" -- even if the cursor is in an <em>unfolded</em> FOLD.
The <code>unfolded()</code> function does the opposite.
This allows you to do things like the following, which toggles folding.
<pre>
	:alias negfold {
		if folded()
		then unfold
		else fold
	}</pre>

<p>Also, see the <a href="elvisopt.html#folding">folding</a> option
for a way to enable folding in one window but disable it in another.

</dl>

<h2><a name="REGION">4.20 Regions</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
| range | <a href="#region">reg[ion]</a>          | [face [comment]]                  |
| range | <a href="#unregion">unr[egion]</a>        | [face]                            |
| range | <a href="#chregion">chr[egion]</a>        | face newface [newcomment]         |
^-------^-------------------^-----------------------------------^
</pre>

<p>These commands are only available if the region feature is enabled.
(The command `<a href="#calculate">:calc</a> <a href="elvisexp.html#feature">feature("region")</a>' should say True.)

<p>Regions give you a way to change the appearance of specific lines.
Each region has the following attributes:
<ul>
<li>a span of lines to which it applies,
<li>a face to use instead of the "normal" or "idle" face for those lines, and
<li>an optional comment.
</ul>
The face names are the same ones that are used with the
<a href="#color">:color</a> command.

<p>The <a href="elvisopt.html#show">show</a> option
can also contain a "region" word,
which causes the current region's comment to be displayed at the bottom of
the window.
You can use  <a href="elvisexp.html#current">current("region")</a> or
<a href="elvisexp.html#current">current("rcomment")</a> to access the current
region's face name or comment, respectively.

<p>All three of these commands act on the current line by default.
These are plain old '\n'-delimited lines, by the way -- the same definition
of "line" as is used by ex addresses, and the 
<a href="elvisdm.html#normal">normal</a> and
<a href="elvisdm.html#syntax">syntax</a> display modes.
When you're using any other display mode, the region highlighting may be
unreliable.

<dl>

<dt><var>range</var> <a name="region">reg[ion]</a> <code>[</code><var>face</var> <code>[</code><var>comment</var><code>]]</code>
<dd>This creates a region, or lists existing regions.
<p>
When invoked without a face name, it lists any regions which lie at least
partly within the given range of lines.
The following command lists all regions in the current buffer:
<pre>
	:%reg</pre>

<p>When invoked with a face name and optional comment, it creates a region.
If you don't specify a comment, then the face name will serve as the comment.
Regions aren't allowed to overlap, so if there were any other regions in
the given range before you invoke <code>:region</code>, they'll be clobbered.
The following comment creates a region that uses the "notes" face, covering
the first 10 lines of the file:
<pre>
	:1,10reg notes These are the first 10 lines</pre>

<dt><var>range</var> <a name="unregion">unr[egion]</a> <code>[</code><var>face</var><code>]</code>
<dd>The <code>:unregion</code> command cancels the region highlighting for
the given range of lines.
If you supply a face name, then it will only cancel regions which were
using that face; otherwise it cancels all regions within the range.
The following example gets rid of all "notes" regions, but leaves other
regions unchanged:
<pre>
	:%unr notes</pre>

<dt><var>range</var> <a name="chregion">chr[egion]</a> <var>face</var> <var>newface</var> <code>[</code><var>newcomment</var><code>]</code>
<dd>The <code>:chregion</code> command changes one type of region into
another type, based on the face.
The following is a nifty trick which
automatically marks changed lines as "unsaved" while you're editing,
and then converts those to "saved" when you write the file.
<pre>
	<a href="#color">:color</a> unsaved on red
	<a href="#color">:color</a> saved on green
	<a href="#autocmd">:autocmd</a> <a href="elvistip.html#Edit">Edit</a> * '[,']region unsaved
	<a href="#autocmd">:autocmd</a> <a href="elvistip.html#BufWritePost">BufWritePost</a> * %chregion unsaved saved</pre>

</dl>
<p>Also, running "<a href="elvistip.html#load">:load</a> <code>inregion</code>"
will add an "<code>:inregion</code> <var>face excmds</var>" alias, which you can
use to execute commands on lines in a given type of region.

<h2><a name="SPELL">4.21 Spell checking</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#words">wo[rds]</a>[!]        | [+ | -] words...                  |
|       | <a href="#wordfile">wordf[ile]</a>[!]     | [filename...]                     |
|       | <a href="#check">che[ck]</a>[!]        | [* | + | -] faces...              |
^-------^-------------------^-----------------------------------^
</pre>

<p>
These commands are only available if the spell-checking feature is enabled.
(The command `<code>:calc feature("spell")</code>' should say True.)
For more information about the spell checker, see the section in the
<a href="elvistip.html#SPELL">Tips</a> chapter, and the
<a href="elvisopt.html#SPELL">spelling options</a>.

<dl>

<dt><a name="words">wo[rds]</a><code>[</code>!<code>]</code>
	<code>[</code>+<code>|</code>-<code>]
	[</code><var>words...</var><code>]</code>
<dd>Adds words to the natural-language dictionary.
Words that follow a "-" flag will be added as *BAD* words; otherwise the
words are added as good words.

<p>When invoked without any arguments, it lists any words that you've added
with previous invocations of the <code>:words</code> command.

<p>If you use a "!" suffix on the command name, then the added words will
not be marked as though they were added via :words.  This is used mostly in
Elvis' initialization scripts.
Words added this way won't be listed by an argumentless <code>:words</code>
command, and won't be saved via the <a href="elvisopt.html#mkexrc">:mkexrc</a>
command.
<pre graphic>
    .------------.-------------------------------------------.
    | COMMAND    | WHAT IT DOES                              |
    |------------|-------------------------------------------|
    | :wo word   | Add word to personal dictionary as "good" |
    | :wo -word  | Add word to personal dictionary as "bad"  |
    | :wo! word  | Add word as "good", but not "personal"    |
    | :wo! -word | Add word as "bad" but not "personal"      |
    |            |   (This effectively removes the word from |
    |            |   the dictionary.)                        |
    ^------------^-------------------------------------------^</pre>
<p>Words given in lowercase will be assumed to be case-insensitive.
Words containing any uppercase letters will be case-sensitive.
Also, there's a minor bug involving case-sensitive words and the
<a href="elvisopt.html#spellsuffix">spellsuffix</a> option;
see the "Options" chapter for details.

<dt><a name="wordfile">wordf[ile]</a><code>[</code>!<code>]</code>
	<code>[</code><var>filename...</var><code>]</code>
<dd>Scan a text file for words, and add them to the natural-language
dictionary.
The text file shouldn't contain any markups such as HTML tags; it must be
a plain text file.
However, the words do not need to be sorted or formatted in any special way.
You can use the <a href="elvistip.html#wascii">:wascii</a> alias to generate
a plain text file from an HTML, man, or TeX source file.

<p>When invoked without any arguments, <code>:wordfile</code> loads the words
from the file indicated by the <a href="elvisopt.html#spelldict">spelldict</a>
option.
Doing this will take a noticeable amount of time, but it will allow the
<a href="elvisexp.html#spell">spell()</a> function to work better.

<p>When invoked with filenames as arguments, it scans those files for words
and adds them to your personal dictionary, so they'll be saved by the
<a href="#mkexrc">:mkexrc</a> command.
You can also add words temporarily by using <code>:wordfile!</code>
(with a ! suffix).

<dt><a name="check">che[ck]</a><code>[</code>!<code>]</code>
	<code>[</code>*<code>|</code>+<code>|</code>-<code>]
	[</code><var>faces...</var><code>]</code>
<dd>This command allows you to reduce the amount of spell-checking that is
performed on specific text faces.
The face names are the same ones the <a href="#color">:color</a> command uses.
By default, most faces are spell-checked; Elvis' default configuration
files (mostly <a href="elvisses.html#elvis.spe">elvis.spe</a>) reduce spell
checking for a few carefully-chosen faces.

<p>If invoked without any arguments, it will list any fonts that you've
changed with previous invocations of the <code>:check</code> command.

<p>If invoked with arguments, then the arguments should be a mixture of
flags and face names.
Each flag indicates which type of spell-checking is allowed on any text that
is drawn in the faces that follow it.
The flags are:

<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>*</strong> Check tags and natural-language words.
<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>+</strong> Check tags, but not natural-language words.
<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>-</strong> Don't check against either list.

<p>If you don't use any of those flags, then "+" is assumed.

<p>"tags" refers to the list of symbol names defined in a file named "tags",
in any directory named in the <a href="elvisopt.html#tags">tags</a> option.
For convenience, it also looks for "tags" in the directories listed in the
<a href="elvisopt.html#elvispath">elvispath</a> option; many people set up
a list of standard library functions there.

<p>"natural-language words" refers to the list of words maintained by the
<a href="#word">:words</a> command, or stored in an external file named via
the <a href="elvisopt.html#spelldict">spelldict</a> option.

<p>Some examples:
<pre graphic>
.-----------------------.----------------------------------------.
| COMMAND               | WHAT IT DOES                           |
|-----------------------|----------------------------------------|
| :che +variable        | enable tag-only checking for variables |
| :che variable         | same as ":check +variable"             |
| :che *string          | enable full checking for strings       |
| :che -variable string | turn off all checking for those fonts  |
^-----------------------^----------------------------------------^</pre>
<p>For example, the default configuration disables spell-checking on variable
names, since most tag-generator programs don't generate tags for all variables.
If you use a tag generator that does generate tags for all variables, then
you may want to enable checking against tags.  You still wouldn't want to
check variable names against natural-language words, though.
The command to enable this checking for variables is:
<pre>
	:check variable</pre>

<p>Strings aren't normally spell-checked, because strings often contain
quirky things like "\n" and "%d", which causes many false alarms.
However, if you want to enable natural-language checking for strings,
you can do it with this command:
<pre>
	:check *string</pre>

<p>Appending a "!" suffix to the command name will prevent the changed font
from being listed by a later, argumentless <code>:check</code> command, or
from being saved by a <a href="#mkexrc">:mkexrc</a> command.
Elvis' initialization scripts invoke it this way.

</dl>

<h2><a name="MISC">4.22 Miscellaneous</a></h2>
<pre graphic>.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#QUOTE">&quot;</a>                 | text                              |
|       | <a href="#cd">cd</a>[!]             | [directory]                       |
|       | <a href="#chdir">chd[ir]</a>[!]        | [directory]                       |
|       | <a href="#echo">ec[ho]</a>            | text                              |
|       | <a href="#message">me[ssage]</a>         | text                              |
|       | <a href="#warning">wa[rning]</a>         | text                              |
|       | <a href="#error">erro[r]</a>           | text                              |
| range | <a href="#normal">norm[al]</a>[!]       | [keystrokes]                      |
|       | <a href="#shell">sh[ell]</a>           |                                   |
|       | <a href="#stop">st[op]</a>[!]         |                                   |
|       | <a href="#suspend">sus[pend]</a>[!]      |                                   |
|       | <a href="#version">ve[rsion]</a>         |                                   |
| line  | <a href="#goto">go[to]</a>            |                                   |
| line  | <a href="#mark">ma[rk]</a>            | mark                              |
| line  | <a href="#k">k</a>                 | mark                              |
|       | <a href="#OCUR">{</a>                 |                                   |
^-------^-------------------^-----------------------------------^
</pre>

<dl>

<dt><a name="QUOTE">&quot;</a> <var>text</var>
<dd>
The <code>:&quot;</code> command causes the remainder of the line to be ignored.
It is used for inserting comments into ex scripts.

<dt><a name="cd">cd</a><code>[</code>!<code>]</code> <code>[</code><var>directory</var><code>]</code>
<br><a name="chdir">chd[ir]</a><code>[</code>!<code>]</code> <code>[</code><var>directory</var><code>]</code>
<dd>The <code>:cd</code> and <code>:chdir</code> commands are identical.
They both change the current working directory for Elvis and all its windows.
If you don't specify a new directory name then Elvis will switch to your
home directory.

<dt><a name="echo">ec[ho]</a> <var>text</var>
<dd>
The <code>:echo</code> command displays its arguments as a message.
This may be useful in ex scripts.

<dt><a name="message">me[ssage]</a> <var>text</var>
<br><a name="warning">wa[rning]</a> <var>text</var>
<br><a name="error">erro[r]</a> <var>text</var>
<dd>The <code>:message</code>, <code>:warning</code>, and <code>:error</code> commands
all output their arguments as a message.
The command name indicates the importance of the message.
This is differs from <code>:echo</code> as follows: the messages are
translated via the <a href="elvismsg.html#elvis.msg">elvis.msg</a> file,
then evaluated using the <a href="elvisexp.html#SIMPLER">simpler syntax</a>,
and finally stuffed into the message queue.
The message queue collects all messages, and outputs them immediately before
waiting for the next keystroke.
Also, the <code>:error</code> command has the side-effect of terminating any
macros, aliases, or scripts.

<p>When used inside an <a href="#autocmd">autocmd</a>, error and warning
messages are normally hidden.
To enable them in an <code>autocmd</code>, you should turn on the
<a href="elvisopt.html#eventerrors">eventerrors</a> option.

<p>When used inside a <a href="#try">try</a> command, errors and warnings
are always hidden.

<dt><var>range</var> <a name="normal">norm[al]</a><code>[</code>!<code>] [</code><var>keystrokes</var><code>]</code>
<dd>
The <code>:normal</code> command does two totally separate things.
When invoked without any parameters, it switches to the <a href="elvisdm.html#normal">normal display mode</a>.

<p>
When <code>:normal</code> is invoked with parameter text, though, it leaves
the display mode unchanged and interprets the characters of the text as though
they were vi commands.
If no addresses were given, then those commands are executed once, without
moving the cursor initially;
if an address or range of addresses were given, then it moves the cursor to
the first character of each line and repeats the vi command keys there.

<p>
The "!" suffix has no effect in Elvis.
In vim, it would prevent <a href="#map">maps</a> from being applied to the
simulated keystrokes, but Elvis never applies maps to <code>:normal</code>
keystrokes.
<dt><a name="shell">sh[ell]</a>
<dd>
The <code>:shell</code> command starts up an interactive shell
(command-line interpreter).
Elvis will be suspended while the shell executes.
(Exception: the "x11" GUI runs the shell in a separate xterm window.
Then Elvis and the shell can then run simultaneously.)

<dt><a name="stop">st[op]</a><code>[</code>!<code>]</code>
<br><a name="suspend">sus[pend]</a><code>[</code>!<code>]</code>
<dd>The <code>:stop</code> and <code>:suspend</code> commands are identical to each other.
If the operating system and user interface support it, they will suspend
Elvis and resume the shell that started Elvis.
(This is like hitting <kbd>^Z</kbd> on many UNIX systems.)
If the OS or GUI don't support it, then Elvis will generally treat these
commands as synonyms for the <code>:shell</code> command.

<dt><a name="version">ve[rsion]</a>
<dd>
The <code>:version</code> command identifies this version number of Elvis,
and displays credits.

<dt><var>line</var> <a name="goto">go[to]</a>
<dd>The <code>:goto</code> moves the cursor to the addressed line.

<p>If you give an address without any ex command, then Elvis will assume
you want to use the <code>:goto</code> command.

<dt><var>line</var> <a name="mark">ma[rk]</a> <var>mark</var>
<br><var>line</var> <a name="k">k</a> <var>mark</var>
<dd>The <code>:mark</code> and <code>:k</code> commands are identical to each other.
They set a named mark to equal the addressed line, or the current line if
no address was given.

<dt><a name="OCUR">{</a> <var>commands</var> }
<dd>The <code>{ commands }</code> notation isn't really a command;
it is a feature of Elvis' syntax which allows you to pass several command lines
to a command which normally expects a single command line as its argument.
It is supported by the
<a href="#global">:global</a>, <a href="#vglobal">:vglobal</a>,
<a href="#all">:all</a>, <a href="#then">:then</a>, <a href="#else">:else</a>,
<a href="#alias">:alias</a>, and <a href="#autocmd">:autocmd</a> commands.
Instead of placing the argument command at the end of one of those command
lines, you can place a single '{' character there.
That should be followed by one or more command lines, and terminated
by a '}' on a line by itself.

</dl>

<h2><a name="INDEX">4.23 Alphabetical list of ex commands</a></h2>

<pre graphic>
.-------.-------------------.-----------------------------------.
|ADDRESS| COMMAND           | ARGUMENTS                         |
|-------|-------------------|-----------------------------------|
|       | <a href="#abbreviate">ab[breviate]</a>[!]   | [lhs rhs]                         |
|       | <a href="#alias">al[ias]</a>           | [name [excmds]]                   |
|       | <a href="#all">al[l]</a>[!]          | excmds                            |
| line  | <a href="#append">a[ppend]</a>[!]       | [text]                            |
|       | <a href="#args">ar[gs]</a>            | [file...]                         |
|       | <a href="#augroup">aug[roup]</a>[!]      | [group]                           |
|       | <a href="#autocmd">au[tocmd]</a>[!]      | [group] [events [file [excmd]]]   |
|       | <a href="#bbrowse">bb[rowse]</a>         |                                   |
|       | <a href="#break">bre[ak]</a>[!]        | [flags] lhs                       |
|       | <a href="#browse">br[owse]</a>[!]       | restrictions                      |
|       | <a href="#buffer">b[uffer]</a>[!]       | [buffer]                          |
|       | <a href="#calculate">ca[lculate]</a>       | expr                              |
|       | <a href="#case">cas[e]</a>            | value [excmds]                    |
|       | <a href="#cc">cc</a>[!]             | [args]                            |
|       | <a href="#cd">cd</a>[!]             | [directory]                       |
| range | <a href="#change">c[hange]</a>[!]       | [count] [text]                    |
|       | <a href="#chdir">chd[ir]</a>[!]        | [directory]                       |
|       | <a href="#check">che[ck]</a>[!]        | [* | + | -] faces...              |
| range | <a href="#chregion">chr[egion]</a>        | face newface [newcomment]         |
|       | <a href="#close">cl[ose]</a>[!]        |                                   |
|       | <a href="#color">col[or]</a>           | [face [attributes]]               |
| range | <a href="#copy">co[py]</a>            | line                              |
|       | <a href="#default">def[ault]</a>         | excmds                            |
| range | <a href="#delete">d[elete]</a>          | [cutbuf] [count]                  |
|       | <a href="#digraph">dig[raph]</a>[!]      | [lhs [rhs]]                       |
|       | <a href="#display">di[splay]</a>         | [modename [language]]             |
|       | <a href="#doloop">do[loop]</a>          | excmds                            |
|       | <a href="#echo">ec[ho]</a>            | text                              |
|       | <a href="#edit">e[dit]</a>[!]         | [+line] [file]                    |
|       | <a href="#else">el[se]</a>            | excmds                            |
|       | <a href="#errlist">er[rlist]</a>[!]      | [file]                            |
|       | <a href="#error">erro[r]</a>           | text                              |
|       | <a href="#eval">ev[al]</a>            | expr                              |
|       | <a href="#ex">ex</a>[!]             | [+line] [file]                    |
|       | <a href="#file">f[ile]</a>            | [file]                            |
| range | <a href="#fold">fo[ld]</a>[!]         | [name]                            |
|       | <a href="#foreach">for[each]</a>         | option ["in"] expression          |
| range | <a href="#global">g[lobal]</a>[!]       | /regexp/ excmds                   |
| line  | <a href="#goto">go[to]</a>            |                                   |
|       | <a href="#gui">gu[i]</a>             | text                              |
|       | <a href="#help">h[elp]</a>            | topic                             |
|       | <a href="#if">if</a>                | expr                              |
| line  | <a href="#insert">i[nsert]</a>[!]       | [text]                            |
| range | <a href="#join">j[oin]</a>[!]         |                                   |
| line  | <a href="#k">k</a>                 | mark                              |
|       | <a href="#last">la[st]</a>            |                                   |
|       | <a href="#let">le[t]</a>[!]          | option=expr                       |
| range | <a href="#list">l[ist]</a>            | [count]                           |
|       | <a href="#local">lo[cal]</a>           | [option=value | option ]          |
| range | <a href="#lpr">lp[r]</a>[!]          | [ file | &gt;&gt;file | !shellcmd ]     |
|       | <a href="#make">mak[e]</a>[!]         | [args]                            |
|       | <a href="#map">map</a>[!]            | [flags] [lhs [flags] rhs]         |
| line  | <a href="#mark">ma[rk]</a>            | mark                              |
|       | <a href="#message">me[ssage]</a>         | text                              |
|       | <a href="#mkexrc">mk[exrc]</a>[!]       | [file]                            |
| range | <a href="#move">m[ove]</a>            | line                              |
|       | <a href="#new">new</a>               |                                   |
|       | <a href="#next">n[ext]</a>[!]         | [file...]                         |
|       | <a href="#Next">N[ext]</a>[!]         |                                   |
|       | <a href="#nohlsearch">noh[lsearch]</a>      |                                   |
| range | <a href="#normal">norm[al]</a>[!]       | keystrokes                        |
| range | <a href="#number">nu[mber]</a>          | [count]                           |
|       | <a href="#only">on[ly]</a>            |                                   |
|       | <a href="#open">o[pen]</a>[!]         | [+line] [file]                    |
|       | <a href="#pop">po[p]</a>[!]          |                                   |
|       | <a href="#preserve">pres[erve]</a>        |                                   |
|       | <a href="#previous">pre[vious]</a>[!]     |                                   |
| range | <a href="#print">p[rint]</a>           | [count]                           |
|       | <a href="#push">pus[h]</a>[!]         | [+line] [file]                    |
| line  | <a href="#put">pu[t]</a>             | [cutbuf]                          |
|       | <a href="#qall">qa[ll]</a>[!]         |                                   |
|       | <a href="#quit">q[uit]</a>[!]         |                                   |
| line  | <a href="#read">r[ead]</a>            | file | !shellcmd                  |
|       | <a href="#redo">red[o]</a>            | [count]                           |
| range | <a href="#region">reg[ion]</a>          | [face [comment]]                  |
|       | <a href="#rewind">rew[ind]</a>[!]       |                                   |
|       | <a href="#sNext">sN[ext]</a>           |                                   |
|       | <a href="#safely">safel[y]</a>[!        | excmds                            |
|       | <a href="#sall">sa[ll]</a>            |                                   |
|       | <a href="#sbbrowse">sbb[rowse]</a>        |                                   |
|       | <a href="#sbrowse">sb[rowse]</a>         | restrictions                      |
|       | <a href="#set">se[t]</a>[!]          | [option=value | option? | all]    |
|       | <a href="#shell">sh[ell]</a>           |                                   |
|       | <a href="#slast">sl[ast]</a>           |                                   |
|       | <a href="#snew">sne[w]</a>            |                                   |
|       | <a href="#snext">sn[ext]</a>           | [file...]                         |
|       | <a href="#source">so[urce]</a>[!]       | file                              |
|       | <a href="#split">sp[lit]</a>           | [+line] [file | !shellcmd]        |
|       | <a href="#srewind">sre[wind]</a>[!]      |                                   |
|       | <a href="#stack">stac[k]</a>           |                                   |
|       | <a href="#stag">sta[g]</a>            | [tag]                             |
|       | <a href="#stop">st[op]</a>[!]         |                                   |
| range | <a href="#substitute">s[ubstitute]</a>      | /regexp/newtext/[g][p][x][count]  |
|       | <a href="#suspend">sus[pend]</a>[!]      |                                   |
|       | <a href="#switch">sw[itch]</a>          | expr                              |
|       | <a href="#tag">ta[g]</a>[!]          | [tag]                             |
|       | <a href="#then">th[en]</a>            | excmds                            |
| range | <a href="#to">t[o]</a>              | line                              |
|       | <a href="#try">try</a>               | excmds                            |
|       | <a href="#unabbreviate">una[bbreviate]</a>[!] | lhs                               |
|       | <a href="#unalias">unal[ias]</a>[!]      | name                              |
|       | <a href="#unbreak">unb[reak]</a>[!]      | [flags] lhs                       |
|       | <a href="#undo">u[ndo]</a>            | [count]                           |
| range | <a href="#unfold">unf[old]</a>[!]       | [name]                            |
|       | <a href="#unmap">unm[ap]</a>[!]        | [flags] lhs                       |
| range | <a href="#unregion">unr[egion]</a>        | [face]                            |
|       | <a href="#version">ve[rsion]</a>         |                                   |
| range | <a href="#vglobal">v[global]</a>[!]      | /regexp/ excmds                   |
|       | <a href="#visual">vi[sual]</a>[!]       | [+line] [file]                    |
|       | <a href="#warning">wa[rning]</a>         | text                              |
|       | <a href="#while">wh[ile]</a>           | expr                              |
|       | <a href="#window">wi[ndow]</a>          | [+ | - | number | buffer ]        |
|       | <a href="#wnext">wn[ext]</a>[!]        |                                   |
|       | <a href="#wordfile">wordf[ile]</a>[!]     | [filename...]                     |
|       | <a href="#words">wo[rds]</a>[!]        | [+ | -] words...                  |
|       | <a href="#wquit">wq[uit]</a>[!]        | [file]                            |
| range | <a href="#write">w[rite]</a>[!]        | [file | &gt;&gt;file | !shellcmd]       |
|       | <a href="#xit">x[it]</a>[!]          | [file]                            |
| range | <a href="#yank">y[ank]</a>            | [cutbuf] [count]                  |
| line  | <a href="#z">z</a>                 | [spec]                            |
| range | <a href="#BANG">!</a>                 | shellcmd                          |
|       | <a href="#QUOTE">&quot;</a>                 | text                              |
| range | <a href="#HASH">#</a>                 | [count]                           |
| range | <a href="#AMP">&amp;</a>                 |                                   |
|       | <a href="#OPEN">(</a>                 | buffer                            |
| range | <a href="#LT">&lt;</a>                 |                                   |
| range | <a href="#EQ">=</a>                 |                                   |
| range | <a href="#GT">&gt;</a>                 |                                   |
|       | <a href="#AT">@</a>                 | cutbuf                            |
|       | <a href="#OCUR">{</a>                 |                                   |
| range | <a href="#TILDE">~</a>                 |                                   |
^-------^-------------------^-----------------------------------^

</pre>

</body></html>
