
核启动弄相关动作重要的结构体cpuhp_hp_states[]:
1、bringup时从CPUHP_OFFLINE-->CPUHP_BRINGUP_CPU执行相关puhp_hp_states->startup.single回调
2、核唤醒后运行secondary_start_kernel()->notify_cpu_starting(),会从CPUHP_BRINGUP_CPU-->CPUHP_AP_ONLINE执行相关的puhp_hp_states->startup.single回调

==========================================================================================================


	cpus {
		#address-cells = <0x1>;
		#size-cells = <0x0>;

		cpu@0 {
			compatible = "arm,cortex-a53";
			device_type = "cpu";
			reg = <0x0>;
			enable-method = "psci";
		};

		cpu@1 {
			compatible = "arm,cortex-a53";
			device_type = "cpu";
			reg = <0x1>;
			enable-method = "psci";
		};
		...
	};

	psci {
		compatible = "arm,psci-0.2";
		method = "smc";
	};



==========================================================================================================
ATF

sync_exception_aarch64																					//所有BL31操作都从这里开始，arm-trusted-firmware-master\bl31\aarch64\bl31_entrypoint.S
	_exception_vectors=runtime_exceptions																//这是el3中断向量，arm-trusted-firmware-master\bl31\aarch64\runtime_exceptions.S
		sync_exception_aarch64																			//低异常进入高异常
			sync_exception_aarch64
				smc_handler64
					...																					//从rt_svc_descs段中找到std_svc_smc_handler所在的位置
					blr	std_svc_smc_handler
						psci_smc_handler(smc_fid, x1, x2, x3, x4, cookie, handle, flags)				//根据function id处理各种服务
					
							psci_cpu_on()																//开核
								 psci_plat_pm_ops->pwr_domain_on(target_cpu)
									sunxi_pwr_domain_on(target_cpu)										//arm-trusted-firmware-master\plat\allwinner\common\sunxi_scpi_pm.c

==========================================================================================================
linux

start_kernel
	setup_arch																							// arch/arm64/kernel/setup.c
		psci_dt_init
			np = of_find_matching_node_and_match()														//根据psci节点的compatible找到对应of_device_id结构体
			psci_0_2_init(np);
				get_set_conduit_method(np)																//根据method属性设置invoke_psci_fn = __invoke_psci_fn_smc，进入smc是调用的函数
				psci_probe()
					psci_get_version()																	//获取psc固件版本
					psci_0_2_set_functions()															//填充提供给上层关于psci相关设置的接口如cpu on/off，suspend等
						psci_function_id[PSCI_FN_CPU_ON] = PSCI_FN_NATIVE(0_2, CPU_ON);
						psci_ops.cpu_on = psci_cpu_on;

	arch_call_rest_init
		rest_init
			kernel_init
				kernel_init_freeable
					smp_init()
						idle_threads_init()																//为当前cpu初始化idle线程
						cpuhp_threads_init()															//为当前cpu创建热拔插线程cpuhp/%u
						...
						for_each_present_cpu(cpu)
							if (!cpu_online(cpu))
								cpu_up(cpu)
									do_cpu_up(cpu, CPUHP_ONLINE)
										try_online_node(cpu_to_node(cpu))
										_cpu_up(cpu, 0, CPUHP_ONLINE)
										cpuhp_up_callbacks(cpu, st, CPUHP_BRINGUP_CPU)
											cpuhp_invoke_callback(cpu, st->state, true, NULL, NULL)		//先创建绑定该核的内核线程(如ksoftirqd)在bringup核
												bringup_cpu(cpu)==>(cpuhp_hp_states + CPUHP_BRINGUP_CPU)
													__cpu_up(cpu, idle)									//arch/arm64/kernel/smp.c
														boot_secondary(cpu, idle)
															cpu_psci_cpu_boot(cpu) ==> cpu_psci_ops.cpu_boot(cpu) ==> cpu_ops[cpu]->cpu_boot(cpu)
															psci_cpu_on(cpu_logical_map(cpu), __pa_symbol(secondary_entry)) ==> psci_ops.cpu_on(cpu_logical_map(cpu), __pa_symbol(secondary_entry))
																__invoke_psci_fn_smc(PSCI_0_2_FN_CPU_ON, cpu, secondary_entry, 0, 0, 0, 0, &res)
													...
													wait_for_completion_timeout(&cpu_running, msecs_to_jiffies(1000))		//CPU was successfully started, wait for it to come online or time out.
					...
					smp_cpus_done(setup_max_cpus)
						setup_cpu_features()															//CPU特性检测
						hyp_mode_check()																//确定从哪个异常级别启动





secondary_entry																							//arch\arm64\kernel\head.S
	el2_setup																							//el2降到el1
	secondary_startup
		__secondary_switched
			secondary_start_kernel
			...
			cpuinfo_store_cpu()																			//记录CPU信息
				__cpuinfo_store_cpu(info)
					cpuinfo_detect_icache_policy(info)
						pr_info("Detected %s I-cache on CPU%d\n", icache_policy_str[l1ip], cpu)
			...																							//从汇编到C一系列的CPU初始化：使能MMU，设置异常向量表，设置栈，使能中断、timer等
			notify_cpu_starting(cpu)																	//Enable GIC and timers
				cpuhp_invoke_callback(cpu, st->state, true, NULL, NULL)									//调用cpuhp_hp_states结构体中注册的回调函数初始化各模块如GIC and timers
			...
			pr_info("CPU%u: Booted secondary processor 0x%010lx [0x%08x]\n", cpu, (unsigned long)mpidr, read_cpuid_id())
			...
			complete(&cpu_running); 																	//唤醒主处理器的 完成等待函数，继续启动下一个从处理器
			cpu_startup_entry(CPUHP_AP_ONLINE_IDLE); 													//ｉｄｌｅ进程进入ｉｄｌｅ状态



硬中断初始化：
cpuhp_setup_state_nocalls(CPUHP_AP_IRQ_GIC_STARTING, "irqchip/arm/gic:starting", gic_starting_cpu, NULL)
软中断线程创建：
smpboot_register_percpu_thread(&softirq_threads)
timer处理函数注册：
cpuhp_setup_state(CPUHP_AP_ARM_ARCH_TIMER_STARTING, "clockevents/arm/arch_timer:starting", arch_timer_starting_cpu, arch_timer_dying_cpu)
