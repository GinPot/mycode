参考99.On_O1_CFS_prio.txt

O(n)调度器：
	1、需要遍历系统中runqueue链表的进程数；在调度周期结束后，有需要为所有进程的时间片进行充值动作；
	2、O(n)调度器通过一个链表管理系统所有等待调度进程，在smp系统中，访问链表需要上锁的同步机制来保证cpu对链表的串行访问，在多核场景下锁的开销将成为性能瓶颈；
	3、当runqueue链表进程耗尽时间片时，需要为所有进程时间片重新计算充值浪费CPU资源，且该操作会干掉CPU全部的L1cache，导致充值时间片后运行线程的cache命中率降低，导致CPU空转；
		3.1、只有runqueue链表上最后一个进程时间片用完了才会重新充值，smp系统中，可能多核都处于idle状态等待最后一个进程消耗完时间片，cpu资源严重浪费；
	4、时间片充值完后随着进程时间片耗尽，CPU可选择运行的进程不断减少，可能存在本来在cpu0上运行的进程被调度到其他cpu上运行，导致cache命中率降低而影响性能；
	5、实时进程和普通进程都在同一个链表上，运行实时进程时还需要遍历普通进程；且只有在返回用户空间时才会启动调度及优先级翻转问题，导致实时进程即便runnable状态了也不能及时运行
	6、交互式普通进程的调度延迟问题：如磁盘服务的IO行进程，主要在后等待disk io操作，导致经常睡眠，调度器会奖励经常睡眠的进程，但提高动态优先级对磁盘服务没有多大意义；
	7、runqueue链表变大导致整个调度周期的时间变长，导致一个进程在耗尽时间片后只能长时间等待下个调度周期

O(1)调度器：
	1、引入per-cpu runqueue链表，系统中将可运行的进程先经过负载均衡模块分给各个cpu的runqueue，删除全局lock，在per-cpu链表中加入小的lock；来降低调度延迟，提升系统响应，解决smp扩展性和cpu空转问题
	2、在per-cpu runqueue链表基础上又根据每种优先级创建一个链表：支持140个优先级，因此queue成员中有140个分别表示各个优先级的链表头；100～139是普通进程的优先级，其他的是实时进程的优先级。因此，在O（1）调度器中，RT进程和普通进程被区分开了，普通进程根本不会影响RT进程的调度
		2.1、因为有优先级列表，所以按照优先级连接找到第一个非空的链表即最合适的下一个调度进程，不需要遍历整个链表了；
	3、有两组优先级类别分别管理active(有剩余时间片的)和expired(时间片耗尽的)，随着系统运行active的进程时间片耗尽就切换到到expired队列中开始新的调度；
		3.1、进程在时间片消耗完后即重置时间片并从active链表中移除，设置resched标记；

CFS：
	1、模块化设计思想：
		1.1、软件分成了两个层次，一个是core scheduler layer(各种调度器共同的逻辑)，另外一个是specific scheduler layer(具体哪种调度器RT scheduler、CFS sheduler)；
		1.2、功能层面仍然分成两个部分，第一个部分是通过负载均衡模块将各个runnable task根据负载情况平均分配到各个CPU runqueue上去，第二部分的功能是在各个CPU的Main scheduler和Tick scheduler的驱动下进行单个CPU上的调度
	2、关于公平：
		进程静态优先级映射成进程权重：进程应该占有cpu资源的比重；如统中有3个runnable thread A、B和C，权重分别是a、b、c，那么A thread应该分配到的CPU资源是a/(a+b+c)
	3、时间粒度：
		CFS调度器的时间片是动态变化的(CPU的可运行状态的进程以及它们的优先级相关)(之前的调度器时间片是固定的)；在一个调度周期内，CFS调度器可以保证所有的可运行状态的进程平均分配CPU时间
	4、调度延迟：
		1、之前的调度延迟因为给进程分配固定时间片，进程越多，运行完A后下次运行A的延迟越长(运行完所有进程才会重新充值)；
		2、cfs在进程小于8个时用固定时间延迟sysctl_sched_latency（6ms）,大于8时用runnable进程数目乘以sysctl_sched_min_granularity（0.75ms）(没看出为啥这就能保证有界的调度延迟)
	5、虚拟时间：
		Vruntime=Pruntime(物理运行时间)/right(权重，即nice值)*1024(系数)
		红黑树的目的是希望所有进程虚拟时间相等，因为权重nice值不同，将会导致物理运行时间不同；
	6、如何计算虚拟时间：
		物理运行时间即：该进程实际执行时间(取出了异步中断的时间)，然后再根据上面公式计算；




==============================================================================================================================

用户空间视角：
	实时进程(scheduling priority)：1（优先级最低）～99（优先级最高）,普通进程也有scheduling priority，一般被设为0
	普通进程：100（优先级最高）～139（优先级最低），分别对应nice value的-20 ～ 19

===================

内核空间实现：
struct task_struct {
	...
	int				prio;
	int				static_prio;
	int				normal_prio;
	unsigned int	rt_priority;
	...
	unsigned int	policy;
	...
}

int prio;
	动态优先级：运行是可以被修改的，调度器在调度时也是使用这个；

int static_prio, 静态优先级;
	1、值越小，进程优先级越高；
	2、0~99用于RT进程(没有实际意义)，100~139用于普通进程；
	3、默认值为120，nice为0；
	4、用户空间可以通过nice()或者setpriority对该值进行修改。通过getpriority可以获取该值
	5、新创建的进程会继承父进程的static_prio；

int normal_prio;
	归一化优先级：根据静态优先级、scheduling priority和调度策略来计算得到(将多个参数转换成一个参数来比较)，值越小优先级越高；
	deadline进程的normal_prio=-1; RT线程(99-rt_priority)0（优先级最高）～99（优先级最低）; 普通进程(static_prio)100~139用于普通进程

unsigned int rt_priority, 实时优先级;
	也就是用户空间视角的scheduling priority,1（优先级最低）～99（优先级最高,99没有意义？）,普通进程被设置为0

unsigned int policy
	记录该线程的调度策略；




		内核					chrt/nice命令设置				TOP
(0~99，值越小优先级越大)					
		0						RT99						RT
		49						RT50						-51(-1-50)
		99						RT0							-1 (-1-0)

		100						NIC-20						0  (20+(-20))
		120						NIC0						20 (20+0)
		139						NIC19						39 (20+19)

==============================================================================================================================
dl_sched_class			deadline调度器			SCHED_DEADLINE
rt_sched_class			实时调度器				SCHED_FIFO、SCHED_RR
fair_sched_class		完全公平调度器			SCHED_NORMAL、SCHED_BATCH
idle_sched_class		idle task				SCHED_IDLE

RT调度器：
	1、最高优先级的任务将最先获得CPU资源
	2、两个任务具有相同优先级：
		2.1、FIFO调度器，最先进入runnable状态的任务将首先获取CPU资源，并且一直占用该资源，直到该进程进入睡眠状态；
		2.2、RR调度器，具有相同优先级的任务将以轮流执行的方式共享处理器资源。当某个RR任务开始运行后，如果该任务不会阻塞，那么它将一直运行，直到分配给该任务的时间片到期。当时间片用完，调度器将把该任务放在任务链表的末端（注意，只有相同优先级的任务才会放到一个链表中，不同优先级在不同的链表中），并从任务链表中选择下一个任务去执行
	
	chrt -f 10 video_processing_tool
		video_processing_tool任务会归于RT调度器管理，其实时优先级是10，调度策略是FIFO（-f参数）


deadline调度器：选择其Deadline距离当前时间点最近的那个任务并调度它执行
	1、优先级高于RT调度器；
	2、它需要三个元素：周期（period），运行时间（runtime）和最后期限（deadline）

	优点：
		1、可以调度多DL任务在固定周期、deadline内完成任务；而RT任务可能存在超时情况；
		
	缺点：
		1、不能保存每个任务的最小响应时间，RT可以

	chrt -d --sched-runtime 5000000 --sched-deadline 10000000 --sched-period 16666666 0 video_processing_tool
		其中“-d”参数说明设定的调度策略是deadline，“--sched-runtime 5000000”是将运行时间参数设定为5ms，“--sched-deadline 10000000”是将deadline设定为10ms，“--sched-period 16666666”则是设定周期参数。命令行中的“0”是优先级占位符，DL调度器并不使用优先级参数




=========================================================================================================================


Stop调度器：			优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占；
Deadline调度器：		使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行；
RT调度器：			为每个优先级维护一个队列；
CFS调度器：			采用完全公平调度算法，引入虚拟运行时间概念；
IDLE-Task调度器：		每个CPU都会有一个idle线程，当没有其他进程可以调度时，调度运行idle线程；


SCHED_DEADLINE：		使task选择Deadline调度器来调度运行
SCHED_RR：			时间片轮转，进程用完时间片后加入优先级对应运行队列的尾部，把CPU让给同优先级的其他进程；
SCHED_FIFO：			先进先出调度没有时间片，没有更高优先级的情况下，只能等待主动让出CPU；
SCHED_NORMAL：		使task选择CFS调度器来调度运行；
SCHED_BATCH：		批量处理，使task选择CFS调度器来调度运行；
SCHED_IDLE：			使task以最低优先级选择CFS调度器来调度运行

