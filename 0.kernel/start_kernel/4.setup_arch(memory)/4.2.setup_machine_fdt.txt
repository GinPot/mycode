
1、dtb load的物理地址要求8字节对齐，并且大小小于2M；映射时和head.s一样只需要3级查表：
	1.1、init_mm.pgd+FIX_FDT[47:40]得到保存PUD基地址的虚拟地址；
	1.2、PUD基地址+FIX_FDT[39:32]得到保存PMD基地址的虚拟地址；
	1.3、PMD基地址+FIX_FDT[31:24]得到保存设备树物理地址的虚拟地址；
	1.4、设备树物理地址或上地址属性保存到1.3中的虚拟地址中完成映射；

2、将设备树对应的物理地址设置为memblock reserve

3、获取dtb的ramdisk信息、bootargs参数、#address/size-cells大小、memory节点信息,并把memory的信息添加到memblock.memory中

4、initial_boot_params	保存设备树的全局变量的虚拟地址

=====================================================================================================

memblock结构体静态定义好了一些数据


INIT_MEMBLOCK_REGIONS = 128  
INIT_MEMBLOCK_RESERVED_REGIONS = 385
static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_RESERVED_REGIONS] __initdata_memblock;

struct memblock memblock __initdata_memblock = {
	
	struct memblock_type memory{
		.regions	= memblock_memory_init_regions,
		.cnt		= 1,	/* empty dummy entry */
		.max		= INIT_MEMBLOCK_REGIONS,
		.name		= "memory",
	}

	struct memblock_type reserved{
		.regions	= memblock_reserved_init_regions,
		.cnt		= 1,	/* empty dummy entry */
		.max		= INIT_MEMBLOCK_RESERVED_REGIONS,
		.name		= "reserved",
	}

	.bottom_up		= false,
	.current_limit	= MEMBLOCK_ALLOC_ANYWHERE,
};

cat /sys/kernel/debug/memblock


=====================================================================================================

#define SWAPPER_TABLE_SHIFT	30
#define SWAPPER_BLOCK_SIZE	2MB

#define PMD_SHIFT       21
#define SECTION_SHIFT		PMD_SHIFT
#define SECTION_SIZE		(_AC(1, UL) << SECTION_SHIFT)
#define SWAPPER_BLOCK_SIZE	SECTION_SIZE

#define SECTION_MASK		(~(SECTION_SIZE-1))

#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)						//可以理解为：#define round_up(x, y) ，大于等x并接近x的可以整除y的那个数
#define round_down(x, y) ((x) & ~__round_mask(x, y))							//可以理解为：#define round_down(x, y) ((x/y) * y)	小于等x并接近x的可以整除y的那个数include\linux\kernel.h
					

#define pgd_offset_raw(pgd, addr)	((pgd) + pgd_index(addr))					//获取


#define PGDIR_SIZE		(_AC(1, UL) << PGDIR_SHIFT)								// 1 << 39
#define PGDIR_MASK		(~(PGDIR_SIZE-1))										// ~((1 << 39) - 1)
#define pgd_addr_end(addr, end)						\
({	unsigned long __boundary = ((addr) + PGDIR_SIZE) & PGDIR_MASK;	\			//只取bit[39:63]的数据，其他bit清零
	(__boundary - 1 < (end) - 1)? __boundary: (end);		\
})



#define pud_offset_phys(dir, addr)	(pgd_page_paddr( (*(dir))) + pud_index(addr) * sizeof(pud_t))	//从ffff0000117f2000(pgd) + virt(bit[39:47])*8(entry)虚拟地址中，得到基于pud的物理地址加上entry偏移*8字节得到最终保留下一级查边pmd物理地址的物理地址

#define __set_fixmap_offset(idx, phys, flags)				\
({									\
	unsigned long ________addr;					\
	__set_fixmap(idx, phys, flags);					\
	________addr = fix_to_virt(idx) + ((phys) & (PAGE_SIZE - 1));	\
	________addr;							\
})
#define set_fixmap_offset(idx, phys) __set_fixmap_offset(idx, phys, FIXMAP_PAGE_NORMAL)				//FIX_PUD的虚拟地址，加上(pud的物理地址加上entry偏移*8字节)的bit[0:11]位的数据，最终得到(pud的物理地址加上entry偏移*8字节)对应的虚拟地址
#define pud_set_fixmap(addr)		((pud_t *)set_fixmap_offset(FIX_PUD, addr))
#define pud_set_fixmap_offset(pgd, addr)	pud_set_fixmap(pud_offset_phys(pgd, addr))

=====================================================================================================

#define PHYS_PFN(x)				((unsigned long)((x) >> PAGE_SHIFT))
#define	__phys_to_pfn(paddr)	PHYS_PFN(paddr)


=====================================================================================================

CONFIG_NODES_SHIFT=2
#define NODES_SHIFT     CONFIG_NODES_SHIFT
#define MAX_NUMNODES    (1 << NODES_SHIFT)	100


pgd + pud + pmd + pte + offset

dtb的物理地址： 0x7bf25000


setup_machine_fdt()
	void *dt_virt = fixmap_remap_fdt(dt_phys);
		dt_virt = __fixmap_remap_fdt(dt_phys, &size, PAGE_KERNEL_RO);
			dt_virt_base = __fix_to_virt(FIX_FDT);								//取fix_fdt的虚拟地址
			...																	//检测fdt的物理地址是否存在，是否8字节对齐
			...																	//检测虚拟地址是否2M对齐
			...																	//检测FIX_FDT_END和FIX_BTMAP_BEGIN的虚拟地址bit[63:31]是相同的
			offset = dt_phys % SWAPPER_BLOCK_SIZE;								// 888 取物理地址的bit[20:0]数据, 这里的offset也等于round_down(dt_phys, SWAPPER_BLOCK_SIZE)向下偏移的offset
			dt_virt = (void *)dt_virt_base + offset;							//虚拟地址+物理地址的bit[20:0]，因上面原因，所以dt_virt_base实际虚拟地址和round_down(dt_phys, SWAPPER_BLOCK_SIZE)对应，dt_virt_base+offset和dt_phys对应
			create_mapping_noalloc(round_down(dt_phys, SWAPPER_BLOCK_SIZE), dt_virt_base, SWAPPER_BLOCK_SIZE, PAGE_KERNEL_RO);			//这里dtb物理地址用了 round_down，使得映射的虚拟地址包含了，实际的虚拟地址也要加上上面计算出来的offset;	round_down(dt_phys(0x7bf25000), SWAPPER_BLOCK_SIZE)=0x7be00000
				__create_pgd_mapping(init_mm.pgd, phys, virt, size, prot, NULL, NO_CONT_MAPPINGS);
					pgd_t *pgdp = pgd_offset_raw(pgdir, virt);					//init_pg_dir(head.s配置的页表)虚拟地址,实际ffff0000117f2000(pgd) + virt(bit[39:47])*8,(因为前面是64位地址加index)
					...
					phys &= PAGE_MASK;											//dtb的物理地址bit[0:11]清零， 低位最后会用来存放权限相关的属性 888
					addr = virt & PAGE_MASK;									//要映射的虚拟地址bit[0:11]清零
					length = PAGE_ALIGN(size + (virt & ~PAGE_MASK));			//要映射虚拟地址的bit[0:11]+size,再做4k对齐			一般情况下这3条不会对参数值造成改变
					
					end = addr + length;										//要映射的虚拟end地址
					next = pgd_addr_end(addr, end);								//一般情况next等于end
					alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc, flags)
						if (pgd_none(pgd))
							...													//根据pgd是否为空确定是否要设置pdg的页表，此处在 early_fixmap_init()已经设置
						pudp = pud_set_fixmap_offset(pgdp, addr);				//a返回pud+entry的虚拟地址；先读取pgd entry的内容得到pud页表基地址的物理地址，然后根据要映射的虚拟地址bit[39:32]得到pud的entry，最后得到pud + entry的物理地址，用FIX_PUD得到pud的虚拟地址，加上pud + entry物理地址的bit[0:11]得到对应的虚拟地址, 实际返回的还是pud基地址的虚拟地址，加上pud对应entry物理地址[11:0](物理地址和虚拟地址实际只是一个偏移，所以物理地址[11:0]实际就是pud对应entry)
						...
						next = pud_addr_end(addr, end);							//同上
						if (use_1G_block(addr, next, phys) && (flags & NO_BLOCK_MAPPINGS) == 0) 										//如果bit[0:29]都为0(存在1G block地址映射)，则只需要配置pud，以下的可以省略；
							...
						else
							alloc_init_cont_pmd(pudp, addr, next, phys, prot, pgtable_alloc, flags)
								init_pmd(pudp, addr, next, phys, __prot, pgtable_alloc, flags);
									pmdp = pmd_set_fixmap_offset(pudp, addr);	//得到pmd + entry对应的虚拟地址
									...
									if (((addr | next | phys) & ~SECTION_MASK) == 0 && (flags & NO_BLOCK_MAPPINGS) == 0)				//如果bit[0:20]都为0，就只需要2M的地址映射，只配置pmd，后面的省略
										pmd_set_huge(pmdp, phys, prot);																	//dtb映射只需要到pmd
											...
											pmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), sect_prot);									//phys的bit[11:0]清0，再或上属性值
	
											set_pmd(pmdp, new_pmd);
												WRITE_ONCE(*pmdp, pmd);																	//将带有属性值的物理地址写入pmd + entry的虚拟地址中
									else
										alloc_init_cont_pte(pmdp, addr, next, phys, prot, pgtable_alloc, flags);
											init_pte(pmdp, addr, next, phys, __prot);
												ptep = pte_set_fixmap_offset(pmdp, addr);												//得到pte + entry对应的虚拟地址
												set_pte(ptep, pfn_pte(__phys_to_pfn(phys), prot));
													WRITE_ONCE(*ptep, pte);																//将dtb的物理地址bit[0:11]写入pte entry对应的虚拟地址中
			
			if (fdt_magic(dt_virt) != FDT_MAGIC)
			*size = fdt_totalsize(dt_virt);										//设备树文件内部数据结构参考：4.5.unflatten_device_tree.txt
			
			if (offset + *size > SWAPPER_BLOCK_SIZE)							//如果因为offset的原因导致物理地址+size跨过了一个2M的边界，所以需要第二次map
				create_mapping_noalloc(round_down(dt_phys, SWAPPER_BLOCK_SIZE), dt_virt_base,
						round_up(offset + *size, SWAPPER_BLOCK_SIZE), prot);

		memblock_reserve(dt_phys, size);
			memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);//把dtb的这段内存添加到memblock.reserved，添加时会比较原有内存，并去掉重叠部分


	if (!dt_virt || !early_init_dt_scan(dt_virt))								
		status = early_init_dt_verify(params);
			if (fdt_check_header(params))										//检查dtb的header是否有效
			initial_boot_params = params;										//dtb的虚拟地址保存在全局变量中

		early_init_dt_scan_nodes();
			of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
				early_init_dt_scan_chosen()
					early_init_dt_check_for_initrd(node);						//获取ramdisk信息，起始、终止地址
					of_get_flat_dt_prop(node, "bootargs", &l);					//获取bootargs参数，并保存到boot_command_line全局变量中
				early_init_dt_scan_root()										//获取根节点下的#address-cells(用几个参数来代表一个地址)和#size-cells(用几个参数来代表一个长度)数据
				early_init_dt_scan_memory()
					...
					if (type == NULL || strcmp(type, "memory") != 0)			//获取设备树memory节点，得到内存的起始地址和大小
					...
					reg = of_get_flat_dt_prop(node, "reg", &l);					// l=8, (l / sizeof(__be32))=4
					...
					early_init_dt_add_memory_arch(base, size)
						if (size < PAGE_SIZE - (base & ~PAGE_MASK))				//忽略大小小于4K
						if (!PAGE_ALIGNED(base))								//确定内存起始地址4K对齐，不对齐的话起始地址和size都减去不对齐的部分，
						size &= PAGE_MASK;										//size bit[0:11]清零
						...														//过滤地址和大小不在最大值，最小值范围内的
						memblock_add(base, size);
							memblock_add_range(&memblock.memory, base, size, MAX_NUMNODES, 0);		//确定的内存添加到 memblock.memory的数组中，添加时会比较原有内存，并去掉重叠部分；










