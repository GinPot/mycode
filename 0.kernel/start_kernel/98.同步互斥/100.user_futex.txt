futex：Fast Userspace muTEX

该机制是由Rusty Russell、Hubertus Franke和Mathew Kirkwood在2.5.7版本的内核中引入，虽然名字中有互斥锁（mutex）的含义，
但实际它是一种用于用户空间应用程序的通用同步工具（基于futex可以在userspace实现互斥锁、读写锁、condition variable等同步机制）。Futex组成包括：
1,内核空间的等待队列
2,用户空间层的32-bit futex word（所有平台都是32bit，包括64位平台）


在没有竞争的场景下，锁的获取和释放性能都非常高，不需要内核的参与，仅仅是通过用户空间的原子操作来修改futex word的状态即可。
在有竞争的场景下，如果线程无法获取futex锁，那么把自己放入到 wait queue中（陷入内核，有系统调用的开销），而在owner task释放锁的时候，
如果检测到有竞争（等待队列中有阻塞任务），就会通过系统调用来唤醒等待队列中的任务，使其恢复执行，继续去持锁。如果没有竞争，那么也无需陷入内核。

=============================================================================

   1.多线程程序中：互斥量一般是一个全局变量，所有线程共享此变量，如果该值为0，说明没有被其它线程获取，此时可以成功获取锁，然后将互斥量置为1。如果该值为1，
	说明被其它线程获取了，此时当前线程需要陷入内核态然后挂起。

   2.多进程程序中：互斥量一般使用共享内存表示，使用mmap或者shmat系统调用创建，所以互斥量的虚拟地址可能不同，但是物理地址一样。然后获取锁的策略同上。

=============================================================================

Glibc库中实现有pthread_mutex_lock()/pthread_mutex_unlock()等用户态锁接口，以提供快速的futex机制。

Bionic 的pthread实现中也提供标准的pthread_mutex_lock()/pthread_mutex_unlock()接口，其实现也使用linux futex机制。

=============================================================================

获取不到锁挂起睡眠等待








