
1、dtb load的物理地址要求8字节对齐，并且大小小于2M；映射时和head.s一样只需要3级查表
2、获取dtb的ramdisk信息、bootargs参数、#address/size-cells大小、memory节点信息

=====================================================================================================


#define PMD_SHIFT       21
#define SECTION_SHIFT		PMD_SHIFT
#define SECTION_SIZE		(_AC(1, UL) << SECTION_SHIFT)
#define SWAPPER_BLOCK_SIZE	SECTION_SIZE

#define SECTION_MASK		(~(SECTION_SIZE-1))

#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)						//可以理解为：#define round_up(x, y) ，大于等x并接近x的可以整除y的那个数
#define round_down(x, y) ((x) & ~__round_mask(x, y))							//可以理解为：#define round_down(x, y) ((x/y) * y)	小于等x并接近x的可以整除y的那个数include\linux\kernel.h
					

#define pgd_offset_raw(pgd, addr)	((pgd) + pgd_index(addr))					//获取


#define PGDIR_SIZE		(_AC(1, UL) << PGDIR_SHIFT)								// 1 << 39
#define PGDIR_MASK		(~(PGDIR_SIZE-1))										// ~((1 << 39) - 1)
#define pgd_addr_end(addr, end)						\
({	unsigned long __boundary = ((addr) + PGDIR_SIZE) & PGDIR_MASK;	\			//只取bit[39:63]的数据，其他bit清零
	(__boundary - 1 < (end) - 1)? __boundary: (end);		\
})



#define pud_offset_phys(dir, addr)	(pgd_page_paddr( (*(dir))) + pud_index(addr) * sizeof(pud_t))	//从ffff0000117f2000(pgd) + virt(bit[39:47])*8(entry)虚拟地址中，得到基于pud的物理地址加上entry偏移*8字节得到最终保留下一级查边pmd物理地址的物理地址

#define __set_fixmap_offset(idx, phys, flags)				\
({									\
	unsigned long ________addr;					\
	__set_fixmap(idx, phys, flags);					\
	________addr = fix_to_virt(idx) + ((phys) & (PAGE_SIZE - 1));	\
	________addr;							\
})
#define set_fixmap_offset(idx, phys) __set_fixmap_offset(idx, phys, FIXMAP_PAGE_NORMAL)				//FIX_PUD的虚拟地址，加上(pud的物理地址加上entry偏移*8字节)的bit[0:11]位的数据，最终得到(pud的物理地址加上entry偏移*8字节)对应的虚拟地址
#define pud_set_fixmap(addr)		((pud_t *)set_fixmap_offset(FIX_PUD, addr))
#define pud_set_fixmap_offset(pgd, addr)	pud_set_fixmap(pud_offset_phys(pgd, addr))

=====================================================================================================
#define __initdata_memblock

struct memblock memblock __initdata_memblock = {
	.memory.regions		= memblock_memory_init_regions,
	.memory.cnt		= 1,	/* empty dummy entry */
	.memory.max		= INIT_MEMBLOCK_REGIONS,
	.memory.name		= "memory",

	.reserved.regions	= memblock_reserved_init_regions,
	.reserved.cnt		= 1,	/* empty dummy entry */
	.reserved.max		= INIT_MEMBLOCK_RESERVED_REGIONS,
	.reserved.name		= "reserved",

	.bottom_up		= false,
	.current_limit		= MEMBLOCK_ALLOC_ANYWHERE,
};

cat /sys/kernel/debug/memblock

=====================================================================================================

CONFIG_NODES_SHIFT=2
#define NODES_SHIFT     CONFIG_NODES_SHIFT
#define MAX_NUMNODES    (1 << NODES_SHIFT)	100


pgd + pud + pmd + pte + offset




setup_machine_fdt()
	void *dt_virt = fixmap_remap_fdt(dt_phys);
		dt_virt = __fixmap_remap_fdt(dt_phys, &size, PAGE_KERNEL_RO);
			dt_virt_base = __fix_to_virt(FIX_FDT);								//取fix_fdt的虚拟地址
			...																	//检测fdt的物理地址是否存在，是否8字节对齐
			...																	//检测虚拟地址是否2M对齐
			offset = dt_phys % SWAPPER_BLOCK_SIZE;								//取物理地址的bit[20:0]数据
			dt_virt = (void *)dt_virt_base + offset;							//虚拟地址+物理地址的bit[20:0]
			create_mapping_noalloc(round_down(dt_phys, SWAPPER_BLOCK_SIZE), dt_virt_base, SWAPPER_BLOCK_SIZE, PAGE_KERNEL_RO);			//这里dtb物理地址用了round_down，使得映射的虚拟地址包含了，实际的虚拟地址也要加上上面计算出来的offset
				__create_pgd_mapping(init_mm.pgd, phys, virt, size, prot, NULL, NO_CONT_MAPPINGS);
					pgd_t *pgdp = pgd_offset_raw(pgdir, virt);					//init_pg_dir(head.s配置的页表)虚拟地址,实际ffff0000117f2000(pgd) + virt(bit[39:47])*8(entry),(因为前面是64位地址加index)
					...
					phys &= PAGE_MASK;											//dtb的物理地址bit[0:11]清零
					addr = virt & PAGE_MASK;									//要映射的虚拟地址bit[0:11]清零
					length = PAGE_ALIGN(size + (virt & ~PAGE_MASK));			//要映射虚拟地址的bit[0:11]+size,再做4k对齐
					
					end = addr + length;										//要映射的虚拟end地址
					next = pgd_addr_end(addr, end);								//根据要映射的size初始化pud，此处只有一个pgd；
					alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc, flags)
						if (pgd_none(pgd))
							...													//根据pgd是否为空确定是否要设置pdg的页表，此处在early_fixmap_init()已经设置
						pudp = pud_set_fixmap_offset(pgdp, addr);				//addr为fix_fdt的虚拟地址bit[0:11]清零，返回pud对应entry的虚拟地址；先读取pgd entry的内容得到pud页表基地址的物理地址，然后根据要映射的虚拟地址得到pud的entry，计算得到pud entry的物理地址，用FIX_PUD得到pud的虚拟地址，加上pud entry物理地址的bit[0:11]得到对应的虚拟地址
						...
						next = pud_addr_end(addr, end);							//同上
						if (use_1G_block(addr, next, phys) && (flags & NO_BLOCK_MAPPINGS) == 0) 										//如果bit[0:29]都为0(存在1G block地址映射)，则只需要配置pud，以下的可以省略；
							...
						else
							alloc_init_cont_pmd(pudp, addr, next, phys, prot, pgtable_alloc, flags)
								init_pmd(pudp, addr, next, phys, __prot, pgtable_alloc, flags);
									pmdp = pmd_set_fixmap_offset(pudp, addr);	//得到pmd entry对应的虚拟地址
									...
									if (((addr | next | phys) & ~SECTION_MASK) == 0 && (flags & NO_BLOCK_MAPPINGS) == 0)				//如果bit[0:20]都为0，就只需要2M的地址映射，只配置pmd，后面的省略
										pmd_set_huge(pmdp, phys, prot);																	//dtb可能只需要2M
											set_pmd(pmdp, new_pmd);
												WRITE_ONCE(*pmdp, pmd);
									else
										alloc_init_cont_pte(pmdp, addr, next, phys, prot, pgtable_alloc, flags);
											init_pte(pmdp, addr, next, phys, __prot);
												ptep = pte_set_fixmap_offset(pmdp, addr);												//得到pte entry对应的虚拟地址
												set_pte(ptep, pfn_pte(__phys_to_pfn(phys), prot));
													WRITE_ONCE(*ptep, pte);																//将dtb的物理地址bit[0:11]写入pte entry对应的虚拟地址中
			
			if (fdt_magic(dt_virt) != FDT_MAGIC)
			*size = fdt_totalsize(dt_virt);
			
			if (offset + *size > SWAPPER_BLOCK_SIZE)							//如果因为offset的原因导致物理地址+size跨过了一个2M的边界，所以需要第二次map
				create_mapping_noalloc(round_down(dt_phys, SWAPPER_BLOCK_SIZE), dt_virt_base,
						round_up(offset + *size, SWAPPER_BLOCK_SIZE), prot);

		memblock_reserve(dt_phys, size);
			memblock_add_range(&memblock.reserved, base, size, MAX_NUMNODES, 0);//把dtb的这段内存添加到memblock.reserved，添加时会比较原有内存，并去掉重叠部分


	if (!dt_virt || !early_init_dt_scan(dt_virt))								
		status = early_init_dt_verify(params);
			if (fdt_check_header(params))										//检查dtb的header是否有效
			initial_boot_params = params;										//dtb的虚拟地址保存在全局变量中

		early_init_dt_scan_nodes();
			of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
				early_init_dt_scan_chosen()
					early_init_dt_check_for_initrd(node);						//获取ramdisk信息，起始、终止地址
					of_get_flat_dt_prop(node, "bootargs", &l);					//获取bootargs参数，并保存到boot_command_line全局变量中
				early_init_dt_scan_root()										//获取根节点下的#address-cells(用几个参数来代表一个地址)和#size-cells(用几个参数来代表一个长度)数据
				early_init_dt_scan_memory()
					...
					if (type == NULL || strcmp(type, "memory") != 0)			//获取设备树memory节点，得到内存的起始地址和大小
					...
					early_init_dt_add_memory_arch(base, size)
						if (size < PAGE_SIZE - (base & ~PAGE_MASK))				//忽略大小小于4K
						if (!PAGE_ALIGNED(base))								//确定内存起始地址4K对齐，不对齐的话起始地址和size都减去不对齐的部分，
						size &= PAGE_MASK;										//size bit[0:11]清零
						...														//过滤地址和大小不在最大值，最小值范围内的
						memblock_add(base, size);
							memblock_add_range(&memblock.memory, base, size, MAX_NUMNODES, 0);		//确定的内存添加到memblock.memory的数组中，添加时会比较原有内存，并去掉重叠部分；










