
#define PHYS_OFFSET		({ VM_BUG_ON(memstart_addr & 1); memstart_addr; })
#define __phys_to_virt(x)	((unsigned long)((x) - PHYS_OFFSET) | PAGE_OFFSET)		//物理地址相对起始地址的偏移，或上起始虚拟线性地址0xffff800000000000，得到虚拟地址



#define ARM64_MEMSTART_SHIFT		PUD_SHIFT
#define ARM64_MEMSTART_ALIGN	(1UL << ARM64_MEMSTART_SHIFT)	(1<<30)






arm64_memblock_init();
	const s64 linear_region_size = -(s64)PAGE_OFFSET;								//得到虚拟地址线性映射区域大小

	fdt_enforce_memory_region();													//获取dtb的linux,usable-memory-range节点属性，H5无
	
	memblock_remove(1ULL << PHYS_MASK_SHIFT, ULLONG_MAX);							//移除起始地址(1<<48)后面的物理地址
	
	BUILD_BUG_ON(linear_region_size != BIT(VA_BITS - 1));							//虚拟线性区为内核虚拟地址的一半，即1<<47

	memstart_addr = round_down(memblock_start_of_DRAM(), ARM64_MEMSTART_ALIGN);		//物理内存地址向下1G对齐

	memblock_remove(max_t(u64, memstart_addr + linear_region_size, __pa_symbol(_end)), ULLONG_MAX);			//移除(物理起始地址+虚拟线性区)为起始地址后的地址

	if (memstart_addr + linear_region_size < memblock_end_of_DRAM()) {				//一般不会有这么大的内存，有的话也把0~(memblock_end_of_DRAM() - linear_region_size)向上1G对齐的空间移除
		/* ensure that memstart_addr remains sufficiently aligned */
		memstart_addr = round_up(memblock_end_of_DRAM() - linear_region_size,
					 ARM64_MEMSTART_ALIGN);
		memblock_remove(0, memstart_addr);
	}

	if (memory_limit != PHYS_ADDR_MAX) {											//未设置内存限制
		memblock_mem_limit_remove_map(memory_limit);
		memblock_add(__pa_symbol(_text), (u64)(_end - _text));
	}
	
/*****************************************************************************************************************************************/
	
	if (IS_ENABLED(CONFIG_BLK_DEV_INITRD) && phys_initrd_size){
		memblock_remove(base, size); /* clear MEMBLOCK_ flags */
		memblock_add(base, size);
		memblock_reserve(base, size);												//把initrd内存添加到 reserve 和memory中；remove的内存相当于no map；之前在fixmap中已经 reserve 了dtb物理地址
	}

	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)){
		...																			//如果使能，且虚拟地址的线性区比实际物理地址大，线性区域也随机化
	}

	memblock_reserve(__pa_symbol(_text), _end - _text);								//内核_text对应的物理地址添加到 reserve
	if (IS_ENABLED(CONFIG_BLK_DEV_INITRD) && phys_initrd_size) {					//定义CONFIG_BLK_DEV_INITRD,并且设置了initrd
		/* the generic initrd code expects virtual addresses */
		initrd_start = __phys_to_virt(phys_initrd_start);							//计算得到initrd起始、结束的虚拟地址
		initrd_end = initrd_start + phys_initrd_size;
	}

	early_init_fdt_scan_reserved_mem()
		...
		early_init_dt_reserve_memory_arch(base, size, 0);							//从dtb的header中获取off_mem_rsvmap得到reserv ememory添加到 reserve 中
		of_scan_flat_dt(__fdt_scan_reserved_mem, NULL);
			if (!found && depth == 1 && strcmp(uname, "reserved-memory") == 0)		//遍历所有深度为1的节点名字是否是reserved-memory
				if (__reserved_mem_check_root(node) != 0)							//确定节点有#size-cells、#address-cells、ranges属性
				...
			if (!of_fdt_device_is_available(initial_boot_params, node))				//确定节点有效性status=ok/okay，或者没有status,然后退出，下次进来就是这个节点的子节点
			err = __reserved_mem_reserve_reg(node, uname);
				...																	//获取节点属性(内存地址、大小，是否nomap)
				early_init_dt_reserve_memory_arch(base, size, nomap)				//然后对应的remove、reserve内存,这些region可以从节点中获取确定的起始地址和size
				fdt_reserved_mem_save_node(node, uname, base, size)					//同时把节点信息加入到全局数组reserved_mem中
			if(err == -ENOENT && of_get_flat_dt_prop(node, "size", NULL))			//如果该节点没有reg信息，且有size信息
				fdt_reserved_mem_save_node(node, uname, 0, 0);						//把节点信息保存到全局数组reserved_mem中，base和size设置0
	
		fdt_init_reserved_mem()
			__rmem_check_for_overlap();												//检测reserved区是否有重叠，不处理，仅报错
			for (i = 0; i < reserved_mem_count; i++)								//遍历reserved_mem数组
				err = __reserved_mem_alloc_size(node, rmem->name, &rmem->base, &rmem->size);			//根据节点的size，从memblock中找一段大小为size的内存去reserved或remove
					prop = of_get_flat_dt_prop(node, "alloc-ranges", &len);			//节点有alloc-ranges属性时，从这个属性参数中找size操作
					...
					early_init_dt_alloc_reserved_memory_arch()						//自下而上，或自上而下找到后操作内存
				err = __reserved_mem_init_node(rmem);								//在__reservedmem_of_table段中读取信息，看是否匹配reserved_mem数组的节点compatible，匹配的话
																					//就调用对应的函数，一般由RESERVEDMEM_OF_DECLARE定义compatible和函数，ld连接近对应的代码段中
	
	reserve_crashkernel();
	reserve_elfcorehdr();

memblock先是通过dtb得到系统内存，然后把系统不能使用的内存添加到reserve(dtb、_text、initrd)中



