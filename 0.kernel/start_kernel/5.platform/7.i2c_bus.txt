i2c总线：

1、i2c bus注册，并注册一个dummy i2c driver；
2、i2c adapter基于platform device/driver注册驱动；
3、i2c devices基于i2c bus的驱动加载；

4、driver是在注册的过程中调用不同的API接口时将会设置driver对应的bus结构体(bus_type),device也类似；根据bus设置的状态(注册该bus时设置sysfs、drivers_autoprobe等)去probe该bus下的设备驱动

==============================================================================

i2c probe：

1、i2c设备probe方案：
	1.1、驱动的 of_match_table 与设备树的compatible匹配；
	1.2、嵌入式无acpi；
	1.3、驱动的 id_table.name与i2c_client.name(一般是i2c设备节点的compatible对应的字段“,”号后面的字符(如x-power,ac108，则为ac108))匹配；
2、用i2c bus的probe进行probe；
3、i2c还可通过 address_list 调用detect探测确认来注册i2c设备；


==============================================================================




struct bus_type i2c_bus_type = {
	.name		= "i2c",
	.match		= i2c_device_match,			//驱动设备匹配
	.probe		= i2c_device_probe,			//probe
	.remove		= i2c_device_remove,
	.shutdown	= i2c_device_shutdown,
};


#define postcore_initcall(fn)		__define_initcall(fn, 2)
postcore_initcall(i2c_init)
	i2c_init()
		retval = of_alias_get_highest_id("i2c")						//取第一个i2c的别名ID, 别名参考4.5.unflatten_device_tree.txt
		if (retval >= __i2c_first_dynamic_bus_num)
			__i2c_first_dynamic_bus_num = retval + 1;				//在全局变量__i2c_first_dynamic_bus_num中记录i2c bus的数量
		bus_register(&i2c_bus_type)									//创建/dev/bus/下的i2c目录对应的object 888
		i2c_adapter_compat_class = class_compat_register("i2c-adapter")			//在/sys/class/下面创建i2c-adapter文件夹的object
		i2c_add_driver(&dummy_driver)								//意义不大？ 已经有了i2c总线，注册一个空的i2c驱动 888
			i2c_register_driver(THIS_MODULE, dummy_driver)
				driver->driver.owner = owner
				driver->driver.bus = &i2c_bus_type
				driver_register(&driver->driver)					//同8.platform_driver.txt描述
					bus_add_driver(drv)
						kobject_init_and_add(&priv->kobj, &driver_ktype, NULL, "%s", drv->name)			//所有驱动注册时都会在对应的bus(/sys/bus/i2c/drivers)下创建驱动name的文件夹
						if(drv->bus->p->drivers_autoprobe)
							driver_attach(drv)
								__driver_attach()
									driver_match_device(drv, dev)
										i2c_device_match			///i2c bus匹配过程 888
											if(i2c_of_match_device(drv->of_match_table, client))		//驱动的of_match_table与设备树的compatible匹配
											if(acpi_driver_match_device(dev, drv))
											if(i2c_match_id(driver->id_table, client)					//驱动的id_table.name与dtb节点对应的设备name匹配
									device_driver_attach(drv, dev)
										driver_probe_device(drv, dev)
											really_probe(dev, drv)
												if(dev->bus->probe)
													dev->bus->probe(dev)								//用i2c bus的probe进行probe
														if(driver->probe)								//最后调用i2c驱动的probe
															driver->probe()
				i2c_for_each_dev(driver, __process_new_driver)											//若上面为成功probe，并设置了detect探测的方式probe
					bus_for_each_dev(&i2c_bus_type, NULL, data, fn)										//对dtb里的每个i2c节点所述的adapter进行探测
						i2c_do_add_adapter(data, to_i2c_adapter(dev))
							i2c_detect(adap, driver)
								if(!driver->detect || !address_list)									//该注册的i2c驱动需要有detect和address_list
								for (i = 0; address_list[i] != I2C_CLIENT_END; i += 1)					//每个i2c adapter去挨个用address_list的i2c地址去尝试是否可以通信
									i2c_detect_address(temp_client, driver)								//可以通信的话调用.detect(i2c驱动实现)函数确定i2c设备,即填充info->type，后续会赋值给client->name
										i2c_new_device(adapter, &info)									//根据detect新的info信息(client->name)创建新的i2c device再次注册驱动
											device_register(&client->dev)










static const struct i2c_device_id ac108_i2c_id[] = {
	{ "adm1025", adm1025 },
	{ "ne1619", ne1619 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, ac108_i2c_id);

static struct i2c_driver ac108_i2c_driver = {
	.class = I2C_CLASS_HWMON,
	.driver = {
		.name = "ac108",
		.owner = THIS_MODULE,
		//.of_match_table = ac108_dt_ids,	//1.匹配dts里的I2C信息去probe
	},
	.probe = ac108_i2c_probe,
	.remove = ac108_i2c_remove,
	.id_table = ac108_i2c_id,				//2.用 id_table.name与 i2c_client.name 匹配

	.address_list = ac108_i2c_addr,	//3.1.每个i2c adapter去挨个用address_list的i2c地址去尝试是否可以通信
	.detect = ac108_i2c_detect,		//3.2.可以通信的话调用.detect(i2c驱动实现)函数确定i2c设备,即填充info->type，后续会赋值给client->name注册新的i2c client

};



&i2c {
	status = "okay";
	#address-cells = <0x1>;
	#size-cells = <0x0>;

	asm330lhh@6a {
		compatible = "st,asm330lhh";
		reg = <0x6a>;
		interrupt-parent = <&tlmm>;
		interrupts = <41 IRQ_TYPE_LEVEL_HIGH>;								//在调用bus->probe时解析得到：really_probe(dev, drv) ==> dev->bus->probe(dev) ==> i2c_device_probe ==> of_irq_parse_one(dev->of_node, 0)
		pinctrl-names = "default";
		pinctrl-0 = <&asm330_int1_default &asm330_int2_default>;			//在调用probe前解析：driver_probe_device() ==> pinctrl_bind_pins(dev)根据dts设置为对应的复用功能、上下拉、驱动力等
		host-notify;														//用i2c adapter的中断作为i2c设备的中断,H5不支持改功能
	};
};








