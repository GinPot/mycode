arch\arm64\include\asm\pgtable-hwdef.h
arch\arm64\include\asm\kernel-pgtable.h

tbl		adrp	x0, idmap_pg_dir
rtbl	ldrp	x1, #0
vstart	adrp	x3, __idmap_text_start
vend	adr_l	x6, __idmap_text_end
flags	mov	x7, SWAPPER_MM_MMUFLAGS
#define SWAPPER_MM_MMUFLAGS	(PMD_ATTRINDX(MT_NORMAL) | (PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S))

pgds	ldr_l	x4, idmap_ptrs_per_pgd(1 << 9) = 0x200
	u64 idmap_ptrs_per_pgd = PTRS_PER_PGD;
	#define MAX_USER_VA_BITS	VA_BITS（48）
	#define PTRS_PER_PGD		(1 << (MAX_USER_VA_BITS - PGDIR_SHIFT))

	CONFIG_PGTABLE_LEVELS=4
	#define SWAPPER_PGTABLE_LEVELS	(CONFIG_PGTABLE_LEVELS - 1)

	#define PAGE_SHIFT 12
	#define ARM64_HW_PGTABLE_LEVEL_SHIFT(n)	((PAGE_SHIFT - 3) * (4 - (n)) + 3)
	#define PUD_SHIFT		ARM64_HW_PGTABLE_LEVEL_SHIFT(1)
	#define SWAPPER_TABLE_SHIFT	PUD_SHIFT

	#define PTRS_PER_PTE		(1 << (PAGE_SHIFT - 3))
	#define PTRS_PER_PMD		PTRS_PER_PTE

	#define PMD_SHIFT		ARM64_HW_PGTABLE_LEVEL_SHIFT(2)
	#define SECTION_SHIFT		PMD_SHIFT
	#define SECTION_SIZE		(_AC(1, UL) << SECTION_SHIFT)
	#define SWAPPER_BLOCK_SIZE	SECTION_SIZE		//粒度为2M

	#define PMD_TYPE_TABLE		(_AT(pmdval_t, 3) << 0)(3),表示为普通内存

map_memory, tbl, rtbl, vstart, vend, flags, phys, pgds, istart, iend, tmp, count, sv
map_memory  x0,  x1,   x3,     x6,   x7,    x3,   x4,   x10,    x11,  x12, x13,   x14
	add \rtbl, \tbl, #PAGE_SIZE		//PUD = PGD + 4k 的地址
	mov \sv, \rtbl					//sv=PUD
	mov \count, #0
	compute_indices \vstart, \vend, #PGDIR_SHIFT(bit[47:39]), \pgds, \istart, \iend, \count						//根据__idmap_text_start的物理地址设置PGD的描述符
	populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp
	mov \tbl, \sv					//tbl=PUD
	mov \sv, \rtbl					//sv=PMD

	compute_indices \vstart, \vend, #SWAPPER_TABLE_SHIFT(bit[38:30]), #PTRS_PER_PMD, \istart, \iend, \count		//根据__idmap_text_start的物理地址设置PMD的描述符
	populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp
	mov \tbl, \sv

	compute_indices \vstart, \vend, #SWAPPER_BLOCK_SHIFT(bit[29:21]), #PTRS_PER_PTE, \istart, \iend, \count		//根据__idmap_text_start的物理地址设置PUD的描述符
	bic \count, \phys, #SWAPPER_BLOCK_SIZE - 1
	populate_entries \tbl, \count, \istart, \iend, \flags, #SWAPPER_BLOCK_SIZE, \tmp
	.endm





							#PGDIR_SHIFT(#39), \pgds,
.macro compute_indices, vstart, vend, shift, ptrs, istart, iend, count
	lsr	\iend, \vend, \shift		//把vend右移39位，为了保留bit[47:39]位的数据；
	mov	\istart, \ptrs				//istart=0x200
	sub	\istart, \istart, #1		//0x200-1=0x1FF，即bit[8:0]都为1的mask掩码
	and	\iend, \iend, \istart		// iend = (vend >> 39) & (0x200 - 1)
	mov	\istart, \ptrs				//istart=0x200
	mul	\istart, \istart, \count	//istart=0x200 * 0 = 0
	add	\iend, \iend, \istart		// iend += 0
					// our entries span multiple tables

	lsr	\istart, \vstart, \shift
	mov	\count, \ptrs
	sub	\count, \count, #1
	and	\istart, \istart, \count	//主要就是把vstart右移39位，为了保留bit[47:39]位上的数据，并与上0x1FF(bit[8:0]都为1)

	sub	\count, \iend, \istart		//计算vstart, vend差值,一般应该为0
	.endm


									\istart,\iend,#PMD_TYPE_TABLE,#PAGE_SIZE
.macro populate_entries, tbl, rtbl, index, eindex, flags, inc, tmp1
.Lpe\@:	phys_to_pte \tmp1, \rtbl	//
	orr	\tmp1, \tmp1, \flags		// tmp1 = table entry,设置PUD基地址属性，告知改描述符是否有效bit0，该描述符是哪种类型bit1
	str	\tmp1, [\tbl, \index, lsl #3]	//把PUD基地址存放到PGD地址的index(__idmap_text_start地址的bit[47:39]位的数据)处，左移3位，是因为一个描述符占用8字节空间，总共可以存放512个描述符，总共占用4096字节空间
	add	\rtbl, \rtbl, \inc			// rtbl = pa next level,即指向PMD
	add	\index, \index, #1
	cmp	\index, \eindex
	b.ls	.Lpe\@
	.endm








				 
				 